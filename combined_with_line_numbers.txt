from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel
from enum import Enum


class OrganizationRole(str, Enum):
    OWNER = "owner"
    ADMIN = "admin"
    MEMBER = "member"
    VIEWER = "viewer"


class UserOrganizationRole(BaseModel):
    id: UUID
    user_id: UUID
    organization_id: UUID
    role: OrganizationRole
    assigned_by: UUID
    assigned_at: datetime
    expires_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        organization_id: UUID,
        role: OrganizationRole,
        assigned_by: UUID,
        expires_at: Optional[datetime] = None
    ) -> "UserOrganizationRole":
        return cls(
            id=uuid4(),
            user_id=user_id,
            organization_id=organization_id,
            role=role,
            assigned_by=assigned_by,
            assigned_at=datetime.utcnow(),
            expires_at=expires_at,
            is_active=True
        )

    def change_role(self, new_role: OrganizationRole, changed_by: UUID) -> "UserOrganizationRole":
        """Change user role in organization."""
        return self.model_copy(update={
            "role": new_role,
            "assigned_by": changed_by,
            "assigned_at": datetime.utcnow()
        })

    def deactivate(self) -> "UserOrganizationRole":
        """Deactivate user role in organization."""
        return self.model_copy(update={"is_active": False})

    def activate(self) -> "UserOrganizationRole":
        """Activate user role in organization."""
        return self.model_copy(update={"is_active": True})

    def is_expired(self) -> bool:
        """Check if role assignment has expired."""
        if not self.expires_at:
            return False
        return datetime.utcnow() > self.expires_at

    def is_valid(self) -> bool:
        """Check if role assignment is valid (active and not expired)."""
        return self.is_active and not self.is_expired()

    def has_admin_privileges(self) -> bool:
        """Check if role has admin privileges."""
        return self.role in [OrganizationRole.OWNER, OrganizationRole.ADMIN]

    def can_manage_users(self) -> bool:
        """Check if role can manage other users."""
        return self.role in [OrganizationRole.OWNER, OrganizationRole.ADMIN]

    def can_modify_organization(self) -> bool:
        """Check if role can modify organization settings."""
        return self.role == OrganizationRole.OWNER
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List
from pydantic import BaseModel

from ..value_objects.organization_name import OrganizationName
from ..value_objects.organization_settings import OrganizationSettings


class Organization(BaseModel):
    id: UUID
    name: OrganizationName
    description: Optional[str] = None
    owner_id: UUID
    settings: OrganizationSettings
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls, 
        name: str, 
        owner_id: UUID, 
        description: Optional[str] = None,
        max_users: int = 10
    ) -> "Organization":
        return cls(
            id=uuid4(),
            name=OrganizationName(value=name),
            description=description,
            owner_id=owner_id,
            settings=OrganizationSettings.create_default(max_users=max_users),
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "Organization":
        return self.model_copy(update={
            "name": OrganizationName(value=name),
            "updated_at": datetime.utcnow()
        })

    def update_description(self, description: str) -> "Organization":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def transfer_ownership(self, new_owner_id: UUID) -> "Organization":
        return self.model_copy(update={
            "owner_id": new_owner_id,
            "updated_at": datetime.utcnow()
        })

    def update_settings(self, settings: OrganizationSettings) -> "Organization":
        return self.model_copy(update={
            "settings": settings,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Organization":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Organization":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })

    def is_owner(self, user_id: UUID) -> bool:
        """Check if user is the owner of this organization."""
        return self.owner_id == user_id

    def can_add_users(self, current_user_count: int) -> bool:
        """Check if organization can add more users based on settings."""
        return current_user_count < self.settings.max_users

    def validate_user_limit(self, new_user_count: int) -> tuple[bool, str]:
        """Validate if organization can support the new user count."""
        if new_user_count > self.settings.max_users:
            return False, f"Organization exceeds maximum user limit of {self.settings.max_users}"
        return True, "User limit validation passed"
from .organization import Organization
from .user_organization_role import UserOrganizationRole

__all__ = ["Organization", "UserOrganizationRole"]
from typing import List
from uuid import UUID

from ..entities.user_organization_role import UserOrganizationRole, OrganizationRole
from ..repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)
from ..repositories.organization_repository import OrganizationRepository


class MembershipService:
    """Domain service for organization membership logic."""

    def __init__(
        self,
        role_repository: UserOrganizationRoleRepository,
        organization_repository: OrganizationRepository,
    ):
        self._role_repository = role_repository
        self._organization_repository = organization_repository

    def add_user_to_organization(
        self,
        user_id: UUID,
        organization_id: UUID,
        role: OrganizationRole,
        assigned_by: UUID,
    ) -> UserOrganizationRole:
        """Add user to organization with specified role."""
        # Check if user already has a role in this organization
        existing_role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if existing_role and existing_role.is_valid():
            raise ValueError("User already has an active role in this organization")

        # Create new role assignment
        new_role = UserOrganizationRole.create(
            user_id=user_id,
            organization_id=organization_id,
            role=role,
            assigned_by=assigned_by,
        )

        return self._role_repository.save(new_role)

    def change_user_role(
        self,
        user_id: UUID,
        organization_id: UUID,
        new_role: OrganizationRole,
        changed_by: UUID,
    ) -> UserOrganizationRole:
        """Change user's role in organization."""
        current_role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if not current_role or not current_role.is_valid():
            raise ValueError("User does not have an active role in this organization")

        # Prevent changing owner role without proper transfer
        if current_role.role == OrganizationRole.OWNER:
            raise ValueError(
                "Cannot change owner role. Use ownership transfer instead."
            )

        updated_role = current_role.change_role(new_role, changed_by)
        return self._role_repository.save(updated_role)

    def remove_user_from_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> bool:
        """Remove user from organization."""
        # Check if user is organization owner
        organization = self._organization_repository.get_by_id(organization_id)

        if organization and organization.is_owner(user_id):
            raise ValueError(
                "Cannot remove organization owner. Transfer ownership first."
            )

        return self._role_repository.remove_user_from_organization(
            user_id, organization_id
        )

    def get_user_permissions_in_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> List[str]:
        """Get list of permissions user has in organization."""
        role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if not role or not role.is_valid():
            return []

        # Define permissions based on role
        permissions_map = {
            OrganizationRole.OWNER: [
                "manage_organization",
                "manage_users",
                "manage_roles",
                "view_analytics",
                "manage_settings",
                "delete_organization",
                "transfer_ownership",
            ],
            OrganizationRole.ADMIN: [
                "manage_users",
                "manage_roles",
                "view_analytics",
                "manage_settings",
            ],
            OrganizationRole.MEMBER: ["view_organization", "use_features"],
            OrganizationRole.VIEWER: ["view_organization"],
        }

        return permissions_map.get(role.role, [])

    def can_user_perform_action(
        self, user_id: UUID, organization_id: UUID, action: str
    ) -> bool:
        """Check if user can perform specific action in organization."""
        permissions = self.get_user_permissions_in_organization(
            user_id, organization_id
        )
        return action in permissions

    def transfer_ownership(
        self, organization_id: UUID, current_owner_id: UUID, new_owner_id: UUID
    ) -> tuple[UserOrganizationRole, UserOrganizationRole]:
        """Transfer organization ownership."""
        # Get current owner role
        owner_role = self._role_repository.get_by_user_and_organization(
            current_owner_id, organization_id
        )

        if not owner_role or owner_role.role != OrganizationRole.OWNER:
            raise ValueError("Current user is not the organization owner")

        # Get new owner's current role
        new_owner_role = self._role_repository.get_by_user_and_organization(
            new_owner_id, organization_id
        )

        if not new_owner_role or not new_owner_role.is_valid():
            raise ValueError("New owner must be an active member of the organization")

        # Update organization owner
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        updated_organization = organization.transfer_ownership(new_owner_id)
        self._organization_repository.save(updated_organization)

        # Change roles
        demoted_owner = owner_role.change_role(OrganizationRole.ADMIN, new_owner_id)
        promoted_owner = new_owner_role.change_role(
            OrganizationRole.OWNER, current_owner_id
        )

        # Save role changes
        self._role_repository.save(demoted_owner)
        self._role_repository.save(promoted_owner)

        return demoted_owner, promoted_owner
from typing import Optional, List
from uuid import UUID

from ..entities.organization import Organization
from ..entities.user_organization_role import UserOrganizationRole, OrganizationRole
from ..value_objects.organization_name import OrganizationName
from ..repositories.organization_repository import OrganizationRepository
from ..repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)


class OrganizationDomainService:
    """Domain service for organization-specific business logic."""

    def __init__(
        self,
        organization_repository: OrganizationRepository,
        role_repository: UserOrganizationRoleRepository,
    ):
        self._organization_repository = organization_repository
        self._role_repository = role_repository

     def is_organization_name_available(
        self, name: OrganizationName, excluding_org_id: Optional[UUID] = None
    ) -> bool:
        """Check if organization name is available."""
        existing_org = self._organization_repository.get_by_name(name)

        if not existing_org:
            return True

        # If excluding a specific org (for updates), check if it's the same org
        if excluding_org_id and existing_org.id == excluding_org_id:
            return True

        return False

     def can_organization_be_deleted(
        self, organization_id: UUID
    ) -> tuple[bool, str]:
        """Check if organization can be safely deleted."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return False, "Organization not found"

        # Check if organization has active members
        user_count = self._role_repository.count_organization_users(organization_id)

        if user_count > 1:  # Owner + other members
            return (
                False,
                f"Organization has {user_count} active members and cannot be deleted",
            )

        return True, "Can be deleted"

     def can_user_leave_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> tuple[bool, str]:
        """Check if user can leave organization."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return False, "Organization not found"

        # Owner cannot leave organization
        if organization.is_owner(user_id):
            return False, "Organization owner cannot leave. Transfer ownership first."

        user_role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if not user_role:
            return False, "User is not a member of this organization"

        return True, "User can leave organization"

     def can_transfer_ownership(
        self, organization_id: UUID, current_owner_id: UUID, new_owner_id: UUID
    ) -> tuple[bool, str]:
        """Check if ownership can be transferred."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return False, "Organization not found"

        if not organization.is_owner(current_owner_id):
            return False, "Only organization owner can transfer ownership"

        # Check if new owner is a member of the organization
        new_owner_role = self._role_repository.get_by_user_and_organization(
            new_owner_id, organization_id
        )

        if not new_owner_role or not new_owner_role.is_valid():
            return False, "New owner must be an active member of the organization"

        return True, "Ownership can be transferred"

     def validate_user_addition(
        self, organization_id: UUID, role: OrganizationRole
    ) -> tuple[bool, str]:
        """Validate if a new user can be added to organization."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return False, "Organization not found"

        if not organization.is_active:
            return False, "Cannot add users to inactive organization"

        current_user_count = self._role_repository.count_organization_users(
            organization_id
        )

        if not organization.can_add_users(current_user_count):
            return (
                False,
                f"Organization has reached maximum user limit of {organization.settings.max_users}",
            )

        return True, "User can be added to organization"
from .organization_domain_service import OrganizationDomainService
from .membership_service import MembershipService

__all__ = ["OrganizationDomainService", "MembershipService"]
from pydantic import BaseModel, field_validator
from typing import Dict, Any


class OrganizationSettings(BaseModel):
    max_users: int
    allow_user_registration: bool
    require_email_verification: bool
    session_timeout_hours: int
    features_enabled: Dict[str, bool]
    custom_settings: Dict[str, Any]

    model_config = {"frozen": True}

    @field_validator('max_users')
    @classmethod
    def validate_max_users(cls, v: int) -> int:
        if v < 1:
            raise ValueError("Maximum users must be at least 1")
        if v > 10000:
            raise ValueError("Maximum users cannot exceed 10,000")
        return v

    @field_validator('session_timeout_hours')
    @classmethod
    def validate_session_timeout(cls, v: int) -> int:
        if v < 1:
            raise ValueError("Session timeout must be at least 1 hour")
        if v > 720:  # 30 days
            raise ValueError("Session timeout cannot exceed 720 hours (30 days)")
        return v

    @classmethod
    def create_default(cls, max_users: int = 10) -> "OrganizationSettings":
        return cls(
            max_users=max_users,
            allow_user_registration=True,
            require_email_verification=True,
            session_timeout_hours=24,
            features_enabled={
                "chat_whatsapp": False,
                "chat_iframe": False,
                "api_access": True,
                "custom_branding": False,
                "analytics": True
            },
            custom_settings={}
        )

    def enable_feature(self, feature_name: str) -> "OrganizationSettings":
        """Enable a specific feature."""
        new_features = self.features_enabled.copy()
        new_features[feature_name] = True
        
        return self.model_copy(update={"features_enabled": new_features})

    def disable_feature(self, feature_name: str) -> "OrganizationSettings":
        """Disable a specific feature."""
        new_features = self.features_enabled.copy()
        new_features[feature_name] = False
        
        return self.model_copy(update={"features_enabled": new_features})

    def is_feature_enabled(self, feature_name: str) -> bool:
        """Check if a feature is enabled."""
        return self.features_enabled.get(feature_name, False)

    def update_max_users(self, new_max: int) -> "OrganizationSettings":
        """Update maximum users limit."""
        return self.model_copy(update={"max_users": new_max})

    def update_custom_setting(self, key: str, value: Any) -> "OrganizationSettings":
        """Update a custom setting."""
        new_custom = self.custom_settings.copy()
        new_custom[key] = value
        
        return self.model_copy(update={"custom_settings": new_custom})

    def get_custom_setting(self, key: str, default: Any = None) -> Any:
        """Get a custom setting value."""
        return self.custom_settings.get(key, default)
from pydantic import BaseModel, field_validator
from typing import Any
import re


class OrganizationName(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Organization name cannot be empty")
        
        cleaned_name = v.strip()
        
        if len(cleaned_name) < 2:
            raise ValueError("Organization name must be at least 2 characters long")
        
        if len(cleaned_name) > 100:
            raise ValueError("Organization name cannot exceed 100 characters")
        
        # Allow letters, numbers, spaces, hyphens, and underscores
        if not re.match(r'^[a-zA-Z0-9\s\-_]+$', cleaned_name):
            raise ValueError("Organization name can only contain letters, numbers, spaces, hyphens, and underscores")
        
        return cleaned_name

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, OrganizationName):
            return self.value == other.value
        return False

    def to_slug(self) -> str:
        """Convert name to URL-friendly slug."""
        return re.sub(r'[^a-zA-Z0-9\-_]', '-', self.value.lower()).strip('-')
from .organization_name import OrganizationName
from .organization_settings import OrganizationSettings

__all__ = ["OrganizationName", "OrganizationSettings"]
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.organization import Organization
from ..value_objects.organization_name import OrganizationName


class OrganizationRepository(ABC):
    """Organization repository interface for the Organization bounded context."""

    @abstractmethod
    def save(self, organization: Organization) -> Organization:
        """Save or update an organization."""
        pass

    @abstractmethod
    def get_by_id(self, organization_id: UUID) -> Optional[Organization]:
        """Get organization by ID."""
        pass

    @abstractmethod
    def get_by_name(self, name: OrganizationName) -> Optional[Organization]:
        """Get organization by name."""
        pass

    @abstractmethod
    def get_by_owner_id(self, owner_id: UUID) -> List[Organization]:
        """Get organizations owned by a user."""
        pass

    @abstractmethod
    def exists_by_name(self, name: OrganizationName) -> bool:
        """Check if organization exists by name."""
        pass

    @abstractmethod
    def delete(self, organization_id: UUID) -> bool:
        """Delete organization by ID."""
        pass

    @abstractmethod
    def list_active_organizations(
        self, limit: int = 100, offset: int = 0
    ) -> List[Organization]:
        """List active organizations with pagination."""
        pass

    @abstractmethod
    def count_active_organizations(self) -> int:
        """Count total active organizations."""
        pass

    @abstractmethod
    def get_user_organizations(self, user_id: UUID) -> List[Organization]:
        """Get organizations where user is a member."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.user_organization_role import UserOrganizationRole, OrganizationRole


class UserOrganizationRoleRepository(ABC):
    """User organization role repository interface for the Organization bounded context."""

    @abstractmethod
    def save(self, role: UserOrganizationRole) -> UserOrganizationRole:
        """Save or update a user organization role."""
        pass

    @abstractmethod
    def get_by_id(self, role_id: UUID) -> Optional[UserOrganizationRole]:
        """Get role by ID."""
        pass

    @abstractmethod
    def get_by_user_and_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> Optional[UserOrganizationRole]:
        """Get role by user and organization."""
        pass

    @abstractmethod
    def get_user_roles_in_organization(
        self, organization_id: UUID
    ) -> List[UserOrganizationRole]:
        """Get all user roles in an organization."""
        pass

    @abstractmethod
    def get_user_organizations(self, user_id: UUID) -> List[UserOrganizationRole]:
        """Get all organizations where user has a role."""
        pass

    @abstractmethod
    def user_has_role_in_organization(
        self, user_id: UUID, organization_id: UUID, role: OrganizationRole
    ) -> bool:
        """Check if user has specific role in organization."""
        pass

    @abstractmethod
    def count_organization_users(self, organization_id: UUID) -> int:
        """Count active users in organization."""
        pass

    @abstractmethod
    def remove_user_from_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> bool:
        """Remove user from organization."""
        pass

    @abstractmethod
    def delete(self, role_id: UUID) -> bool:
        """Delete role by ID."""
        pass

    @abstractmethod
    def cleanup_expired_roles(self) -> int:
        """Cleanup expired roles. Returns count of cleaned roles."""
        pass
from .organization_repository import OrganizationRepository
from .user_organization_role_repository import UserOrganizationRoleRepository

__all__ = ["OrganizationRepository", "UserOrganizationRoleRepository"]
from .entities import Organization, UserOrganizationRole
from .value_objects import OrganizationName, OrganizationSettings
from .repositories import OrganizationRepository, UserOrganizationRoleRepository
from .services import OrganizationDomainService, MembershipService

__all__ = [
    "Organization", 
    "UserOrganizationRole",
    "OrganizationName", 
    "OrganizationSettings",
    "OrganizationRepository", 
    "UserOrganizationRoleRepository",
    "OrganizationDomainService",
    "MembershipService"
]
from datetime import datetime
from typing import Optional, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, field_validator


class OrganizationCreateDTO(BaseModel):
    """DTO for creating a new organization."""
    name: str = Field(..., min_length=2, max_length=100, description="Organization name")
    description: Optional[str] = Field(None, max_length=500, description="Organization description")
    max_users: int = Field(10, ge=1, le=1000, description="Maximum users allowed")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Organization name cannot be empty')
        return v.strip()


class OrganizationUpdateDTO(BaseModel):
    """DTO for updating an existing organization."""
    name: Optional[str] = Field(None, min_length=2, max_length=100, description="Organization name")
    description: Optional[str] = Field(None, max_length=500, description="Organization description")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: Optional[str]) -> Optional[str]:
        if v is not None and not v.strip():
            raise ValueError('Organization name cannot be empty')
        return v.strip() if v else None


class OrganizationSettingsUpdateDTO(BaseModel):
    """DTO for updating organization settings."""
    max_users: Optional[int] = Field(None, ge=1, le=1000, description="Maximum users allowed")
    allow_user_registration: Optional[bool] = Field(None, description="Allow user registration")
    require_email_verification: Optional[bool] = Field(None, description="Require email verification")
    session_timeout_hours: Optional[int] = Field(None, ge=1, le=720, description="Session timeout in hours")
    features_enabled: Optional[Dict[str, bool]] = Field(None, description="Enabled features")
    custom_settings: Optional[Dict[str, Any]] = Field(None, description="Custom settings")


class OrganizationResponseDTO(BaseModel):
    """DTO for organization response data."""
    id: UUID
    name: str
    description: Optional[str] = None
    owner_id: UUID
    max_users: int
    current_user_count: int
    settings: Dict[str, Any]
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    model_config = {"from_attributes": True}


class OrganizationListResponseDTO(BaseModel):
    """DTO for paginated organization list response."""
    organizations: list[OrganizationResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class OrganizationMemberSummaryDTO(BaseModel):
    """DTO for organization member summary."""
    user_id: UUID
    user_name: str
    user_email: str
    role: str
    joined_at: datetime
    is_active: bool


class OrganizationDetailResponseDTO(OrganizationResponseDTO):
    """DTO for detailed organization response with members."""
    members: list[OrganizationMemberSummaryDTO]
    member_count: int
    roles_distribution: Dict[str, int]
from .organization_dto import (
    OrganizationCreateDTO, OrganizationUpdateDTO, OrganizationResponseDTO, 
    OrganizationListResponseDTO
)
from .membership_dto import (
    MembershipCreateDTO, MembershipUpdateDTO, MembershipResponseDTO,
    MembershipListResponseDTO, OwnershipTransferDTO
)

__all__ = [
    "OrganizationCreateDTO", "OrganizationUpdateDTO", "OrganizationResponseDTO",
    "OrganizationListResponseDTO", "MembershipCreateDTO", "MembershipUpdateDTO", 
    "MembershipResponseDTO", "MembershipListResponseDTO", "OwnershipTransferDTO"
]
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field
from enum import Enum


class OrganizationRoleEnum(str, Enum):
    OWNER = "owner"
    ADMIN = "admin"
    MEMBER = "member"
    VIEWER = "viewer"


class MembershipCreateDTO(BaseModel):
    """DTO for adding a user to an organization."""
    user_id: UUID = Field(..., description="User ID to add")
    role: OrganizationRoleEnum = Field(OrganizationRoleEnum.MEMBER, description="Role to assign")
    expires_at: Optional[datetime] = Field(None, description="Role expiration date")


class MembershipUpdateDTO(BaseModel):
    """DTO for updating a user's role in an organization."""
    role: OrganizationRoleEnum = Field(..., description="New role to assign")
    expires_at: Optional[datetime] = Field(None, description="Role expiration date")


class MembershipResponseDTO(BaseModel):
    """DTO for membership response data."""
    id: UUID
    user_id: UUID
    organization_id: UUID
    role: str
    assigned_by: UUID
    assigned_at: datetime
    expires_at: Optional[datetime] = None
    is_active: bool
    user_name: str
    user_email: str
    organization_name: str
    
    model_config = {"from_attributes": True}


class MembershipListResponseDTO(BaseModel):
    """DTO for paginated membership list response."""
    memberships: list[MembershipResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class OwnershipTransferDTO(BaseModel):
    """DTO for transferring organization ownership."""
    new_owner_id: UUID = Field(..., description="User ID of the new owner")
    
    @field_validator('new_owner_id')
    @classmethod
    def validate_new_owner_id(cls, v: UUID) -> UUID:
        if not v:
            raise ValueError('New owner ID is required')
        return v


class MembershipInviteDTO(BaseModel):
    """DTO for inviting a user to an organization."""
    email: str = Field(..., description="Email of user to invite")
    role: OrganizationRoleEnum = Field(OrganizationRoleEnum.MEMBER, description="Role to assign")
    message: Optional[str] = Field(None, max_length=500, description="Invitation message")


class UserOrganizationSummaryDTO(BaseModel):
    """DTO for user's organization summary."""
    organization_id: UUID
    organization_name: str
    role: str
    is_owner: bool
    joined_at: datetime
    member_count: int
    is_active: bool


class UserOrganizationsResponseDTO(BaseModel):
    """DTO for user's organizations list."""
    organizations: list[UserOrganizationSummaryDTO]
    total: int
    owned_count: int
    member_count: int
from .dtos import (
    OrganizationCreateDTO, OrganizationUpdateDTO, OrganizationResponseDTO,
    MembershipCreateDTO, MembershipUpdateDTO, MembershipResponseDTO,
    OwnershipTransferDTO
)
from .use_cases import OrganizationUseCase, MembershipUseCase

__all__ = [
    # DTOs
    "OrganizationCreateDTO", "OrganizationUpdateDTO", "OrganizationResponseDTO",
    "MembershipCreateDTO", "MembershipUpdateDTO", "MembershipResponseDTO",
    "OwnershipTransferDTO",
    
    # Use Cases
    "OrganizationUseCase", "MembershipUseCase"
]
from typing import Optional
from uuid import UUID
import math

from ..dtos.membership_dto import (
    MembershipCreateDTO,
    MembershipUpdateDTO,
    MembershipResponseDTO,
    MembershipListResponseDTO,
    OwnershipTransferDTO,
    MembershipInviteDTO,
    UserOrganizationSummaryDTO,
    UserOrganizationsResponseDTO,
)
from ...domain.entities.user_organization_role import (
    OrganizationRole,
)
from ...domain.repositories.organization_repository import OrganizationRepository
from ...domain.repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)
from ...domain.services.organization_domain_service import OrganizationDomainService
from ...domain.services.membership_service import MembershipService


class MembershipUseCase:
    """Use cases for organization membership management."""

    def __init__(
        self,
        organization_repository: OrganizationRepository,
        role_repository: UserOrganizationRoleRepository,
        organization_domain_service: OrganizationDomainService,
        membership_service: MembershipService,
    ):
        self._organization_repository = organization_repository
        self._role_repository = role_repository
        self._organization_domain_service = organization_domain_service
        self._membership_service = membership_service

    def add_member(
        self, organization_id: UUID, dto: MembershipCreateDTO, assigned_by: UUID
    ) -> MembershipResponseDTO:
        """Add a user to an organization."""

        # Check if organization exists
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        # Check if user can manage members
        assigner_role = self._role_repository.get_by_user_and_organization(
            assigned_by, organization_id
        )

        if not assigner_role or not assigner_role.can_manage_users():
            raise ValueError(
                "User does not have permission to manage organization members"
            )

        # Validate user addition
        can_add, reason = self._organization_domain_service.validate_user_addition(
            organization_id, dto.role
        )

        if not can_add:
            raise ValueError(f"Cannot add user: {reason}")

        # Add user to organization
        role = self._membership_service.add_user_to_organization(
            user_id=dto.user_id,
            organization_id=organization_id,
            role=dto.role,
            assigned_by=assigned_by,
        )

        return MembershipResponseDTO(
            **role.model_dump(),
            user_name="User Name",  # Would fetch from user service
            user_email="user@example.com",  # Would fetch from user service
            organization_name=organization.name.value,
        )

    def update_member_role(
        self,
        organization_id: UUID,
        user_id: UUID,
        dto: MembershipUpdateDTO,
        updated_by: UUID,
    ) -> MembershipResponseDTO:
        """Update a member's role in an organization."""

        # Check if organization exists
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        # Check permissions
        updater_role = self._role_repository.get_by_user_and_organization(
            updated_by, organization_id
        )

        if not updater_role or not updater_role.can_manage_users():
            raise ValueError(
                "User does not have permission to manage organization members"
            )

        # Update role
        updated_role = self._membership_service.change_user_role(
            user_id=user_id,
            organization_id=organization_id,
            new_role=dto.role,
            changed_by=updated_by,
        )

        return MembershipResponseDTO(
            **updated_role.model_dump(),
            user_name="User Name",  # Would fetch from user service
            user_email="user@example.com",  # Would fetch from user service
            organization_name=organization.name.value,
        )

    def remove_member(
        self, organization_id: UUID, user_id: UUID, removed_by: UUID
    ) -> bool:
        """Remove a user from an organization."""

        # Check if organization exists
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        # Check permissions (can remove others or themselves)
        remover_role = self._role_repository.get_by_user_and_organization(
            removed_by, organization_id
        )

        can_remove_others = remover_role and remover_role.can_manage_users()
        is_self_removal = removed_by == user_id

        if not can_remove_others and not is_self_removal:
            raise ValueError("User does not have permission to remove this member")

        # Check if user can leave organization
        if is_self_removal:
            can_leave, reason = (
                self._organization_domain_service.can_user_leave_organization(
                    user_id, organization_id
                )
            )

            if not can_leave:
                raise ValueError(f"Cannot leave organization: {reason}")

        # Remove user from organization
        return self._membership_service.remove_user_from_organization(
            user_id, organization_id
        )

    def get_organization_members(
        self, organization_id: UUID, page: int = 1, page_size: int = 100
    ) -> MembershipListResponseDTO:
        """Get paginated list of organization members."""

        if page < 1:
            page = 1

        if page_size < 1 or page_size > 1000:
            page_size = 100

        # Get organization to verify it exists
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        # Get all user roles in organization
        user_roles = self._role_repository.get_user_roles_in_organization(
            organization_id
        )

        # Filter active roles and paginate
        active_roles = [role for role in user_roles if role.is_valid()]
        total = len(active_roles)

        offset = (page - 1) * page_size
        paginated_roles = active_roles[offset : offset + page_size]

        # Convert to DTOs
        membership_dtos = []
        for role in paginated_roles:
            dto = MembershipResponseDTO(
                **role.model_dump(),
                user_name="User Name",  # Would fetch from user service
                user_email="user@example.com",  # Would fetch from user service
                organization_name=organization.name.value,
            )
            membership_dtos.append(dto)

        total_pages = math.ceil(total / page_size)

        return MembershipListResponseDTO(
            memberships=membership_dtos,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_user_membership(
        self, user_id: UUID, organization_id: UUID
    ) -> Optional[MembershipResponseDTO]:
        """Get user's membership in a specific organization."""

        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            return None

        role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if not role or not role.is_valid():
            return None

        return MembershipResponseDTO(
            **role.model_dump(),
            user_name="User Name",  # Would fetch from user service
            user_email="user@example.com",  # Would fetch from user service
            organization_name=organization.name.value,
        )

    def get_user_organizations(self, user_id: UUID) -> UserOrganizationsResponseDTO:
        """Get all organizations where user is a member."""

        user_roles = self._role_repository.get_user_organizations(user_id)

        organizations = []
        owned_count = 0

        for role in user_roles:
            if role.is_valid():
                organization = self._organization_repository.get_by_id(
                    role.organization_id
                )

                if organization:
                    member_count = self._role_repository.count_organization_users(
                        organization.id
                    )

                    is_owner = role.role == OrganizationRole.OWNER
                    if is_owner:
                        owned_count += 1

                    org_summary = UserOrganizationSummaryDTO(
                        organization_id=organization.id,
                        organization_name=organization.name.value,
                        role=role.role.value,
                        is_owner=is_owner,
                        joined_at=role.assigned_at,
                        member_count=member_count,
                        is_active=organization.is_active,
                    )
                    organizations.append(org_summary)

        return UserOrganizationsResponseDTO(
            organizations=organizations,
            total=len(organizations),
            owned_count=owned_count,
            member_count=len(organizations) - owned_count,
        )

    def transfer_ownership(
        self, organization_id: UUID, dto: OwnershipTransferDTO, current_owner_id: UUID
    ) -> MembershipResponseDTO:
        """Transfer organization ownership."""

        # Validate transfer
        can_transfer, reason = self._organization_domain_service.can_transfer_ownership(
            organization_id, current_owner_id, dto.new_owner_id
        )

        if not can_transfer:
            raise ValueError(f"Cannot transfer ownership: {reason}")

        # Perform transfer
        old_role, new_role = self._membership_service.transfer_ownership(
            organization_id, current_owner_id, dto.new_owner_id
        )

        # Get organization for response
        organization = self._organization_repository.get_by_id(organization_id)

        return MembershipResponseDTO(
            **new_role.model_dump(),
            user_name="New Owner Name",  # Would fetch from user service
            user_email="newowner@example.com",  # Would fetch from user service
            organization_name=organization.name.value,
        )

    def invite_user(
        self, organization_id: UUID, dto: MembershipInviteDTO, invited_by: UUID
    ) -> bool:
        """Invite a user to join an organization."""

        # Check if organization exists
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        # Check permissions
        inviter_role = self._role_repository.get_by_user_and_organization(
            invited_by, organization_id
        )

        if not inviter_role or not inviter_role.can_manage_users():
            raise ValueError("User does not have permission to invite members")

        # Validate user addition
        can_add, reason = self._organization_domain_service.validate_user_addition(
            organization_id, dto.role
        )

        if not can_add:
            raise ValueError(f"Cannot invite user: {reason}")

        # In a real implementation, this would:
        # 1. Create an invitation record
        # 2. Send an email invitation
        # 3. Generate invitation token

        return True

    def get_user_permissions(self, user_id: UUID, organization_id: UUID) -> list[str]:
        """Get user's permissions in an organization."""

        return self._membership_service.get_user_permissions_in_organization(
            user_id, organization_id
        )

    def check_user_permission(
        self, user_id: UUID, organization_id: UUID, action: str
    ) -> bool:
        """Check if user can perform specific action in organization."""

        return self._membership_service.can_user_perform_action(
            user_id, organization_id, action
        )
from typing import Optional
from uuid import UUID
import math

from ..dtos.organization_dto import (
    OrganizationCreateDTO,
    OrganizationUpdateDTO,
    OrganizationSettingsUpdateDTO,
    OrganizationResponseDTO,
    OrganizationListResponseDTO,
    OrganizationDetailResponseDTO,
    OrganizationMemberSummaryDTO,
)
from ...domain.entities.organization import Organization
from ...domain.entities.user_organization_role import (
    UserOrganizationRole,
    OrganizationRole,
)
from ...domain.repositories.organization_repository import OrganizationRepository
from ...domain.repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)
from ...domain.services.organization_domain_service import OrganizationDomainService
from ...domain.services.membership_service import MembershipService
from ...domain.value_objects.organization_name import OrganizationName


class OrganizationUseCase:
    """Use cases for organization management."""

    def __init__(
        self,
        organization_repository: OrganizationRepository,
        role_repository: UserOrganizationRoleRepository,
        organization_domain_service: OrganizationDomainService,
        membership_service: MembershipService,
    ):
        self._organization_repository = organization_repository
        self._role_repository = role_repository
        self._organization_domain_service = organization_domain_service
        self._membership_service = membership_service

    def create_organization(
        self, dto: OrganizationCreateDTO, owner_id: UUID
    ) -> OrganizationResponseDTO:
        """Create a new organization."""

        # Check if organization name is available
        org_name = OrganizationName(value=dto.name)
        is_available = self._organization_domain_service.is_organization_name_available(
            org_name
        )

        if not is_available:
            raise ValueError(f"Organization name '{dto.name}' is already in use")

        # Create organization entity
        organization = Organization.create(
            name=dto.name,
            owner_id=owner_id,
            description=dto.description,
            max_users=dto.max_users,
        )

        # Save organization
        saved_org = self._organization_repository.save(organization)

        # Create owner role
        self._membership_service.add_user_to_organization(
            user_id=owner_id,
            organization_id=saved_org.id,
            role=OrganizationRole.OWNER,
            assigned_by=owner_id,
        )

        # Get current user count
        user_count = self._role_repository.count_organization_users(saved_org.id)

        return OrganizationResponseDTO(
            **saved_org.model_dump(),
            current_user_count=user_count,
            max_users=dto.max_users,
            settings=saved_org.settings.model_dump(),
        )

    def get_organization_by_id(
        self, organization_id: UUID
    ) -> Optional[OrganizationResponseDTO]:
        """Get organization by ID."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return None

        # Get current user count
        user_count = self._role_repository.count_organization_users(organization_id)

        return OrganizationResponseDTO(
            **organization.model_dump(),
            current_user_count=user_count,
            max_users=organization.settings.max_users,
            settings=organization.settings.model_dump(),
        )

    def get_organization_detail(
        self, organization_id: UUID
    ) -> Optional[OrganizationDetailResponseDTO]:
        """Get detailed organization information with members."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return None

        # Get organization members
        user_roles = self._role_repository.get_user_roles_in_organization(
            organization_id
        )

        # Convert to member summary DTOs
        members = []
        roles_distribution = {}

        for role in user_roles:
            if role.is_valid():
                # This would typically require joining with user data
                member = OrganizationMemberSummaryDTO(
                    user_id=role.user_id,
                    user_name="User Name",  # Would fetch from user service
                    user_email="user@example.com",  # Would fetch from user service
                    role=role.role.value,
                    joined_at=role.assigned_at,
                    is_active=role.is_active,
                )
                members.append(member)

                # Count roles
                role_name = role.role.value
                roles_distribution[role_name] = roles_distribution.get(role_name, 0) + 1

        return OrganizationDetailResponseDTO(
            **organization.model_dump(),
            current_user_count=len(members),
            max_users=organization.settings.max_users,
            settings=organization.settings.model_dump(),
            members=members,
            member_count=len(members),
            roles_distribution=roles_distribution,
        )

    def update_organization(
        self, organization_id: UUID, dto: OrganizationUpdateDTO, updated_by: UUID
    ) -> OrganizationResponseDTO:
        """Update organization information."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            raise ValueError("Organization not found")

        # Check if user can modify organization
        user_role = self._role_repository.get_by_user_and_organization(
            updated_by, organization_id
        )

        if not user_role or not user_role.can_modify_organization():
            raise ValueError("User does not have permission to modify organization")

        updated_org = organization

        # Update name if provided
        if dto.name is not None:
            org_name = OrganizationName(value=dto.name)
            is_available = (
                self._organization_domain_service.is_organization_name_available(
                    org_name, organization_id
                )
            )
            if not is_available:
                raise ValueError(f"Organization name '{dto.name}' is already in use")

            updated_org = updated_org.update_name(dto.name)

        # Update description if provided
        if dto.description is not None:
            updated_org = updated_org.update_description(dto.description)

        # Save updated organization
        saved_org = self._organization_repository.save(updated_org)

        # Get current user count
        user_count = self._role_repository.count_organization_users(organization_id)

        return OrganizationResponseDTO(
            **saved_org.model_dump(),
            current_user_count=user_count,
            max_users=saved_org.settings.max_users,
            settings=saved_org.settings.model_dump(),
        )

    def update_organization_settings(
        self,
        organization_id: UUID,
        dto: OrganizationSettingsUpdateDTO,
        updated_by: UUID,
    ) -> OrganizationResponseDTO:
        """Update organization settings."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            raise ValueError("Organization not found")

        # Check permissions
        user_role = self._role_repository.get_by_user_and_organization(
            updated_by, organization_id
        )

        if not user_role or not user_role.can_modify_organization():
            raise ValueError(
                "User does not have permission to modify organization settings"
            )

        # Update settings
        updated_settings = organization.settings

        if dto.max_users is not None:
            # Validate new max_users doesn't violate current user count
            current_user_count = self._role_repository.count_organization_users(
                organization_id
            )
            if dto.max_users < current_user_count:
                raise ValueError(
                    f"Cannot reduce max users below current count: {current_user_count}"
                )

            updated_settings = updated_settings.update_max_users(dto.max_users)

        if dto.allow_user_registration is not None:
            updated_settings = updated_settings.update_custom_setting(
                "allow_user_registration", dto.allow_user_registration
            )

        if dto.require_email_verification is not None:
            updated_settings = updated_settings.update_custom_setting(
                "require_email_verification", dto.require_email_verification
            )

        if dto.session_timeout_hours is not None:
            updated_settings = updated_settings.update_custom_setting(
                "session_timeout_hours", dto.session_timeout_hours
            )

        if dto.features_enabled is not None:
            for feature, enabled in dto.features_enabled.items():
                if enabled:
                    updated_settings = updated_settings.enable_feature(feature)
                else:
                    updated_settings = updated_settings.disable_feature(feature)

        if dto.custom_settings is not None:
            for key, value in dto.custom_settings.items():
                updated_settings = updated_settings.update_custom_setting(key, value)

        # Update organization with new settings
        updated_org = organization.update_settings(updated_settings)
        saved_org = self._organization_repository.save(updated_org)

        # Get current user count
        user_count = self._role_repository.count_organization_users(organization_id)

        return OrganizationResponseDTO(
            **saved_org.model_dump(),
            current_user_count=user_count,
            max_users=updated_settings.max_users,
            settings=updated_settings.model_dump(),
        )

    def deactivate_organization(
        self, organization_id: UUID, deactivated_by: UUID
    ) -> bool:
        """Deactivate an organization."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            raise ValueError("Organization not found")

        # Check if user is owner
        if not organization.is_owner(deactivated_by):
            raise ValueError("Only organization owner can deactivate the organization")

        # Check if organization can be safely deactivated
        (
            can_delete,
            reason,
        ) = self._organization_domain_service.can_organization_be_deleted(
            organization_id
        )

        if not can_delete:
            raise ValueError(f"Cannot deactivate organization: {reason}")

        # Deactivate organization
        updated_org = organization.deactivate()
        self._organization_repository.save(updated_org)

        return True

    def transfer_ownership(
        self, organization_id: UUID, current_owner_id: UUID, new_owner_id: UUID
    ) -> OrganizationResponseDTO:
        """Transfer organization ownership."""

        # Validate transfer
        (
            can_transfer,
            reason,
        ) = self._organization_domain_service.can_transfer_ownership(
            organization_id, current_owner_id, new_owner_id
        )

        if not can_transfer:
            raise ValueError(f"Cannot transfer ownership: {reason}")

        # Perform transfer
        self._membership_service.transfer_ownership(
            organization_id, current_owner_id, new_owner_id
        )

        # Return updated organization
        return self.get_organization_by_id(organization_id)

    def list_organizations(
        self, page: int = 1, page_size: int = 100, active_only: bool = True
    ) -> OrganizationListResponseDTO:
        """List organizations with pagination."""

        if page < 1:
            page = 1

        if page_size < 1 or page_size > 1000:
            page_size = 100

        offset = (page - 1) * page_size

        # Get organizations
        organizations = self._organization_repository.list_active_organizations(
            limit=page_size, offset=offset
        )

        # Get total count
        total = self._organization_repository.count_active_organizations()

        # Convert to DTOs
        org_dtos = []
        for org in organizations:
            user_count = self._role_repository.count_organization_users(org.id)
            org_dto = OrganizationResponseDTO(
                **org.model_dump(),
                current_user_count=user_count,
                max_users=org.settings.max_users,
                settings=org.settings.model_dump(),
            )
            org_dtos.append(org_dto)

        total_pages = math.ceil(total / page_size)

        return OrganizationListResponseDTO(
            organizations=org_dtos,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_user_organizations(self, user_id: UUID) -> list[OrganizationResponseDTO]:
        """Get all organizations where user is a member."""
        organizations = self._organization_repository.get_user_organizations(user_id)

        org_dtos = []
        for org in organizations:
            user_count = self._role_repository.count_organization_users(org.id)
            org_dto = OrganizationResponseDTO(
                **org.model_dump(),
                current_user_count=user_count,
                max_users=org.settings.max_users,
                settings=org.settings.model_dump(),
            )
            org_dtos.append(org_dto)

        return org_dtos
from .organization_use_cases import OrganizationUseCase
from .membership_use_cases import MembershipUseCase

__all__ = ["OrganizationUseCase", "MembershipUseCase"]
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.ext.io import Session
from sqlalchemy import select, update, delete, and_
from sqlalchemy.exc import IntegrityError

from ...domain.entities.user_organization_role import UserOrganizationRole
from ...domain.repositories.user_organization_role_repository import UserOrganizationRoleRepository
from ....infrastructure.database.models.organization_models import (
    UserOrganizationRoleModel, OrganizationRoleEnum
)


class SqlAlchemyUserOrganizationRoleRepository(UserOrganizationRoleRepository):
    """SQLAlchemy implementation of UserOrganizationRoleRepository."""
    
    def __init__(self, session: Session):
        self.session = session
    
     def save(self, membership: UserOrganizationRole) -> UserOrganizationRole:
        """Save a user organization role entity."""
        try:
            # Check if membership exists
            existing =  self.session.get(UserOrganizationRoleModel, membership.id)
            
            if existing:
                # Update existing membership
                existing.user_id = membership.user_id
                existing.organization_id = membership.organization_id
                existing.role = OrganizationRoleEnum(membership.role)
                existing.assigned_by = membership.assigned_by
                existing.expires_at = membership.expires_at
                existing.is_active = membership.is_active
                existing.updated_at = datetime.now(timezone.utc)
                
                 self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new membership
                membership_model = UserOrganizationRoleModel(
                    id=membership.id,
                    user_id=membership.user_id,
                    organization_id=membership.organization_id,
                    role=OrganizationRoleEnum(membership.role),
                    assigned_by=membership.assigned_by,
                    expires_at=membership.expires_at,
                    is_active=membership.is_active,
                    created_at=membership.created_at,
                    updated_at=membership.updated_at
                )
                
                self.session.add(membership_model)
                 self.session.flush()
                return self._to_domain_entity(membership_model)
                
        except IntegrityError as e:
             self.session.rollback()
            raise e
    
     def find_by_id(self, membership_id: UUID) -> Optional[UserOrganizationRole]:
        """Find a membership by ID."""
        result =  self.session.execute(
            select(UserOrganizationRoleModel).where(UserOrganizationRoleModel.id == membership_id)
        )
        membership_model = result.scalar_one_or_none()
        
        if membership_model:
            return self._to_domain_entity(membership_model)
        return None
    
     def find_by_user_and_organization(
        self,
        user_id: UUID,
        organization_id: UUID
    ) -> Optional[UserOrganizationRole]:
        """Find active membership for user in organization."""
        result =  self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.user_id == user_id,
                    UserOrganizationRoleModel.organization_id == organization_id,
                    UserOrganizationRoleModel.is_active == True
                )
            )
        )
        membership_model = result.scalar_one_or_none()
        
        if membership_model:
            return self._to_domain_entity(membership_model)
        return None
    
     def find_user_memberships(self, user_id: UUID) -> List[UserOrganizationRole]:
        """Find all active memberships for a user."""
        result =  self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.user_id == user_id,
                    UserOrganizationRoleModel.is_active == True
                )
            )
        )
        membership_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in membership_models]
    
     def find_organization_members(self, organization_id: UUID) -> List[UserOrganizationRole]:
        """Find all active members of an organization."""
        result =  self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.organization_id == organization_id,
                    UserOrganizationRoleModel.is_active == True
                )
            )
        )
        membership_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in membership_models]
    
     def find_organization_members_by_role(
        self,
        organization_id: UUID,
        role: str
    ) -> List[UserOrganizationRole]:
        """Find organization members with specific role."""
        result =  self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.organization_id == organization_id,
                    UserOrganizationRoleModel.role == OrganizationRoleEnum(role),
                    UserOrganizationRoleModel.is_active == True
                )
            )
        )
        membership_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in membership_models]
    
     def find_expired_memberships(self) -> List[UserOrganizationRole]:
        """Find expired memberships that are still active."""
        current_time = datetime.now(timezone.utc)
        result =  self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.expires_at <= current_time,
                    UserOrganizationRoleModel.is_active == True
                )
            )
        )
        membership_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in membership_models]
    
     def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        user_id: Optional[UUID] = None,
        role: Optional[str] = None,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20
    ) -> tuple[List[UserOrganizationRole], int]:
        """Find memberships with pagination and filters."""
        query = select(UserOrganizationRoleModel)
        count_query = select(UserOrganizationRoleModel)
        
        # Apply filters
        if organization_id:
            query = query.where(UserOrganizationRoleModel.organization_id == organization_id)
            count_query = count_query.where(UserOrganizationRoleModel.organization_id == organization_id)
        
        if user_id:
            query = query.where(UserOrganizationRoleModel.user_id == user_id)
            count_query = count_query.where(UserOrganizationRoleModel.user_id == user_id)
        
        if role:
            query = query.where(UserOrganizationRoleModel.role == OrganizationRoleEnum(role))
            count_query = count_query.where(UserOrganizationRoleModel.role == OrganizationRoleEnum(role))
        
        if is_active is not None:
            query = query.where(UserOrganizationRoleModel.is_active == is_active)
            count_query = count_query.where(UserOrganizationRoleModel.is_active == is_active)
        
        # Get total count
        total_result =  self.session.execute(count_query)
        total = len(total_result.scalars().all())
        
        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(UserOrganizationRoleModel.created_at.desc())
        result =  self.session.execute(query)
        membership_models = result.scalars().all()
        
        memberships = [self._to_domain_entity(model) for model in membership_models]
        return memberships, total
    
     def delete(self, membership_id: UUID) -> bool:
        """Delete a membership (hard delete)."""
        result =  self.session.execute(
            delete(UserOrganizationRoleModel).where(UserOrganizationRoleModel.id == membership_id)
        )
        return result.rowcount > 0
    
     def deactivate_membership(self, membership_id: UUID) -> bool:
        """Deactivate a membership (soft delete)."""
        result =  self.session.execute(
            update(UserOrganizationRoleModel)
            .where(UserOrganizationRoleModel.id == membership_id)
            .values(
                is_active=False,
                updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0
    
     def update_role(self, membership_id: UUID, new_role: str) -> bool:
        """Update membership role."""
        result =  self.session.execute(
            update(UserOrganizationRoleModel)
            .where(UserOrganizationRoleModel.id == membership_id)
            .values(
                role=OrganizationRoleEnum(new_role),
                updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0
    
     def extend_membership(self, membership_id: UUID, new_expiration: datetime) -> bool:
        """Extend membership expiration."""
        result =  self.session.execute(
            update(UserOrganizationRoleModel)
            .where(UserOrganizationRoleModel.id == membership_id)
            .values(
                expires_at=new_expiration,
                updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0
    
     def count_organization_members(self, organization_id: UUID) -> int:
        """Count active members in an organization."""
        result =  self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.organization_id == organization_id,
                    UserOrganizationRoleModel.is_active == True
                )
            )
        )
        return len(result.scalars().all())
    
     def count_user_memberships(self, user_id: UUID) -> int:
        """Count active memberships for a user."""
        result =  self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.user_id == user_id,
                    UserOrganizationRoleModel.is_active == True
                )
            )
        )
        return len(result.scalars().all())
    
     def expire_memberships(self) -> int:
        """Mark expired memberships as inactive."""
        current_time = datetime.now(timezone.utc)
        result =  self.session.execute(
            update(UserOrganizationRoleModel)
            .where(
                and_(
                    UserOrganizationRoleModel.expires_at <= current_time,
                    UserOrganizationRoleModel.is_active == True
                )
            )
            .values(
                is_active=False,
                updated_at=current_time
            )
        )
        return result.rowcount
    
    def _to_domain_entity(self, membership_model: UserOrganizationRoleModel) -> UserOrganizationRole:
        """Convert SQLAlchemy model to domain entity."""
        return UserOrganizationRole(
            id=membership_model.id,
            user_id=membership_model.user_id,
            organization_id=membership_model.organization_id,
            role=membership_model.role.value,
            assigned_by=membership_model.assigned_by,
            expires_at=membership_model.expires_at,
            is_active=membership_model.is_active,
            created_at=membership_model.created_at,
            updated_at=membership_model.updated_at
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.ext.io import Session
from sqlalchemy import select, update, delete
from sqlalchemy.exc import IntegrityError

from ...domain.entities.organization import Organization
from ...domain.repositories.organization_repository import OrganizationRepository
from ...domain.value_objects.organization_name import OrganizationName
from ...domain.value_objects.organization_settings import OrganizationSettings
from ....infrastructure.database.models.organization_models import OrganizationModel


class SqlAlchemyOrganizationRepository(OrganizationRepository):
    """SQLAlchemy implementation of OrganizationRepository."""
    
    def __init__(self, session: Session):
        self.session = session
    
     def save(self, organization: Organization) -> Organization:
        """Save an organization entity."""
        try:
            # Check if organization exists
            existing =  self.session.get(OrganizationModel, organization.id)
            
            if existing:
                # Update existing organization
                existing.name = organization.name.value
                existing.description = organization.description
                existing.owner_id = organization.owner_id
                existing.is_active = organization.is_active
                existing.settings = organization.settings.to_dict()
                existing.member_count = organization.member_count
                existing.max_members = organization.max_members
                existing.updated_at = datetime.now(timezone.utc)
                
                 self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new organization
                org_model = OrganizationModel(
                    id=organization.id,
                    name=organization.name.value,
                    description=organization.description,
                    owner_id=organization.owner_id,
                    is_active=organization.is_active,
                    settings=organization.settings.to_dict(),
                    member_count=organization.member_count,
                    max_members=organization.max_members,
                    created_at=organization.created_at,
                    updated_at=organization.updated_at
                )
                
                self.session.add(org_model)
                 self.session.flush()
                return self._to_domain_entity(org_model)
                
        except IntegrityError as e:
             self.session.rollback()
            raise e
    
     def find_by_id(self, organization_id: UUID) -> Optional[Organization]:
        """Find an organization by ID."""
        result =  self.session.execute(
            select(OrganizationModel).where(OrganizationModel.id == organization_id)
        )
        org_model = result.scalar_one_or_none()
        
        if org_model:
            return self._to_domain_entity(org_model)
        return None
    
     def find_by_name(self, name: OrganizationName) -> Optional[Organization]:
        """Find an organization by name."""
        result =  self.session.execute(
            select(OrganizationModel).where(OrganizationModel.name == name.value)
        )
        org_model = result.scalar_one_or_none()
        
        if org_model:
            return self._to_domain_entity(org_model)
        return None
    
     def find_by_owner(self, owner_id: UUID) -> List[Organization]:
        """Find organizations owned by a user."""
        result =  self.session.execute(
            select(OrganizationModel).where(OrganizationModel.owner_id == owner_id)
        )
        org_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in org_models]
    
     def find_active_organizations(self) -> List[Organization]:
        """Find all active organizations."""
        result =  self.session.execute(
            select(OrganizationModel).where(OrganizationModel.is_active == True)
        )
        org_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in org_models]
    
     def find_paginated(
        self,
        offset: int = 0,
        limit: int = 20,
        name_filter: Optional[str] = None,
        owner_id: Optional[UUID] = None,
        is_active: Optional[bool] = None
    ) -> tuple[List[Organization], int]:
        """Find organizations with pagination and filters."""
        query = select(OrganizationModel)
        count_query = select(OrganizationModel)
        
        # Apply filters
        if name_filter:
            query = query.where(OrganizationModel.name.ilike(f"%{name_filter}%"))
            count_query = count_query.where(OrganizationModel.name.ilike(f"%{name_filter}%"))
        
        if owner_id:
            query = query.where(OrganizationModel.owner_id == owner_id)
            count_query = count_query.where(OrganizationModel.owner_id == owner_id)
        
        if is_active is not None:
            query = query.where(OrganizationModel.is_active == is_active)
            count_query = count_query.where(OrganizationModel.is_active == is_active)
        
        # Get total count
        total_result =  self.session.execute(count_query)
        total = len(total_result.scalars().all())
        
        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(OrganizationModel.created_at.desc())
        result =  self.session.execute(query)
        org_models = result.scalars().all()
        
        organizations = [self._to_domain_entity(model) for model in org_models]
        return organizations, total
    
     def delete(self, organization_id: UUID) -> bool:
        """Delete an organization (hard delete)."""
        result =  self.session.execute(
            delete(OrganizationModel).where(OrganizationModel.id == organization_id)
        )
        return result.rowcount > 0
    
     def exists_by_name(self, name: OrganizationName) -> bool:
        """Check if an organization with the given name exists."""
        result =  self.session.execute(
            select(OrganizationModel.id).where(OrganizationModel.name == name.value)
        )
        return result.scalar_one_or_none() is not None
    
     def update_member_count(self, organization_id: UUID, member_count: int) -> bool:
        """Update organization's member count."""
        result =  self.session.execute(
            update(OrganizationModel)
            .where(OrganizationModel.id == organization_id)
            .values(
                member_count=member_count,
                updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0
    
     def transfer_ownership(self, organization_id: UUID, new_owner_id: UUID) -> bool:
        """Transfer organization ownership."""
        result =  self.session.execute(
            update(OrganizationModel)
            .where(OrganizationModel.id == organization_id)
            .values(
                owner_id=new_owner_id,
                updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0
    
     def update_settings(self, organization_id: UUID, settings: OrganizationSettings) -> bool:
        """Update organization settings."""
        result =  self.session.execute(
            update(OrganizationModel)
            .where(OrganizationModel.id == organization_id)
            .values(
                settings=settings.to_dict(),
                updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0
    
     def count_organizations_by_owner(self, owner_id: UUID) -> int:
        """Count organizations owned by a user."""
        result =  self.session.execute(
            select(OrganizationModel).where(OrganizationModel.owner_id == owner_id)
        )
        return len(result.scalars().all())
    
    def _to_domain_entity(self, org_model: OrganizationModel) -> Organization:
        """Convert SQLAlchemy model to domain entity."""
        return Organization(
            id=org_model.id,
            name=OrganizationName(org_model.name),
            description=org_model.description,
            owner_id=org_model.owner_id,
            is_active=org_model.is_active,
            settings=OrganizationSettings.from_dict(org_model.settings),
            member_count=org_model.member_count,
            max_members=org_model.max_members,
            created_at=org_model.created_at,
            updated_at=org_model.updated_at
        )
from .sqlalchemy_organization_repository import SqlAlchemyOrganizationRepository
from .sqlalchemy_user_organization_role_repository import SqlAlchemyUserOrganizationRoleRepository

__all__ = [
    "SqlAlchemyOrganizationRepository",
    "SqlAlchemyUserOrganizationRoleRepository"
]
from .repositories import SqlAlchemyOrganizationRepository, SqlAlchemyUserOrganizationRoleRepository

__all__ = [
    "SqlAlchemyOrganizationRepository",
    "SqlAlchemyUserOrganizationRoleRepository"
]
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
import logging
import time

from infrastructure.database.connection import engine, Base
from presentation.api.user_routes import router as user_router
from presentation.api.auth_routes import router as auth_router

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def create_tables():
    Base.metadata.create_all(bind=engine)


def create_app() -> FastAPI:
    app = FastAPI(
        title="DDD FastAPI Application",
        description="A FastAPI application following Domain Driven Design principles",
        version="1.0.0",
        redirect_slashes=False,  # Desabilita redirecionamento automático de trailing slash
    )

    @app.middleware("http")
     def log_requests(request: Request, call_next):
        start_time = time.time()

        # Logar requisições suspeitas para endpoints de IA
        ai_endpoints = ["/v1/models", "/v1/chat", "/v1/completions", "/models", "/chat"]
        if any(request.url.path.startswith(endpoint) for endpoint in ai_endpoints):
            logger.warning(
                f"AI API request detected: {request.method} {request.url.path} "
                f"from {request.client.host if request.client else 'unknown'} "
                f"User-Agent: {request.headers.get('user-agent', 'unknown')}"
            )

        response = call_next(request)
        process_time = time.time() - start_time

        # Logar requisições problemáticas e redirecionamentos
        if (
            response.status_code >= 400
            or request.url.path.startswith("/v1/")
            or response.status_code == 307
        ):
            status_msg = ""
            if response.status_code == 307:
                status_msg = " (REDIRECT - check trailing slash)"

            logger.info(
                f"{request.method} {request.url.path} - "
                f"Status: {response.status_code}{status_msg} - "
                f"Time: {process_time:.4f}s - "
                f"Client: {request.client.host if request.client else 'unknown'}"
            )

        return response

    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    app.include_router(user_router, prefix="/api/v1")
    app.include_router(auth_router, prefix="/api/v1")

    return app


app = create_app()


@app.on_event("startup")
 def startup_event():
    create_tables()


@app.get("/")
 def root():
    return {"message": "Welcome to DDD FastAPI Application"}


@app.get("/health")
 def health_check():
    return {"status": "healthy"}


@app.get("/v1/models")
 def models_endpoint():
    """
    Endpoint para esclarecer que esta não é uma API de modelos de IA.
    Algumas ferramentas podem tentar acessar este endpoint pensando que é uma API OpenAI-like.
    """
    return {
        "error": "Not an AI models API",
        "message": "This is a FastAPI DDD application, not an AI models server",
        "application": "FastAPI DDD Project",
        "available_endpoints": [
            "/docs - API Documentation",
            "/api/v1/users - User management endpoints",
            "/api/v1/auth - Authentication endpoints",
            "/health - Health check",
        ],
        "note": "If you're looking for AI models, try OpenAI API, Ollama, or similar services",
    }


@app.post("/v1/chat/completions")
@app.post("/v1/completions")
@app.get("/models")
 def ai_endpoints_handler():
    """
    Handler para outros endpoints comuns de APIs de IA
    """
    return {
        "error": "AI API not available",
        "message": "This is not an AI service. This is a FastAPI DDD application for user management.",
        "redirect": "Check /docs for available endpoints",
        "suggestion": "For AI services, try OpenAI, Anthropic, Ollama, or other AI providers",
    }
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Dict, Any, List
from pydantic import BaseModel
from enum import Enum


class PolicyEffect(str, Enum):
    ALLOW = "allow"
    DENY = "deny"


class PolicyCondition(BaseModel):
    attribute: str
    operator: str  # eq, ne, gt, lt, gte, lte, in, not_in, contains
    value: Any

    model_config = {"frozen": True}

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Evaluate condition against context."""
        context_value = context.get(self.attribute)
        
        if context_value is None:
            return False
        
        if self.operator == "eq":
            return context_value == self.value
        elif self.operator == "ne":
            return context_value != self.value
        elif self.operator == "gt":
            return context_value > self.value
        elif self.operator == "lt":
            return context_value < self.value
        elif self.operator == "gte":
            return context_value >= self.value
        elif self.operator == "lte":
            return context_value <= self.value
        elif self.operator == "in":
            return context_value in self.value
        elif self.operator == "not_in":
            return context_value not in self.value
        elif self.operator == "contains":
            return self.value in context_value
        
        return False


class Policy(BaseModel):
    id: UUID
    name: str
    description: str
    effect: PolicyEffect
    resource_type: str
    action: str
    conditions: List[PolicyCondition]
    organization_id: Optional[UUID] = None
    created_by: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True
    priority: int = 0  # Higher number = higher priority

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls,
        name: str,
        description: str,
        effect: PolicyEffect,
        resource_type: str,
        action: str,
        conditions: List[PolicyCondition],
        created_by: UUID,
        organization_id: Optional[UUID] = None,
        priority: int = 0
    ) -> "Policy":
        return cls(
            id=uuid4(),
            name=name,
            description=description,
            effect=effect,
            resource_type=resource_type,
            action=action,
            conditions=conditions,
            organization_id=organization_id,
            created_by=created_by,
            created_at=datetime.utcnow(),
            is_active=True,
            priority=priority
        )

    def evaluate(self, context: Dict[str, Any]) -> Optional[bool]:
        """Evaluate policy against context. Returns None if not applicable."""
        if not self.is_active:
            return None
        
        # Check if policy applies to this resource type and action
        if (context.get("resource_type") != self.resource_type or 
            context.get("action") != self.action):
            return None
        
        # Check organization scope
        if self.organization_id and context.get("organization_id") != self.organization_id:
            return None
        
        # Evaluate all conditions
        for condition in self.conditions:
            if not condition.evaluate(context):
                return None  # Policy doesn't apply
        
        # All conditions met, return effect
        return self.effect == PolicyEffect.ALLOW

    def update_conditions(self, conditions: List[PolicyCondition]) -> "Policy":
        """Update policy conditions."""
        return self.model_copy(update={
            "conditions": conditions,
            "updated_at": datetime.utcnow()
        })

    def update_priority(self, priority: int) -> "Policy":
        """Update policy priority."""
        return self.model_copy(update={
            "priority": priority,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Policy":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Policy":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })

    def matches_request(self, resource_type: str, action: str, organization_id: Optional[UUID] = None) -> bool:
        """Check if policy matches the request."""
        if not self.is_active:
            return False
        
        if self.resource_type != resource_type or self.action != action:
            return False
        
        if self.organization_id and self.organization_id != organization_id:
            return False
        
        return True
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel
from enum import Enum

from ..value_objects.permission_name import PermissionName


class PermissionType(str, Enum):
    CREATE = "create"
    READ = "read"
    UPDATE = "update"
    DELETE = "delete"
    EXECUTE = "execute"
    MANAGE = "manage"


class Permission(BaseModel):
    id: UUID
    name: PermissionName
    description: str
    permission_type: PermissionType
    resource_type: str  # e.g., "user", "organization", "chat"
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True
    is_system_permission: bool = False

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls, 
        name: str, 
        description: str, 
        permission_type: PermissionType,
        resource_type: str,
        is_system_permission: bool = False
    ) -> "Permission":
        return cls(
            id=uuid4(),
            name=PermissionName(value=name),
            description=description,
            permission_type=permission_type,
            resource_type=resource_type,
            created_at=datetime.utcnow(),
            is_active=True,
            is_system_permission=is_system_permission
        )

    def update_description(self, description: str) -> "Permission":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Permission":
        if self.is_system_permission:
            raise ValueError("Cannot deactivate system permissions")
        
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Permission":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })

    def get_full_name(self) -> str:
        """Get full permission name in format: resource_type:permission_type"""
        return f"{self.resource_type}:{self.permission_type.value}"

    def can_be_deleted(self) -> tuple[bool, str]:
        """Check if permission can be deleted."""
        if self.is_system_permission:
            return False, "System permissions cannot be deleted"
        
        return True, "Permission can be deleted"

    def matches_resource_and_action(self, resource_type: str, action: PermissionType) -> bool:
        """Check if this permission matches the given resource and action."""
        return (
            self.resource_type == resource_type and 
            self.permission_type == action and 
            self.is_active
        )
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List
from pydantic import BaseModel

from ..value_objects.role_name import RoleName


class Role(BaseModel):
    id: UUID
    name: RoleName
    description: str
    organization_id: Optional[UUID] = None  # None for system-wide roles
    created_by: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True
    is_system_role: bool = False

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls, 
        name: str, 
        description: str, 
        created_by: UUID,
        organization_id: Optional[UUID] = None,
        is_system_role: bool = False
    ) -> "Role":
        return cls(
            id=uuid4(),
            name=RoleName(value=name),
            description=description,
            organization_id=organization_id,
            created_by=created_by,
            created_at=datetime.utcnow(),
            is_active=True,
            is_system_role=is_system_role
        )

    def update_description(self, description: str) -> "Role":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Role":
        if self.is_system_role:
            raise ValueError("Cannot deactivate system roles")
        
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Role":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })

    def is_organization_role(self) -> bool:
        """Check if this is an organization-specific role."""
        return self.organization_id is not None

    def is_global_role(self) -> bool:
        """Check if this is a global/system role."""
        return self.organization_id is None

    def can_be_deleted(self) -> tuple[bool, str]:
        """Check if role can be deleted."""
        if self.is_system_role:
            return False, "System roles cannot be deleted"
        
        return True, "Role can be deleted"

    def can_be_modified(self) -> tuple[bool, str]:
        """Check if role can be modified."""
        if self.is_system_role:
            return False, "System roles cannot be modified"
        
        if not self.is_active:
            return False, "Inactive roles cannot be modified"
        
        return True, "Role can be modified"
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel


class Resource(BaseModel):
    id: UUID
    resource_type: str  # e.g., "user", "organization", "chat", "plan"
    resource_id: UUID  # ID of the actual resource
    owner_id: UUID
    organization_id: Optional[UUID] = None
    attributes: Dict[str, Any]  # For ABAC - resource attributes
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls, 
        resource_type: str, 
        resource_id: UUID, 
        owner_id: UUID,
        organization_id: Optional[UUID] = None,
        attributes: Optional[Dict[str, Any]] = None
    ) -> "Resource":
        return cls(
            id=uuid4(),
            resource_type=resource_type,
            resource_id=resource_id,
            owner_id=owner_id,
            organization_id=organization_id,
            attributes=attributes or {},
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_attributes(self, attributes: Dict[str, Any]) -> "Resource":
        """Update resource attributes for ABAC."""
        return self.model_copy(update={
            "attributes": {**self.attributes, **attributes},
            "updated_at": datetime.utcnow()
        })

    def set_attribute(self, key: str, value: Any) -> "Resource":
        """Set a single attribute."""
        new_attributes = self.attributes.copy()
        new_attributes[key] = value
        
        return self.model_copy(update={
            "attributes": new_attributes,
            "updated_at": datetime.utcnow()
        })

    def remove_attribute(self, key: str) -> "Resource":
        """Remove an attribute."""
        new_attributes = self.attributes.copy()
        new_attributes.pop(key, None)
        
        return self.model_copy(update={
            "attributes": new_attributes,
            "updated_at": datetime.utcnow()
        })

    def get_attribute(self, key: str, default: Any = None) -> Any:
        """Get attribute value."""
        return self.attributes.get(key, default)

    def has_attribute(self, key: str) -> bool:
        """Check if resource has specific attribute."""
        return key in self.attributes

    def is_owned_by(self, user_id: UUID) -> bool:
        """Check if resource is owned by specific user."""
        return self.owner_id == user_id

    def belongs_to_organization(self, organization_id: UUID) -> bool:
        """Check if resource belongs to specific organization."""
        return self.organization_id == organization_id

    def deactivate(self) -> "Resource":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Resource":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })

    def transfer_ownership(self, new_owner_id: UUID) -> "Resource":
        """Transfer resource ownership."""
        return self.model_copy(update={
            "owner_id": new_owner_id,
            "updated_at": datetime.utcnow()
        })
from datetime import datetime
from uuid import UUID
from typing import Optional, Dict, Any, List
from pydantic import BaseModel


class AuthorizationContext(BaseModel):
    """Context for authorization decisions containing all relevant information."""
    
    user_id: UUID
    organization_id: Optional[UUID]
    resource_type: str
    resource_id: Optional[UUID]
    action: str
    user_attributes: Dict[str, Any]
    resource_attributes: Dict[str, Any]
    environment_attributes: Dict[str, Any]
    request_time: datetime
    
    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        resource_type: str,
        action: str,
        organization_id: Optional[UUID] = None,
        resource_id: Optional[UUID] = None,
        user_attributes: Optional[Dict[str, Any]] = None,
        resource_attributes: Optional[Dict[str, Any]] = None,
        environment_attributes: Optional[Dict[str, Any]] = None
    ) -> "AuthorizationContext":
        return cls(
            user_id=user_id,
            organization_id=organization_id,
            resource_type=resource_type,
            resource_id=resource_id,
            action=action,
            user_attributes=user_attributes or {},
            resource_attributes=resource_attributes or {},
            environment_attributes=environment_attributes or {},
            request_time=datetime.utcnow()
        )

    def add_user_attribute(self, key: str, value: Any) -> "AuthorizationContext":
        """Add user attribute to context."""
        new_attributes = self.user_attributes.copy()
        new_attributes[key] = value
        return self.model_copy(update={"user_attributes": new_attributes})

    def add_resource_attribute(self, key: str, value: Any) -> "AuthorizationContext":
        """Add resource attribute to context."""
        new_attributes = self.resource_attributes.copy()
        new_attributes[key] = value
        return self.model_copy(update={"resource_attributes": new_attributes})

    def add_environment_attribute(self, key: str, value: Any) -> "AuthorizationContext":
        """Add environment attribute to context."""
        new_attributes = self.environment_attributes.copy()
        new_attributes[key] = value
        return self.model_copy(update={"environment_attributes": new_attributes})

    def get_user_attribute(self, key: str, default: Any = None) -> Any:
        """Get user attribute value."""
        return self.user_attributes.get(key, default)

    def get_resource_attribute(self, key: str, default: Any = None) -> Any:
        """Get resource attribute value."""
        return self.resource_attributes.get(key, default)

    def get_environment_attribute(self, key: str, default: Any = None) -> Any:
        """Get environment attribute value."""
        return self.environment_attributes.get(key, default)

    def to_dict(self) -> Dict[str, Any]:
        """Convert context to dictionary for policy evaluation."""
        return {
            "user_id": str(self.user_id),
            "organization_id": str(self.organization_id) if self.organization_id else None,
            "resource_type": self.resource_type,
            "resource_id": str(self.resource_id) if self.resource_id else None,
            "action": self.action,
            "request_time": self.request_time.isoformat(),
            **self.user_attributes,
            **{f"resource_{k}": v for k, v in self.resource_attributes.items()},
            **{f"env_{k}": v for k, v in self.environment_attributes.items()}
        }

    def is_same_organization(self, other_org_id: Optional[UUID]) -> bool:
        """Check if context belongs to same organization."""
        return self.organization_id == other_org_id

    def is_resource_owner(self) -> bool:
        """Check if user is the resource owner."""
        return self.get_resource_attribute("owner_id") == str(self.user_id)

    def get_user_roles(self) -> List[str]:
        """Get user roles from context."""
        return self.get_user_attribute("roles", [])

    def has_role(self, role: str) -> bool:
        """Check if user has specific role."""
        return role in self.get_user_roles()
from .role import Role
from .permission import Permission
from .resource import Resource
from .policy import Policy
from .authorization_context import AuthorizationContext

__all__ = ["Role", "Permission", "Resource", "Policy", "AuthorizationContext"]
from typing import List, Optional
from uuid import UUID

from ..entities.authorization_context import AuthorizationContext
from ..entities.permission import Permission
from ..repositories.role_repository import RoleRepository
from ..repositories.permission_repository import PermissionRepository
from ..repositories.role_permission_repository import RolePermissionRepository
from ..value_objects.authorization_decision import AuthorizationDecision, DecisionReason


class RBACService:
    """Role-Based Access Control service."""

    def __init__(
        self,
        role_repository: RoleRepository,
        permission_repository: PermissionRepository,
        role_permission_repository: RolePermissionRepository,
    ):
        self._role_repository = role_repository
        self._permission_repository = permission_repository
        self._role_permission_repository = role_permission_repository

     def authorize(self, context: AuthorizationContext) -> AuthorizationDecision:
        """Authorize request using RBAC."""
        reasons: List[DecisionReason] = []

        # Get user roles
        user_roles = self._role_repository.get_user_roles(
            context.user_id, context.organization_id
        )

        if not user_roles:
            reason = DecisionReason(
                type="rbac_no_roles",
                message="User has no roles assigned",
                details={"user_id": str(context.user_id)},
            )
            return AuthorizationDecision.deny([reason])

        # Get user permissions through roles
        user_permissions = self.get_user_permissions(
            context.user_id, context.organization_id
        )

        if not user_permissions:
            reason = DecisionReason(
                type="rbac_no_permissions",
                message="User has no permissions through assigned roles",
                details={
                    "user_id": str(context.user_id),
                    "roles": [role.name.value for role in user_roles],
                },
            )
            return AuthorizationDecision.deny([reason])

        # Check if user has required permission
        required_permission = f"{context.resource_type}:{context.action}"

        # Check exact permission match
        if required_permission in user_permissions:
            reason = DecisionReason(
                type="rbac_allow",
                message=f"User has required permission: {required_permission}",
                details={
                    "permission": required_permission,
                    "roles": [role.name.value for role in user_roles],
                },
            )
            return AuthorizationDecision.allow([reason])

        # Check wildcard permissions
        resource_wildcard = f"{context.resource_type}:*"
        if resource_wildcard in user_permissions:
            reason = DecisionReason(
                type="rbac_allow",
                message=f"User has wildcard permission for resource: {resource_wildcard}",
                details={
                    "permission": resource_wildcard,
                    "roles": [role.name.value for role in user_roles],
                },
            )
            return AuthorizationDecision.allow([reason])

        # Check global wildcard
        if "*:*" in user_permissions:
            reason = DecisionReason(
                type="rbac_allow",
                message="User has global wildcard permission",
                details={
                    "permission": "*:*",
                    "roles": [role.name.value for role in user_roles],
                },
            )
            return AuthorizationDecision.allow([reason])

        # No matching permission found
        reason = DecisionReason(
            type="rbac_deny",
            message=f"User lacks required permission: {required_permission}",
            details={
                "required_permission": required_permission,
                "user_permissions": user_permissions,
                "roles": [role.name.value for role in user_roles],
            },
        )
        return AuthorizationDecision.deny([reason])

     def get_user_permissions(
        self, user_id: UUID, organization_id: Optional[UUID] = None
    ) -> List[str]:
        """Get all permissions for a user through their roles."""
        # Get user roles
        user_roles = self._role_repository.get_user_roles(user_id, organization_id)

        if not user_roles:
            return []

        # Get permissions for all roles
        all_permissions = set()

        for role in user_roles:
            if not role.is_active:
                continue

            role_permissions = self._permission_repository.get_role_permissions(role.id)

            for permission in role_permissions:
                if permission.is_active:
                    all_permissions.add(permission.get_full_name())

        return list(all_permissions)

     def user_has_permission(
        self,
        user_id: UUID,
        permission_name: str,
        organization_id: Optional[UUID] = None,
    ) -> bool:
        """Check if user has a specific permission."""
        user_permissions = self.get_user_permissions(user_id, organization_id)

        # Check exact match
        if permission_name in user_permissions:
            return True

        # Check wildcard matches
        resource_type, action = (
            permission_name.split(":", 1)
            if ":" in permission_name
            else (permission_name, "")
        )

        # Check resource wildcard
        resource_wildcard = f"{resource_type}:*"
        if resource_wildcard in user_permissions:
            return True

        # Check global wildcard
        if "*:*" in user_permissions:
            return True

        return False

     def get_user_roles_in_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> List[str]:
        """Get user role names in a specific organization."""
        roles = self._role_repository.get_user_roles(user_id, organization_id)
        return [role.name.value for role in roles if role.is_active]

     def user_has_role(
        self, user_id: UUID, role_name: str, organization_id: Optional[UUID] = None
    ) -> bool:
        """Check if user has a specific role."""
        user_roles = self.get_user_roles_in_organization(user_id, organization_id)
        return role_name in user_roles
from typing import Dict, Any, Optional
from datetime import datetime, time
import re

from ..entities.policy import Policy, PolicyCondition
from ..entities.authorization_context import AuthorizationContext


class PolicyEvaluationService:
    """Service for evaluating ABAC policies against authorization contexts."""
    
     def evaluate_policy(
        self, 
        policy: Policy, 
        context: AuthorizationContext
    ) -> Optional[bool]:
        """Evaluate a policy against an authorization context."""
        if not policy.is_active:
            return None
        
        # Check if policy applies to this request
        if not self._policy_applies_to_context(policy, context):
            return None
        
        # Convert context to evaluation dictionary
        evaluation_context = context.to_dict()
        
        # Add computed attributes
        evaluation_context.update(self._get_computed_attributes(context))
        
        # Evaluate all conditions
        all_conditions_met = True
        for condition in policy.conditions:
            if not self._evaluate_condition(condition, evaluation_context):
                all_conditions_met = False
                break
        
        if all_conditions_met:
            # All conditions met, return policy effect
            return policy.effect.value == "allow"
        
        # Conditions not met, policy doesn't apply
        return None
    
    def _policy_applies_to_context(self, policy: Policy, context: AuthorizationContext) -> bool:
        """Check if policy applies to the authorization context."""
        # Check resource type
        if policy.resource_type != context.resource_type:
            return False
        
        # Check action
        if policy.action != context.action:
            return False
        
        # Check organization scope
        if policy.organization_id and policy.organization_id != context.organization_id:
            return False
        
        return True
    
    def _evaluate_condition(self, condition: PolicyCondition, context: Dict[str, Any]) -> bool:
        """Evaluate a single policy condition."""
        try:
            return condition.evaluate(context)
        except Exception:
            # If condition evaluation fails, consider it false
            return False
    
    def _get_computed_attributes(self, context: AuthorizationContext) -> Dict[str, Any]:
        """Get computed attributes for policy evaluation."""
        now = datetime.utcnow()
        
        computed = {
            # Time-based attributes
            "current_hour": now.hour,
            "current_day_of_week": now.weekday(),  # 0 = Monday
            "current_month": now.month,
            "current_year": now.year,
            "is_weekend": now.weekday() >= 5,
            "is_business_hours": 9 <= now.hour <= 17,
            
            # Request attributes
            "is_same_user": str(context.user_id) == context.get_resource_attribute("owner_id"),
            "is_same_organization": (
                context.organization_id and 
                str(context.organization_id) == context.get_resource_attribute("organization_id")
            ),
            
            # Derived attributes
            "resource_age_days": self._calculate_resource_age_days(context),
            "user_role_count": len(context.get_user_attribute("roles", [])),
        }
        
        return computed
    
    def _calculate_resource_age_days(self, context: AuthorizationContext) -> int:
        """Calculate resource age in days."""
        created_at_str = context.get_resource_attribute("created_at")
        if not created_at_str:
            return 0
        
        try:
            if isinstance(created_at_str, str):
                created_at = datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))
            else:
                created_at = created_at_str
            
            age = datetime.utcnow() - created_at
            return age.days
        except Exception:
            return 0
    
     def test_policy_condition(
        self, 
        condition: PolicyCondition, 
        test_context: Dict[str, Any]
    ) -> bool:
        """Test a policy condition with provided context (for testing/debugging)."""
        return self._evaluate_condition(condition, test_context)
    
    def validate_policy_conditions(self, policy: Policy) -> tuple[bool, list[str]]:
        """Validate policy conditions for syntax and logic errors."""
        errors = []
        
        for i, condition in enumerate(policy.conditions):
            # Check attribute name
            if not condition.attribute:
                errors.append(f"Condition {i+1}: attribute name is empty")
                continue
            
            # Check operator
            valid_operators = ["eq", "ne", "gt", "lt", "gte", "lte", "in", "not_in", "contains"]
            if condition.operator not in valid_operators:
                errors.append(f"Condition {i+1}: invalid operator '{condition.operator}'")
            
            # Check value type for specific operators
            if condition.operator in ["in", "not_in"] and not isinstance(condition.value, list):
                errors.append(f"Condition {i+1}: operator '{condition.operator}' requires list value")
            
            if condition.operator in ["gt", "lt", "gte", "lte"]:
                if not isinstance(condition.value, (int, float)):
                    errors.append(f"Condition {i+1}: operator '{condition.operator}' requires numeric value")
        
        return len(errors) == 0, errors
    
     def explain_policy_evaluation(
        self, 
        policy: Policy, 
        context: AuthorizationContext
    ) -> Dict[str, Any]:
        """Explain how a policy was evaluated (for debugging)."""
        explanation = {
            "policy_id": str(policy.id),
            "policy_name": policy.name,
            "policy_applies": self._policy_applies_to_context(policy, context),
            "conditions": [],
            "overall_result": None
        }
        
        if not explanation["policy_applies"]:
            explanation["reason"] = "Policy does not apply to this context"
            return explanation
        
        evaluation_context = context.to_dict()
        evaluation_context.update(self._get_computed_attributes(context))
        
        all_conditions_met = True
        for i, condition in enumerate(policy.conditions):
            condition_result = self._evaluate_condition(condition, evaluation_context)
            
            explanation["conditions"].append({
                "index": i,
                "attribute": condition.attribute,
                "operator": condition.operator,
                "expected_value": condition.value,
                "actual_value": evaluation_context.get(condition.attribute),
                "result": condition_result
            })
            
            if not condition_result:
                all_conditions_met = False
        
        if all_conditions_met:
            explanation["overall_result"] = policy.effect.value == "allow"
        else:
            explanation["overall_result"] = None
            explanation["reason"] = "Not all conditions were met"
        
        return explanation
import time
from typing import List
from uuid import UUID

from ..entities.authorization_context import AuthorizationContext
from ..value_objects.authorization_decision import (
    AuthorizationDecision,
    DecisionReason,
    DecisionResult,
)
from .rbac_service import RBACService
from .abac_service import ABACService


class AuthorizationService:
    """Main authorization service that combines RBAC and ABAC."""

    def __init__(self, rbac_service: RBACService, abac_service: ABACService):
        self._rbac_service = rbac_service
        self._abac_service = abac_service

     def authorize(self, context: AuthorizationContext) -> AuthorizationDecision:
        """Main authorization method combining RBAC and ABAC."""
        start_time = time.time()
        reasons: List[DecisionReason] = []

        try:
            # First try RBAC (faster)
            rbac_decision = self._rbac_service.authorize(context)
            reasons.extend(rbac_decision.reasons)

            if rbac_decision.is_allowed():
                # RBAC allows, check if there are any ABAC policies that deny
                abac_decision = self._abac_service.evaluate_policies(context)
                reasons.extend(abac_decision.reasons)

                if abac_decision.is_denied():
                    # ABAC explicitly denies
                    evaluation_time = (time.time() - start_time) * 1000
                    return AuthorizationDecision.deny(reasons, evaluation_time)

                # RBAC allows and ABAC doesn't deny
                evaluation_time = (time.time() - start_time) * 1000
                return AuthorizationDecision.allow(reasons, evaluation_time)

            # RBAC denies, check ABAC for potential allow
            abac_decision = self._abac_service.evaluate_policies(context)
            reasons.extend(abac_decision.reasons)

            if abac_decision.is_allowed():
                # ABAC explicitly allows despite RBAC denial
                evaluation_time = (time.time() - start_time) * 1000
                return AuthorizationDecision.allow(reasons, evaluation_time)

            # Both deny or are not applicable
            evaluation_time = (time.time() - start_time) * 1000

            # If we have explicit deny reasons, deny. Otherwise, default deny
            has_explicit_deny = any(
                reason.type in ["rbac_deny", "policy_deny"] for reason in reasons
            )

            if has_explicit_deny or reasons:
                return AuthorizationDecision.deny(reasons, evaluation_time)
            else:
                # No applicable rules found, default deny
                default_reason = DecisionReason(
                    type="default_deny",
                    message="No applicable authorization rules found",
                    details={
                        "resource_type": context.resource_type,
                        "action": context.action,
                        "user_id": str(context.user_id),
                    },
                )
                return AuthorizationDecision.deny([default_reason], evaluation_time)

        except Exception as e:
            # Authorization failure should default to deny
            evaluation_time = (time.time() - start_time) * 1000
            error_reason = DecisionReason(
                type="authorization_error",
                message=f"Authorization evaluation failed: {str(e)}",
                details={"error": str(e)},
            )
            return AuthorizationDecision.deny([error_reason], evaluation_time)

     def can_user_access_resource(
        self,
        user_id: UUID,
        resource_type: str,
        resource_id: UUID,
        action: str,
        organization_id: UUID = None,
    ) -> bool:
        """Simplified method to check if user can access a resource."""
        context = AuthorizationContext.create(
            user_id=user_id,
            resource_type=resource_type,
            resource_id=resource_id,
            action=action,
            organization_id=organization_id,
        )

        decision = self.authorize(context)
        return decision.is_allowed()

     def get_user_permissions(
        self, user_id: UUID, organization_id: UUID = None
    ) -> List[str]:
        """Get all permissions for a user."""
        return self._rbac_service.get_user_permissions(user_id, organization_id)

     def check_multiple_permissions(
        self,
        user_id: UUID,
        resource_type: str,
        actions: List[str],
        organization_id: UUID = None,
        resource_id: UUID = None,
    ) -> dict[str, bool]:
        """Check multiple permissions at once for efficiency."""
        results = {}

        for action in actions:
            context = AuthorizationContext.create(
                user_id=user_id,
                resource_type=resource_type,
                action=action,
                organization_id=organization_id,
                resource_id=resource_id,
            )

            decision = self.authorize(context)
            results[action] = decision.is_allowed()

        return results
from typing import List, Dict, Any
from uuid import UUID

from ..entities.authorization_context import AuthorizationContext
from ..entities.policy import Policy
from ..repositories.policy_repository import PolicyRepository
from ..repositories.resource_repository import ResourceRepository
from ..value_objects.authorization_decision import AuthorizationDecision, DecisionReason
from .policy_evaluation_service import PolicyEvaluationService


class ABACService:
    """Attribute-Based Access Control service."""

    def __init__(
        self,
        policy_repository: PolicyRepository,
        resource_repository: ResourceRepository,
        policy_evaluation_service: PolicyEvaluationService,
    ):
        self._policy_repository = policy_repository
        self._resource_repository = resource_repository
        self._policy_evaluation_service = policy_evaluation_service

    def evaluate_policies(self, context: AuthorizationContext) -> AuthorizationDecision:
        """Evaluate ABAC policies for the given context."""
        reasons: List[DecisionReason] = []

        # Enrich context with resource attributes if resource_id is provided
        enriched_context = self._enrich_context_with_resource_attributes(context)

        # Get applicable policies
        applicable_policies = self._policy_repository.get_applicable_policies(
            enriched_context.resource_type,
            enriched_context.action,
            enriched_context.organization_id,
        )

        if not applicable_policies:
            reason = DecisionReason(
                type="abac_no_policies",
                message="No applicable ABAC policies found",
                details={
                    "resource_type": enriched_context.resource_type,
                    "action": enriched_context.action,
                },
            )
            return AuthorizationDecision.not_applicable([reason])

        # Sort policies by priority (highest first)
        sorted_policies = sorted(
            applicable_policies, key=lambda p: p.priority, reverse=True
        )

        # Evaluate policies
        policy_results = []
        for policy in sorted_policies:
            if not policy.is_active:
                continue

            evaluation_result = self._policy_evaluation_service.evaluate_policy(
                policy, enriched_context
            )

            if evaluation_result is not None:  # Policy is applicable
                policy_results.append((policy, evaluation_result))

                reason = DecisionReason(
                    type="policy_evaluation",
                    message=f"Policy '{policy.name}' evaluated to {evaluation_result}",
                    details={
                        "policy_id": str(policy.id),
                        "policy_name": policy.name,
                        "effect": policy.effect.value,
                        "result": evaluation_result,
                        "priority": policy.priority,
                    },
                )
                reasons.append(reason)

        # Apply policy combination logic
        final_decision = self._combine_policy_results(policy_results)

        if final_decision is True:
            return AuthorizationDecision.allow(reasons)
        elif final_decision is False:
            return AuthorizationDecision.deny(reasons)
        else:
            # No applicable policies or all policies were not applicable
            reason = DecisionReason(
                type="abac_not_applicable",
                message="No ABAC policies were applicable to this request",
                details={
                    "evaluated_policies": len(policy_results),
                    "total_policies": len(applicable_policies),
                },
            )
            return AuthorizationDecision.not_applicable([reason])

    def _enrich_context_with_resource_attributes(
        self, context: AuthorizationContext
    ) -> AuthorizationContext:
        """Enrich authorization context with resource attributes."""
        if not context.resource_id:
            return context

        # Get resource from repository
        resource = self._resource_repository.get_by_resource_id(
            context.resource_type, context.resource_id
        )

        if not resource:
            return context

        # Add resource attributes to context
        enriched_context = context
        for key, value in resource.attributes.items():
            enriched_context = enriched_context.add_resource_attribute(key, value)

        # Add common resource attributes
        enriched_context = enriched_context.add_resource_attribute(
            "owner_id", str(resource.owner_id)
        )
        enriched_context = enriched_context.add_resource_attribute(
            "is_active", resource.is_active
        )

        if resource.organization_id:
            enriched_context = enriched_context.add_resource_attribute(
                "organization_id", str(resource.organization_id)
            )

        return enriched_context

    def _combine_policy_results(
        self, policy_results: List[tuple[Policy, bool]]
    ) -> bool | None:
        """Combine policy evaluation results using deny-overrides algorithm."""
        if not policy_results:
            return None

        has_allow = False
        has_deny = False

        for policy, result in policy_results:
            if result:  # Policy condition matched
                if policy.effect.value == "deny":
                    has_deny = True
                elif policy.effect.value == "allow":
                    has_allow = True

        # Deny-overrides: if any policy denies, deny
        if has_deny:
            return False

        # If any policy allows and no policy denies, allow
        if has_allow:
            return True

        # No applicable policies
        return None

    def check_resource_ownership(
        self, user_id: UUID, resource_type: str, resource_id: UUID
    ) -> bool:
        """Check if user owns the resource."""
        resource = self._resource_repository.get_by_resource_id(
            resource_type, resource_id
        )

        if not resource:
            return False

        return resource.is_owned_by(user_id)

    def check_resource_organization_membership(
        self,
        user_id: UUID,
        resource_type: str,
        resource_id: UUID,
        organization_id: UUID,
    ) -> bool:
        """Check if resource belongs to user's organization."""
        resource = self._resource_repository.get_by_resource_id(
            resource_type, resource_id
        )

        if not resource:
            return False

        return resource.belongs_to_organization(organization_id)

    def evaluate_custom_policy(
        self, policy: Policy, context: Dict[str, Any]
    ) -> bool | None:
        """Evaluate a custom policy with provided context."""
        auth_context = AuthorizationContext.create(
            user_id=UUID(context["user_id"]),
            resource_type=context["resource_type"],
            action=context["action"],
            organization_id=UUID(context["organization_id"])
            if context.get("organization_id")
            else None,
            resource_id=UUID(context["resource_id"])
            if context.get("resource_id")
            else None,
            user_attributes=context.get("user_attributes", {}),
            resource_attributes=context.get("resource_attributes", {}),
            environment_attributes=context.get("environment_attributes", {}),
        )

        return self._policy_evaluation_service.evaluate_policy(policy, auth_context)
from .authorization_service import AuthorizationService
from .rbac_service import RBACService
from .abac_service import ABACService
from .policy_evaluation_service import PolicyEvaluationService

__all__ = [
    "AuthorizationService",
    "RBACService", 
    "ABACService",
    "PolicyEvaluationService"
]
from pydantic import BaseModel, field_validator
from typing import Any
import re


class RoleName(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Role name cannot be empty")
        
        cleaned_name = v.strip().lower()
        
        if len(cleaned_name) < 2:
            raise ValueError("Role name must be at least 2 characters long")
        
        if len(cleaned_name) > 50:
            raise ValueError("Role name cannot exceed 50 characters")
        
        # Allow letters, numbers, and underscores only
        if not re.match(r'^[a-z0-9_]+$', cleaned_name):
            raise ValueError("Role name can only contain lowercase letters, numbers, and underscores")
        
        # Must start with a letter
        if not cleaned_name[0].isalpha():
            raise ValueError("Role name must start with a letter")
        
        return cleaned_name

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, RoleName):
            return self.value == other.value
        return False

    def is_system_role(self) -> bool:
        """Check if this is a system role (starts with 'system_')."""
        return self.value.startswith('system_')

    def get_display_name(self) -> str:
        """Get human-readable display name."""
        return self.value.replace('_', ' ').title()
from datetime import datetime
from typing import Optional, List, Dict, Any
from pydantic import BaseModel
from enum import Enum


class DecisionResult(str, Enum):
    ALLOW = "allow"
    DENY = "deny"
    NOT_APPLICABLE = "not_applicable"


class DecisionReason(BaseModel):
    type: str  # "role", "policy", "ownership", "default"
    message: str
    details: Dict[str, Any]

    model_config = {"frozen": True}


class AuthorizationDecision(BaseModel):
    result: DecisionResult
    reasons: List[DecisionReason]
    evaluated_at: datetime
    evaluation_time_ms: float

    model_config = {"frozen": True}

    @classmethod
    def allow(
        cls, 
        reasons: List[DecisionReason], 
        evaluation_time_ms: float = 0.0
    ) -> "AuthorizationDecision":
        return cls(
            result=DecisionResult.ALLOW,
            reasons=reasons,
            evaluated_at=datetime.utcnow(),
            evaluation_time_ms=evaluation_time_ms
        )

    @classmethod
    def deny(
        cls, 
        reasons: List[DecisionReason], 
        evaluation_time_ms: float = 0.0
    ) -> "AuthorizationDecision":
        return cls(
            result=DecisionResult.DENY,
            reasons=reasons,
            evaluated_at=datetime.utcnow(),
            evaluation_time_ms=evaluation_time_ms
        )

    @classmethod
    def not_applicable(
        cls, 
        reasons: List[DecisionReason], 
        evaluation_time_ms: float = 0.0
    ) -> "AuthorizationDecision":
        return cls(
            result=DecisionResult.NOT_APPLICABLE,
            reasons=reasons,
            evaluated_at=datetime.utcnow(),
            evaluation_time_ms=evaluation_time_ms
        )

    def is_allowed(self) -> bool:
        """Check if the decision allows access."""
        return self.result == DecisionResult.ALLOW

    def is_denied(self) -> bool:
        """Check if the decision denies access."""
        return self.result == DecisionResult.DENY

    def is_not_applicable(self) -> bool:
        """Check if the decision is not applicable."""
        return self.result == DecisionResult.NOT_APPLICABLE

    def get_primary_reason(self) -> Optional[DecisionReason]:
        """Get the primary reason for the decision."""
        return self.reasons[0] if self.reasons else None

    def get_reasons_by_type(self, reason_type: str) -> List[DecisionReason]:
        """Get all reasons of a specific type."""
        return [reason for reason in self.reasons if reason.type == reason_type]

    def add_reason(self, reason: DecisionReason) -> "AuthorizationDecision":
        """Add a reason to the decision."""
        new_reasons = self.reasons.copy()
        new_reasons.append(reason)
        return self.model_copy(update={"reasons": new_reasons})

    def get_summary(self) -> str:
        """Get a summary of the decision."""
        if not self.reasons:
            return f"Access {self.result.value}"
        
        primary_reason = self.get_primary_reason()
        return f"Access {self.result.value}: {primary_reason.message}"

    def to_dict(self) -> Dict[str, Any]:
        """Convert decision to dictionary for logging/debugging."""
        return {
            "result": self.result.value,
            "reasons": [
                {
                    "type": reason.type,
                    "message": reason.message,
                    "details": reason.details
                }
                for reason in self.reasons
            ],
            "evaluated_at": self.evaluated_at.isoformat(),
            "evaluation_time_ms": self.evaluation_time_ms
        }
from .role_name import RoleName
from .permission_name import PermissionName
from .authorization_decision import AuthorizationDecision

__all__ = ["RoleName", "PermissionName", "AuthorizationDecision"]
from pydantic import BaseModel, field_validator
from typing import Any
import re


class PermissionName(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Permission name cannot be empty")
        
        cleaned_name = v.strip().lower()
        
        if len(cleaned_name) < 3:
            raise ValueError("Permission name must be at least 3 characters long")
        
        if len(cleaned_name) > 100:
            raise ValueError("Permission name cannot exceed 100 characters")
        
        # Allow letters, numbers, underscores, and colons
        if not re.match(r'^[a-z0-9_:]+$', cleaned_name):
            raise ValueError("Permission name can only contain lowercase letters, numbers, underscores, and colons")
        
        # Must start with a letter
        if not cleaned_name[0].isalpha():
            raise ValueError("Permission name must start with a letter")
        
        return cleaned_name

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, PermissionName):
            return self.value == other.value
        return False

    def get_resource_type(self) -> str:
        """Extract resource type from permission name (before first colon)."""
        if ':' in self.value:
            return self.value.split(':')[0]
        return self.value

    def get_action(self) -> str:
        """Extract action from permission name (after first colon)."""
        if ':' in self.value:
            parts = self.value.split(':', 1)
            return parts[1] if len(parts) > 1 else ""
        return ""

    def is_resource_permission(self) -> bool:
        """Check if this is a resource-specific permission (contains colon)."""
        return ':' in self.value

    def matches_pattern(self, pattern: str) -> bool:
        """Check if permission matches a pattern (supports wildcards)."""
        if pattern == "*":
            return True
        
        if pattern.endswith("*"):
            prefix = pattern[:-1]
            return self.value.startswith(prefix)
        
        return self.value == pattern

    def get_display_name(self) -> str:
        """Get human-readable display name."""
        return self.value.replace('_', ' ').replace(':', ' - ').title()
from abc import ABC, abstractmethod
from typing import List
from uuid import UUID


class RolePermissionRepository(ABC):
    """Role-Permission repository interface for the Authorization bounded context."""
    
    @abstractmethod
     def assign_permission_to_role(self, role_id: UUID, permission_id: UUID) -> bool:
        """Assign a permission to a role."""
        pass
    
    @abstractmethod
     def remove_permission_from_role(self, role_id: UUID, permission_id: UUID) -> bool:
        """Remove a permission from a role."""
        pass
    
    @abstractmethod
     def get_role_permission_ids(self, role_id: UUID) -> List[UUID]:
        """Get all permission IDs assigned to a role."""
        pass
    
    @abstractmethod
     def get_permission_role_ids(self, permission_id: UUID) -> List[UUID]:
        """Get all role IDs that have a permission."""
        pass
    
    @abstractmethod
     def role_has_permission(self, role_id: UUID, permission_id: UUID) -> bool:
        """Check if a role has a specific permission."""
        pass
    
    @abstractmethod
     def remove_all_role_permissions(self, role_id: UUID) -> int:
        """Remove all permissions from a role. Returns count of removed permissions."""
        pass
    
    @abstractmethod
     def remove_all_permission_assignments(self, permission_id: UUID) -> int:
        """Remove a permission from all roles. Returns count of removed assignments."""
        pass
    
    @abstractmethod
     def bulk_assign_permissions_to_role(
        self, 
        role_id: UUID, 
        permission_ids: List[UUID]
    ) -> int:
        """Bulk assign permissions to a role. Returns count of new assignments."""
        pass
    
    @abstractmethod
     def replace_role_permissions(
        self, 
        role_id: UUID, 
        permission_ids: List[UUID]
    ) -> bool:
        """Replace all permissions for a role with new set."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
from uuid import UUID

from ..entities.resource import Resource


class ResourceRepository(ABC):
    """Resource repository interface for the Authorization bounded context."""
    
    @abstractmethod
     def save(self, resource: Resource) -> Resource:
        """Save or update a resource."""
        pass
    
    @abstractmethod
     def get_by_id(self, resource_id: UUID) -> Optional[Resource]:
        """Get resource by ID."""
        pass
    
    @abstractmethod
     def get_by_resource_id(self, resource_type: str, resource_id: UUID) -> Optional[Resource]:
        """Get resource by type and actual resource ID."""
        pass
    
    @abstractmethod
     def get_by_owner_id(self, owner_id: UUID) -> List[Resource]:
        """Get all resources owned by a user."""
        pass
    
    @abstractmethod
     def get_by_organization_id(self, organization_id: UUID) -> List[Resource]:
        """Get all resources belonging to an organization."""
        pass
    
    @abstractmethod
     def get_by_type(self, resource_type: str) -> List[Resource]:
        """Get all resources of a specific type."""
        pass
    
    @abstractmethod
     def find_by_attributes(
        self, 
        resource_type: str, 
        attributes: Dict[str, Any]
    ) -> List[Resource]:
        """Find resources by attributes."""
        pass
    
    @abstractmethod
     def delete(self, resource_id: UUID) -> bool:
        """Delete resource by ID."""
        pass
    
    @abstractmethod
     def delete_by_resource_id(self, resource_type: str, resource_id: UUID) -> bool:
        """Delete resource by type and actual resource ID."""
        pass
    
    @abstractmethod
     def list_active_resources(
        self, 
        resource_type: Optional[str] = None,
        limit: int = 100, 
        offset: int = 0
    ) -> List[Resource]:
        """List active resources with pagination."""
        pass
    
    @abstractmethod
     def count_user_resources(self, user_id: UUID, resource_type: Optional[str] = None) -> int:
        """Count resources owned by a user."""
        pass
    
    @abstractmethod
     def transfer_ownership(
        self, 
        resource_type: str, 
        resource_id: UUID, 
        new_owner_id: UUID
    ) -> bool:
        """Transfer resource ownership."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.policy import Policy, PolicyEffect


class PolicyRepository(ABC):
    """Policy repository interface for the Authorization bounded context."""
    
    @abstractmethod
     def save(self, policy: Policy) -> Policy:
        """Save or update a policy."""
        pass
    
    @abstractmethod
     def get_by_id(self, policy_id: UUID) -> Optional[Policy]:
        """Get policy by ID."""
        pass
    
    @abstractmethod
     def get_by_name(self, name: str, organization_id: Optional[UUID] = None) -> Optional[Policy]:
        """Get policy by name within organization scope."""
        pass
    
    @abstractmethod
     def get_applicable_policies(
        self, 
        resource_type: str, 
        action: str,
        organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Get policies applicable to a resource type and action."""
        pass
    
    @abstractmethod
     def get_organization_policies(self, organization_id: UUID) -> List[Policy]:
        """Get all policies for an organization."""
        pass
    
    @abstractmethod
     def get_global_policies(self) -> List[Policy]:
        """Get all global policies."""
        pass
    
    @abstractmethod
     def get_policies_by_effect(
        self, 
        effect: PolicyEffect,
        organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Get policies by effect (allow/deny)."""
        pass
    
    @abstractmethod
     def delete(self, policy_id: UUID) -> bool:
        """Delete policy by ID."""
        pass
    
    @abstractmethod
     def list_active_policies(
        self, 
        organization_id: Optional[UUID] = None,
        limit: int = 100, 
        offset: int = 0
    ) -> List[Policy]:
        """List active policies with pagination."""
        pass
    
    @abstractmethod
     def search_policies(
        self, 
        query: str, 
        organization_id: Optional[UUID] = None,
        limit: int = 100
    ) -> List[Policy]:
        """Search policies by name or description."""
        pass
    
    @abstractmethod
     def get_policies_by_priority(
        self, 
        resource_type: str, 
        action: str,
        organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Get policies ordered by priority (highest first)."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.role import Role
from ..value_objects.role_name import RoleName


class RoleRepository(ABC):
    """Role repository interface for the Authorization bounded context."""
    
    @abstractmethod
     def save(self, role: Role) -> Role:
        """Save or update a role."""
        pass
    
    @abstractmethod
     def get_by_id(self, role_id: UUID) -> Optional[Role]:
        """Get role by ID."""
        pass
    
    @abstractmethod
     def get_by_name(self, name: RoleName, organization_id: Optional[UUID] = None) -> Optional[Role]:
        """Get role by name within organization scope."""
        pass
    
    @abstractmethod
     def get_organization_roles(self, organization_id: UUID) -> List[Role]:
        """Get all roles for an organization."""
        pass
    
    @abstractmethod
     def get_system_roles(self) -> List[Role]:
        """Get all system roles."""
        pass
    
    @abstractmethod
     def get_user_roles(self, user_id: UUID, organization_id: Optional[UUID] = None) -> List[Role]:
        """Get roles assigned to a user."""
        pass
    
    @abstractmethod
     def exists_by_name(self, name: RoleName, organization_id: Optional[UUID] = None) -> bool:
        """Check if role exists by name within organization scope."""
        pass
    
    @abstractmethod
     def delete(self, role_id: UUID) -> bool:
        """Delete role by ID."""
        pass
    
    @abstractmethod
     def list_active_roles(
        self, 
        organization_id: Optional[UUID] = None,
        limit: int = 100, 
        offset: int = 0
    ) -> List[Role]:
        """List active roles with pagination."""
        pass
    
    @abstractmethod
     def count_role_assignments(self, role_id: UUID) -> int:
        """Count how many users have this role assigned."""
        pass
from .role_repository import RoleRepository
from .permission_repository import PermissionRepository
from .resource_repository import ResourceRepository
from .policy_repository import PolicyRepository
from .role_permission_repository import RolePermissionRepository

__all__ = [
    "RoleRepository", 
    "PermissionRepository", 
    "ResourceRepository", 
    "PolicyRepository",
    "RolePermissionRepository"
]
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.permission import Permission, PermissionType
from ..value_objects.permission_name import PermissionName


class PermissionRepository(ABC):
    """Permission repository interface for the Authorization bounded context."""
    
    @abstractmethod
     def save(self, permission: Permission) -> Permission:
        """Save or update a permission."""
        pass
    
    @abstractmethod
     def get_by_id(self, permission_id: UUID) -> Optional[Permission]:
        """Get permission by ID."""
        pass
    
    @abstractmethod
     def get_by_name(self, name: PermissionName) -> Optional[Permission]:
        """Get permission by name."""
        pass
    
    @abstractmethod
     def get_by_resource_type(self, resource_type: str) -> List[Permission]:
        """Get all permissions for a resource type."""
        pass
    
    @abstractmethod
     def get_by_resource_and_type(
        self, 
        resource_type: str, 
        permission_type: PermissionType
    ) -> List[Permission]:
        """Get permissions by resource type and permission type."""
        pass
    
    @abstractmethod
     def get_role_permissions(self, role_id: UUID) -> List[Permission]:
        """Get all permissions assigned to a role."""
        pass
    
    @abstractmethod
     def get_user_permissions(
        self, 
        user_id: UUID, 
        organization_id: Optional[UUID] = None
    ) -> List[Permission]:
        """Get all permissions for a user (through roles)."""
        pass
    
    @abstractmethod
     def exists_by_name(self, name: PermissionName) -> bool:
        """Check if permission exists by name."""
        pass
    
    @abstractmethod
     def delete(self, permission_id: UUID) -> bool:
        """Delete permission by ID."""
        pass
    
    @abstractmethod
     def list_active_permissions(self, limit: int = 100, offset: int = 0) -> List[Permission]:
        """List active permissions with pagination."""
        pass
    
    @abstractmethod
     def search_permissions(self, query: str, limit: int = 100) -> List[Permission]:
        """Search permissions by name or description."""
        pass
from .entities import (
    Role, Permission, Resource, Policy, AuthorizationContext
)
from .value_objects import (
    RoleName, PermissionName, AuthorizationDecision
)
from .repositories import (
    RoleRepository, PermissionRepository, ResourceRepository, 
    PolicyRepository, RolePermissionRepository
)
from .services import (
    AuthorizationService, RBACService, ABACService, PolicyEvaluationService
)

__all__ = [
    # Entities
    "Role", "Permission", "Resource", "Policy", "AuthorizationContext",
    
    # Value Objects
    "RoleName", "PermissionName", "AuthorizationDecision",
    
    # Repositories
    "RoleRepository", "PermissionRepository", "ResourceRepository", 
    "PolicyRepository", "RolePermissionRepository",
    
    # Services
    "AuthorizationService", "RBACService", "ABACService", "PolicyEvaluationService"
]
from datetime import datetime
from typing import Optional, List
from uuid import UUID
from pydantic import BaseModel, Field, field_validator


class RoleCreateDTO(BaseModel):
    """DTO for creating a new role."""

    name: str = Field(..., min_length=2, max_length=50, description="Role name")
    description: str = Field(..., max_length=500, description="Role description")
    organization_id: Optional[UUID] = Field(
        None, description="Organization ID (None for global roles)"
    )
    permission_ids: List[UUID] = Field(
        default_factory=list, description="Initial permissions to assign"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Role name cannot be empty")
        # Convert to lowercase with underscores
        return v.strip().lower().replace(" ", "_").replace("-", "_")


class RoleUpdateDTO(BaseModel):
    """DTO for updating an existing role."""

    description: Optional[str] = Field(
        None, max_length=500, description="Role description"
    )
    permission_ids: Optional[List[UUID]] = Field(
        None, description="Permissions to assign (replaces current)"
    )


class RolePermissionAssignDTO(BaseModel):
    """DTO for assigning permissions to a role."""

    permission_ids: List[UUID] = Field(..., description="Permission IDs to assign")


class RolePermissionRemoveDTO(BaseModel):
    """DTO for removing permissions from a role."""

    permission_ids: List[UUID] = Field(..., description="Permission IDs to remove")


class RoleResponseDTO(BaseModel):
    """DTO for role response data."""

    id: UUID
    name: str
    description: str
    organization_id: Optional[UUID] = None
    created_by: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool
    is_system_role: bool
    permission_count: int
    assignment_count: int

    model_config = {"from_attributes": True}


class RoleDetailResponseDTO(RoleResponseDTO):
    """DTO for detailed role response with permissions."""

    permissions: List["PermissionResponseDTO"]


class RoleListResponseDTO(BaseModel):
    """DTO for paginated role list response."""

    roles: List[RoleResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


# Forward reference import
from .permission_dto import PermissionResponseDTO

RoleDetailResponseDTO.model_rebuild()
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field


class AuthorizationRequestDTO(BaseModel):
    """DTO for authorization request."""
    user_id: UUID = Field(..., description="User ID")
    resource_type: str = Field(..., description="Resource type")
    action: str = Field(..., description="Action to perform")
    organization_id: Optional[UUID] = Field(None, description="Organization ID")
    resource_id: Optional[UUID] = Field(None, description="Specific resource ID")
    user_attributes: Dict[str, Any] = Field(default_factory=dict, description="User attributes")
    resource_attributes: Dict[str, Any] = Field(default_factory=dict, description="Resource attributes")
    environment_attributes: Dict[str, Any] = Field(default_factory=dict, description="Environment attributes")


class AuthorizationResponseDTO(BaseModel):
    """DTO for authorization response."""
    user_id: UUID
    resource_type: str
    action: str
    is_authorized: bool
    decision_reason: str
    rbac_result: Optional[bool] = None
    abac_result: Optional[bool] = None
    applicable_roles: List[str] = Field(default_factory=list)
    applicable_policies: List[str] = Field(default_factory=list)
    evaluation_time_ms: float
    evaluated_at: datetime


class BulkAuthorizationRequestDTO(BaseModel):
    """DTO for bulk authorization request."""
    requests: List[AuthorizationRequestDTO] = Field(..., description="List of authorization requests")


class BulkAuthorizationResponseDTO(BaseModel):
    """DTO for bulk authorization response."""
    results: List[AuthorizationResponseDTO]
    total_requests: int
    authorized_count: int
    denied_count: int
    total_evaluation_time_ms: float


class UserPermissionsResponseDTO(BaseModel):
    """DTO for user permissions response."""
    user_id: UUID
    organization_id: Optional[UUID] = None
    resource_type: Optional[str] = None
    roles: List[str]
    permissions: List[Dict[str, Any]]
    permission_count: int


class RoleAssignmentDTO(BaseModel):
    """DTO for role assignment."""
    user_id: UUID = Field(..., description="User ID")
    role_id: UUID = Field(..., description="Role ID")
    organization_id: Optional[UUID] = Field(None, description="Organization ID")
    assigned_by: UUID = Field(..., description="User who assigned the role")
    expires_at: Optional[datetime] = Field(None, description="Role expiration date")
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from enum import Enum


class PolicyEffectEnum(str, Enum):
    ALLOW = "allow"
    DENY = "deny"


class PolicyConditionDTO(BaseModel):
    """DTO for policy condition."""

    attribute: str = Field(..., description="Attribute name")
    operator: str = Field(..., description="Comparison operator")
    value: Any = Field(..., description="Expected value")

    @field_validator("operator")
    @classmethod
    def validate_operator(cls, v: str) -> str:
        valid_operators = [
            "eq",
            "ne",
            "gt",
            "lt",
            "gte",
            "lte",
            "in",
            "not_in",
            "contains",
        ]
        if v not in valid_operators:
            raise ValueError(
                f"Invalid operator. Must be one of: {', '.join(valid_operators)}"
            )
        return v


class PolicyCreateDTO(BaseModel):
    """DTO for creating a new policy."""

    name: str = Field(..., min_length=2, max_length=100, description="Policy name")
    description: str = Field(..., max_length=500, description="Policy description")
    effect: PolicyEffectEnum = Field(..., description="Policy effect (allow/deny)")
    resource_type: str = Field(..., description="Resource type")
    action: str = Field(..., description="Action")
    conditions: List[PolicyConditionDTO] = Field(
        default_factory=list, description="Policy conditions"
    )
    organization_id: Optional[UUID] = Field(
        None, description="Organization ID (None for global policies)"
    )
    priority: int = Field(
        0, ge=0, le=1000, description="Policy priority (higher = more important)"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Policy name cannot be empty")
        return v.strip()


class PolicyUpdateDTO(BaseModel):
    """DTO for updating an existing policy."""

    description: Optional[str] = Field(
        None, max_length=500, description="Policy description"
    )
    effect: Optional[PolicyEffectEnum] = Field(None, description="Policy effect")
    conditions: Optional[List[PolicyConditionDTO]] = Field(
        None, description="Policy conditions"
    )
    priority: Optional[int] = Field(None, ge=0, le=1000, description="Policy priority")


class PolicyResponseDTO(BaseModel):
    """DTO for policy response data."""

    id: UUID
    name: str
    description: str
    effect: str
    resource_type: str
    action: str
    conditions: List[Dict[str, Any]]
    organization_id: Optional[UUID] = None
    created_by: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool
    priority: int

    model_config = {"from_attributes": True}


class PolicyListResponseDTO(BaseModel):
    """DTO for paginated policy list response."""

    policies: List[PolicyResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class PolicyEvaluationRequestDTO(BaseModel):
    """DTO for policy evaluation request."""

    user_id: UUID = Field(..., description="User ID")
    resource_type: str = Field(..., description="Resource type")
    action: str = Field(..., description="Action")
    organization_id: Optional[UUID] = Field(None, description="Organization ID")
    resource_id: Optional[UUID] = Field(None, description="Resource ID")
    user_attributes: Dict[str, Any] = Field(
        default_factory=dict, description="User attributes"
    )
    resource_attributes: Dict[str, Any] = Field(
        default_factory=dict, description="Resource attributes"
    )
    environment_attributes: Dict[str, Any] = Field(
        default_factory=dict, description="Environment attributes"
    )


class PolicyEvaluationResponseDTO(BaseModel):
    """DTO for policy evaluation response."""

    policy_id: UUID
    policy_name: str
    result: Optional[bool]  # None if not applicable
    conditions_met: bool
    condition_results: List[Dict[str, Any]]
    evaluation_time_ms: float
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from enum import Enum


class PermissionTypeEnum(str, Enum):
    CREATE = "create"
    READ = "read"
    UPDATE = "update"
    DELETE = "delete"
    EXECUTE = "execute"
    MANAGE = "manage"


class PermissionCreateDTO(BaseModel):
    """DTO for creating a new permission."""

    name: str = Field(..., min_length=3, max_length=100, description="Permission name")
    description: str = Field(..., max_length=500, description="Permission description")
    permission_type: PermissionTypeEnum = Field(..., description="Permission type")
    resource_type: str = Field(
        ..., min_length=2, max_length=50, description="Resource type"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Permission name cannot be empty")
        # Convert to lowercase with underscores/colons
        return v.strip().lower().replace(" ", "_").replace("-", "_")

    @field_validator("resource_type")
    @classmethod
    def validate_resource_type(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Resource type cannot be empty")
        return v.strip().lower().replace(" ", "_").replace("-", "_")


class PermissionResponseDTO(BaseModel):
    """DTO for permission response data."""

    id: UUID
    name: str
    description: str
    permission_type: str
    resource_type: str
    full_name: str  # resource_type:permission_type
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool
    is_system_permission: bool
    role_count: int  # Number of roles that have this permission

    model_config = {"from_attributes": True}


class PermissionListResponseDTO(BaseModel):
    """DTO for paginated permission list response."""

    permissions: List[PermissionResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class PermissionSearchDTO(BaseModel):
    """DTO for permission search criteria."""

    query: Optional[str] = Field(None, description="Search query")
    resource_type: Optional[str] = Field(None, description="Filter by resource type")
    permission_type: Optional[PermissionTypeEnum] = Field(
        None, description="Filter by permission type"
    )
    is_active: Optional[bool] = Field(None, description="Filter by active status")
from .role_dto import (
    RoleCreateDTO, RoleUpdateDTO, RoleResponseDTO, RoleDetailResponseDTO,
    RoleListResponseDTO, RolePermissionAssignDTO, RolePermissionRemoveDTO
)
from .permission_dto import (
    PermissionCreateDTO, PermissionResponseDTO, PermissionListResponseDTO,
    PermissionSearchDTO
)
from .policy_dto import (
    PolicyCreateDTO, PolicyUpdateDTO, PolicyResponseDTO, PolicyListResponseDTO,
    PolicyEvaluationRequestDTO, PolicyEvaluationResponseDTO
)
from .authorization_dto import (
    AuthorizationRequestDTO, AuthorizationResponseDTO,
    BulkAuthorizationRequestDTO, BulkAuthorizationResponseDTO,
    UserPermissionsResponseDTO, RoleAssignmentDTO
)

__all__ = [
    # Role DTOs
    "RoleCreateDTO", "RoleUpdateDTO", "RoleResponseDTO", "RoleDetailResponseDTO",
    "RoleListResponseDTO", "RolePermissionAssignDTO", "RolePermissionRemoveDTO",
    
    # Permission DTOs
    "PermissionCreateDTO", "PermissionResponseDTO", "PermissionListResponseDTO",
    "PermissionSearchDTO",
    
    # Policy DTOs
    "PolicyCreateDTO", "PolicyUpdateDTO", "PolicyResponseDTO", "PolicyListResponseDTO",
    "PolicyEvaluationRequestDTO", "PolicyEvaluationResponseDTO",
    
    # Authorization DTOs
    "AuthorizationRequestDTO", "AuthorizationResponseDTO",
    "BulkAuthorizationRequestDTO", "BulkAuthorizationResponseDTO",
    "UserPermissionsResponseDTO", "RoleAssignmentDTO"
]
from .dtos import (
    # Role DTOs
    RoleCreateDTO, RoleUpdateDTO, RoleResponseDTO, RoleDetailResponseDTO,
    RoleListResponseDTO, RolePermissionAssignDTO, RolePermissionRemoveDTO,
    
    # Permission DTOs
    PermissionCreateDTO, PermissionResponseDTO, PermissionListResponseDTO,
    PermissionSearchDTO,
    
    # Policy DTOs
    PolicyCreateDTO, PolicyUpdateDTO, PolicyResponseDTO, PolicyListResponseDTO,
    PolicyEvaluationRequestDTO, PolicyEvaluationResponseDTO,
    
    # Authorization DTOs
    AuthorizationRequestDTO, AuthorizationResponseDTO,
    BulkAuthorizationRequestDTO, BulkAuthorizationResponseDTO,
    UserPermissionsResponseDTO, RoleAssignmentDTO
)
from .use_cases import (
    AuthorizationUseCase, RoleUseCase, PermissionUseCase, PolicyUseCase
)

__all__ = [
    # DTOs
    "RoleCreateDTO", "RoleUpdateDTO", "RoleResponseDTO", "RoleDetailResponseDTO",
    "RoleListResponseDTO", "RolePermissionAssignDTO", "RolePermissionRemoveDTO",
    "PermissionCreateDTO", "PermissionResponseDTO", "PermissionListResponseDTO",
    "PermissionSearchDTO",
    "PolicyCreateDTO", "PolicyUpdateDTO", "PolicyResponseDTO", "PolicyListResponseDTO",
    "PolicyEvaluationRequestDTO", "PolicyEvaluationResponseDTO",
    "AuthorizationRequestDTO", "AuthorizationResponseDTO",
    "BulkAuthorizationRequestDTO", "BulkAuthorizationResponseDTO",
    "UserPermissionsResponseDTO", "RoleAssignmentDTO",
    
    # Use Cases
    "AuthorizationUseCase", "RoleUseCase", "PermissionUseCase", "PolicyUseCase"
]
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID

from ...domain.entities.role import Role
from ...domain.repositories.role_repository import RoleRepository
from ...domain.repositories.permission_repository import PermissionRepository
from ..dtos.role_dto import (
    RoleCreateDTO,
    RoleUpdateDTO,
    RoleResponseDTO,
    RoleDetailResponseDTO,
    RoleListResponseDTO,
    RolePermissionAssignDTO,
    RolePermissionRemoveDTO,
)
from ..dtos.permission_dto import PermissionResponseDTO


class RoleUseCase:
    """Use case for role management operations."""

    def __init__(
        self,
        role_repository: RoleRepository,
        permission_repository: PermissionRepository,
    ):
        self.role_repository = role_repository
        self.permission_repository = permission_repository

    def create_role(self, dto: RoleCreateDTO, created_by: UUID) -> RoleResponseDTO:
        """Create a new role."""
        # Validate permissions exist
        if dto.permission_ids:
            permissions = self.permission_repository.find_by_ids(dto.permission_ids)
            if len(permissions) != len(dto.permission_ids):
                raise ValueError("One or more permissions not found")

        # Create role entity
        role = Role(
            name=dto.name,
            description=dto.description,
            organization_id=dto.organization_id,
            created_by=created_by,
            created_at=datetime.now(timezone.utc),
        )

        # Save role
        saved_role = self.role_repository.save(role)

        # Assign permissions if provided
        if dto.permission_ids:
            self.role_repository.assign_permissions(saved_role.id, dto.permission_ids)

        return self._build_role_response(saved_role)

    def get_role_by_id(self, role_id: UUID) -> Optional[RoleDetailResponseDTO]:
        """Get role by ID with permissions."""
        role = self.role_repository.find_by_id(role_id)
        if not role:
            return None

        return self._build_role_detail_response(role)

    def update_role(
        self, role_id: UUID, dto: RoleUpdateDTO
    ) -> Optional[RoleResponseDTO]:
        """Update an existing role."""
        role = self.role_repository.find_by_id(role_id)
        if not role:
            return None

        # Update fields
        if dto.description is not None:
            role.description = dto.description

        role.updated_at = datetime.now(timezone.utc)

        # Save role
        updated_role = self.role_repository.save(role)

        # Update permissions if provided
        if dto.permission_ids is not None:
            # Validate permissions exist
            if dto.permission_ids:
                permissions = self.permission_repository.find_by_ids(dto.permission_ids)
                if len(permissions) != len(dto.permission_ids):
                    raise ValueError("One or more permissions not found")

            self.role_repository.replace_permissions(role_id, dto.permission_ids)

        return self._build_role_response(updated_role)

    def delete_role(self, role_id: UUID) -> bool:
        """Delete a role (soft delete)."""
        role = self.role_repository.find_by_id(role_id)
        if not role:
            return False

        # Check if role is system role
        if role.is_system_role:
            raise ValueError("Cannot delete system role")

        # Check if role has assignments
        assignment_count = self.role_repository.get_assignment_count(role_id)
        if assignment_count > 0:
            raise ValueError("Cannot delete role with active assignments")

        role.is_active = False
        role.updated_at = datetime.now(timezone.utc)
        self.role_repository.save(role)

        return True

    def list_roles(
        self,
        organization_id: Optional[UUID] = None,
        page: int = 1,
        page_size: int = 20,
        include_system: bool = True,
    ) -> RoleListResponseDTO:
        """List roles with pagination."""
        offset = (page - 1) * page_size

        roles, total = self.role_repository.find_paginated(
            organization_id=organization_id,
            include_system=include_system,
            offset=offset,
            limit=page_size,
        )

        role_responses = []
        for role in roles:
            role_responses.append(self._build_role_response(role))

        total_pages = (total + page_size - 1) // page_size

        return RoleListResponseDTO(
            roles=role_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def assign_permissions(
        self, role_id: UUID, dto: RolePermissionAssignDTO
    ) -> Optional[RoleDetailResponseDTO]:
        """Assign permissions to a role."""
        role = self.role_repository.find_by_id(role_id)
        if not role:
            return None

        # Validate permissions exist
        permissions = self.permission_repository.find_by_ids(dto.permission_ids)
        if len(permissions) != len(dto.permission_ids):
            raise ValueError("One or more permissions not found")

        self.role_repository.assign_permissions(role_id, dto.permission_ids)

        return self._build_role_detail_response(role)

    def remove_permissions(
        self, role_id: UUID, dto: RolePermissionRemoveDTO
    ) -> Optional[RoleDetailResponseDTO]:
        """Remove permissions from a role."""
        role = self.role_repository.find_by_id(role_id)
        if not role:
            return None

        self.role_repository.remove_permissions(role_id, dto.permission_ids)

        return self._build_role_detail_response(role)

    def get_roles_by_organization(self, organization_id: UUID) -> List[RoleResponseDTO]:
        """Get all roles for an organization."""
        roles = self.role_repository.find_by_organization(organization_id)

        role_responses = []
        for role in roles:
            role_responses.append(self._build_role_response(role))

        return role_responses

    def _build_role_response(self, role: Role) -> RoleResponseDTO:
        """Build role response DTO."""
        permission_count = self.role_repository.get_permission_count(role.id)
        assignment_count = self.role_repository.get_assignment_count(role.id)

        return RoleResponseDTO(
            id=role.id,
            name=role.name,
            description=role.description,
            organization_id=role.organization_id,
            created_by=role.created_by,
            created_at=role.created_at,
            updated_at=role.updated_at,
            is_active=role.is_active,
            is_system_role=role.is_system_role,
            permission_count=permission_count,
            assignment_count=assignment_count,
        )

    def _build_role_detail_response(self, role: Role) -> RoleDetailResponseDTO:
        """Build detailed role response DTO with permissions."""
        role_response = self._build_role_response(role)

        # Get permissions
        permissions = self.role_repository.get_role_permissions(role.id)
        permission_responses = [
            PermissionResponseDTO(
                id=perm.id,
                name=perm.name,
                description=perm.description,
                permission_type=perm.permission_type,
                resource_type=perm.resource_type,
                full_name=perm.full_name,
                created_at=perm.created_at,
                updated_at=perm.updated_at,
                is_active=perm.is_active,
                is_system_permission=perm.is_system_permission,
                role_count=0,  # Not needed in this context
            )
            for perm in permissions
        ]

        return RoleDetailResponseDTO(
            **role_response.model_dump(), permissions=permission_responses
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID

from ...domain.entities.permission import Permission
from ...domain.repositories.permission_repository import PermissionRepository
from ..dtos.permission_dto import (
    PermissionCreateDTO,
    PermissionResponseDTO,
    PermissionListResponseDTO,
    PermissionSearchDTO,
)


class PermissionUseCase:
    """Use case for permission management operations."""

    def __init__(self, permission_repository: PermissionRepository):
        self.permission_repository = permission_repository

    def create_permission(self, dto: PermissionCreateDTO) -> PermissionResponseDTO:
        """Create a new permission."""
        # Check if permission already exists
        existing = self.permission_repository.find_by_name_and_resource(
            dto.name, dto.resource_type
        )
        if existing:
            raise ValueError(
                f"Permission {dto.name}:{dto.resource_type} already exists"
            )

        # Create permission entity
        permission = Permission(
            name=dto.name,
            description=dto.description,
            permission_type=dto.permission_type,
            resource_type=dto.resource_type,
            created_at=datetime.now(timezone.utc),
        )

        # Save permission
        saved_permission = self.permission_repository.save(permission)

        return self._build_permission_response(saved_permission)

    def get_permission_by_id(
        self, permission_id: UUID
    ) -> Optional[PermissionResponseDTO]:
        """Get permission by ID."""
        permission = self.permission_repository.find_by_id(permission_id)
        if not permission:
            return None

        return self._build_permission_response(permission)

    def list_permissions(
        self, page: int = 1, page_size: int = 20, include_system: bool = True
    ) -> PermissionListResponseDTO:
        """List permissions with pagination."""
        offset = (page - 1) * page_size

        permissions, total = self.permission_repository.find_paginated(
            include_system=include_system, offset=offset, limit=page_size
        )

        permission_responses = []
        for permission in permissions:
            permission_responses.append(self._build_permission_response(permission))

        total_pages = (total + page_size - 1) // page_size

        return PermissionListResponseDTO(
            permissions=permission_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def search_permissions(
        self, search_dto: PermissionSearchDTO, page: int = 1, page_size: int = 20
    ) -> PermissionListResponseDTO:
        """Search permissions with filters."""
        offset = (page - 1) * page_size

        permissions, total = self.permission_repository.search(
            query=search_dto.query,
            resource_type=search_dto.resource_type,
            permission_type=search_dto.permission_type,
            is_active=search_dto.is_active,
            offset=offset,
            limit=page_size,
        )

        permission_responses = []
        for permission in permissions:
            permission_responses.append(self._build_permission_response(permission))

        total_pages = (total + page_size - 1) // page_size

        return PermissionListResponseDTO(
            permissions=permission_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_permissions_by_resource_type(
        self, resource_type: str
    ) -> List[PermissionResponseDTO]:
        """Get all permissions for a specific resource type."""
        permissions = self.permission_repository.find_by_resource_type(resource_type)

        permission_responses = []
        for permission in permissions:
            permission_responses.append(self._build_permission_response(permission))

        return permission_responses

    def delete_permission(self, permission_id: UUID) -> bool:
        """Delete a permission (soft delete)."""
        permission = self.permission_repository.find_by_id(permission_id)
        if not permission:
            return False

        # Check if permission is system permission
        if permission.is_system_permission:
            raise ValueError("Cannot delete system permission")

        # Check if permission is assigned to any roles
        role_count = self.permission_repository.get_role_count(permission_id)
        if role_count > 0:
            raise ValueError("Cannot delete permission assigned to roles")

        permission.is_active = False
        permission.updated_at = datetime.now(timezone.utc)
        self.permission_repository.save(permission)

        return True

    def get_system_permissions(self) -> List[PermissionResponseDTO]:
        """Get all system permissions."""
        permissions = self.permission_repository.find_system_permissions()

        permission_responses = []
        for permission in permissions:
            permission_responses.append(self._build_permission_response(permission))

        return permission_responses

    def bulk_create_permissions(
        self, dtos: List[PermissionCreateDTO]
    ) -> List[PermissionResponseDTO]:
        """Create multiple permissions in bulk."""
        permissions = []

        for dto in dtos:
            # Check if permission already exists
            existing = self.permission_repository.find_by_name_and_resource(
                dto.name, dto.resource_type
            )
            if existing:
                continue  # Skip existing permissions

            # Create permission entity
            permission = Permission(
                name=dto.name,
                description=dto.description,
                permission_type=dto.permission_type,
                resource_type=dto.resource_type,
                created_at=datetime.now(timezone.utc),
            )
            permissions.append(permission)

        # Bulk save
        if permissions:
            saved_permissions = self.permission_repository.bulk_save(permissions)

            permission_responses = []
            for permission in saved_permissions:
                permission_responses.append(self._build_permission_response(permission))

            return permission_responses

        return []

    def _build_permission_response(
        self, permission: Permission
    ) -> PermissionResponseDTO:
        """Build permission response DTO."""
        role_count = self.permission_repository.get_role_count(permission.id)

        return PermissionResponseDTO(
            id=permission.id,
            name=permission.name,
            description=permission.description,
            permission_type=permission.permission_type,
            resource_type=permission.resource_type,
            full_name=permission.full_name,
            created_at=permission.created_at,
            updated_at=permission.updated_at,
            is_active=permission.is_active,
            is_system_permission=permission.is_system_permission,
            role_count=role_count,
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict
from uuid import UUID

from ...domain.entities.policy import Policy
from ...domain.entities.authorization_context import AuthorizationContext
from ...domain.repositories.policy_repository import PolicyRepository
from ...domain.services.abac_service import AbacService
from ..dtos.policy_dto import (
    PolicyCreateDTO,
    PolicyUpdateDTO,
    PolicyResponseDTO,
    PolicyListResponseDTO,
    PolicyEvaluationRequestDTO,
    PolicyEvaluationResponseDTO,
)


class PolicyUseCase:
    """Use case for policy management operations."""

    def __init__(self, policy_repository: PolicyRepository, abac_service: AbacService):
        self.policy_repository = policy_repository
        self.abac_service = abac_service

    def create_policy(
        self, dto: PolicyCreateDTO, created_by: UUID
    ) -> PolicyResponseDTO:
        """Create a new policy."""
        # Create policy entity
        policy = Policy(
            name=dto.name,
            description=dto.description,
            effect=dto.effect,
            resource_type=dto.resource_type,
            action=dto.action,
            conditions=dto.conditions,
            organization_id=dto.organization_id,
            created_by=created_by,
            priority=dto.priority,
            created_at=datetime.now(timezone.utc),
        )

        # Save policy
        saved_policy = self.policy_repository.save(policy)

        return self._build_policy_response(saved_policy)

    def get_policy_by_id(self, policy_id: UUID) -> Optional[PolicyResponseDTO]:
        """Get policy by ID."""
        policy = self.policy_repository.find_by_id(policy_id)
        if not policy:
            return None

        return self._build_policy_response(policy)

    def update_policy(
        self, policy_id: UUID, dto: PolicyUpdateDTO
    ) -> Optional[PolicyResponseDTO]:
        """Update an existing policy."""
        policy = self.policy_repository.find_by_id(policy_id)
        if not policy:
            return None

        # Update fields
        if dto.description is not None:
            policy.description = dto.description
        if dto.effect is not None:
            policy.effect = dto.effect
        if dto.conditions is not None:
            policy.conditions = dto.conditions
        if dto.priority is not None:
            policy.priority = dto.priority

        policy.updated_at = datetime.now(timezone.utc)

        # Save policy
        updated_policy = self.policy_repository.save(policy)

        return self._build_policy_response(updated_policy)

    def delete_policy(self, policy_id: UUID) -> bool:
        """Delete a policy (soft delete)."""
        policy = self.policy_repository.find_by_id(policy_id)
        if not policy:
            return False

        policy.is_active = False
        policy.updated_at = datetime.now(timezone.utc)
        self.policy_repository.save(policy)

        return True

    def list_policies(
        self,
        organization_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
        action: Optional[str] = None,
        page: int = 1,
        page_size: int = 20,
    ) -> PolicyListResponseDTO:
        """List policies with pagination and filters."""
        offset = (page - 1) * page_size

        policies, total = self.policy_repository.find_paginated(
            organization_id=organization_id,
            resource_type=resource_type,
            action=action,
            offset=offset,
            limit=page_size,
        )

        policy_responses = [self._build_policy_response(policy) for policy in policies]

        total_pages = (total + page_size - 1) // page_size

        return PolicyListResponseDTO(
            policies=policy_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_policies_by_resource_and_action(
        self, resource_type: str, action: str, organization_id: Optional[UUID] = None
    ) -> List[PolicyResponseDTO]:
        """Get policies for specific resource type and action."""
        policies = self.policy_repository.find_by_resource_and_action(
            resource_type, action, organization_id
        )

        return [self._build_policy_response(policy) for policy in policies]

    def evaluate_policies(
        self, request_dto: PolicyEvaluationRequestDTO
    ) -> List[PolicyEvaluationResponseDTO]:
        """Evaluate policies for a specific request."""
        # Get applicable policies
        policies = self.policy_repository.find_by_resource_and_action(
            request_dto.resource_type, request_dto.action, request_dto.organization_id
        )

        # Create authorization context
        context = AuthorizationContext(
            user_id=request_dto.user_id,
            organization_id=request_dto.organization_id,
            resource_id=request_dto.resource_id,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            user_attributes=request_dto.user_attributes,
            resource_attributes=request_dto.resource_attributes,
            environment_attributes=request_dto.environment_attributes,
        )

        # Evaluate each policy
        evaluation_results = []

        for policy in policies:
            start_time = datetime.now(timezone.utc)

            # Evaluate policy conditions
            (
                conditions_met,
                condition_results,
            ) = self.abac_service.evaluate_policy_conditions(policy, context)

            # Determine result based on conditions
            result = None
            if conditions_met:
                result = policy.effect == "allow"

            end_time = datetime.now(timezone.utc)
            evaluation_time_ms = (end_time - start_time).total_seconds() * 1000

            evaluation_results.append(
                PolicyEvaluationResponseDTO(
                    policy_id=policy.id,
                    policy_name=policy.name,
                    result=result,
                    conditions_met=conditions_met,
                    condition_results=condition_results,
                    evaluation_time_ms=evaluation_time_ms,
                )
            )

        return evaluation_results

    def get_organization_policies(
        self, organization_id: UUID
    ) -> List[PolicyResponseDTO]:
        """Get all policies for an organization."""
        policies = self.policy_repository.find_by_organization(organization_id)
        return [self._build_policy_response(policy) for policy in policies]

    def get_global_policies(self) -> List[PolicyResponseDTO]:
        """Get all global policies."""
        policies = self.policy_repository.find_global_policies()
        return [self._build_policy_response(policy) for policy in policies]

    def duplicate_policy(
        self,
        policy_id: UUID,
        new_name: str,
        created_by: UUID,
        organization_id: Optional[UUID] = None,
    ) -> Optional[PolicyResponseDTO]:
        """Duplicate an existing policy with a new name."""
        original_policy = self.policy_repository.find_by_id(policy_id)
        if not original_policy:
            return None

        # Create new policy with same configuration but different name
        new_policy = Policy(
            name=new_name,
            description=f"Copy of {original_policy.description}",
            effect=original_policy.effect,
            resource_type=original_policy.resource_type,
            action=original_policy.action,
            conditions=original_policy.conditions.copy(),
            organization_id=organization_id or original_policy.organization_id,
            created_by=created_by,
            priority=original_policy.priority,
            created_at=datetime.now(timezone.utc),
        )

        saved_policy = self.policy_repository.save(new_policy)
        return self._build_policy_response(saved_policy)

    def bulk_update_priority(
        self, policy_priorities: Dict[UUID, int]
    ) -> List[PolicyResponseDTO]:
        """Update priorities for multiple policies."""
        updated_policies = []

        for policy_id, new_priority in policy_priorities.items():
            policy = self.policy_repository.find_by_id(policy_id)
            if policy:
                policy.priority = new_priority
                policy.updated_at = datetime.now(timezone.utc)
                updated_policy = self.policy_repository.save(policy)
                updated_policies.append(updated_policy)

        return [self._build_policy_response(policy) for policy in updated_policies]

    def _build_policy_response(self, policy: Policy) -> PolicyResponseDTO:
        """Build policy response DTO."""
        return PolicyResponseDTO(
            id=policy.id,
            name=policy.name,
            description=policy.description,
            effect=policy.effect,
            resource_type=policy.resource_type,
            action=policy.action,
            conditions=[condition.model_dump() for condition in policy.conditions],
            organization_id=policy.organization_id,
            created_by=policy.created_by,
            created_at=policy.created_at,
            updated_at=policy.updated_at,
            is_active=policy.is_active,
            priority=policy.priority,
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID

from ...domain.entities.authorization_context import AuthorizationContext
from ...domain.services.authorization_service import AuthorizationService
from ...domain.repositories.role_repository import RoleRepository
from ...domain.repositories.policy_repository import PolicyRepository
from ..dtos.authorization_dto import (
    AuthorizationRequestDTO,
    AuthorizationResponseDTO,
    BulkAuthorizationRequestDTO,
    BulkAuthorizationResponseDTO,
    UserPermissionsResponseDTO,
    RoleAssignmentDTO,
)


class AuthorizationUseCase:
    """Use case for authorization operations."""

    def __init__(
        self,
        authorization_service: AuthorizationService,
        role_repository: RoleRepository,
        policy_repository: PolicyRepository,
    ):
        self.authorization_service = authorization_service
        self.role_repository = role_repository
        self.policy_repository = policy_repository

    def check_authorization(
        self, request_dto: AuthorizationRequestDTO
    ) -> AuthorizationResponseDTO:
        """Check if a user is authorized to perform an action."""
        start_time = datetime.now(timezone.utc)

        # Create authorization context
        context = AuthorizationContext(
            user_id=request_dto.user_id,
            organization_id=request_dto.organization_id,
            resource_id=request_dto.resource_id,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            user_attributes=request_dto.user_attributes,
            resource_attributes=request_dto.resource_attributes,
            environment_attributes=request_dto.environment_attributes,
        )

        # Perform authorization check
        is_authorized, decision_info = self.authorization_service.is_authorized(context)

        end_time = datetime.now(timezone.utc)
        evaluation_time_ms = (end_time - start_time).total_seconds() * 1000

        return AuthorizationResponseDTO(
            user_id=request_dto.user_id,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            is_authorized=is_authorized,
            decision_reason=decision_info.get("reason", ""),
            rbac_result=decision_info.get("rbac_result"),
            abac_result=decision_info.get("abac_result"),
            applicable_roles=decision_info.get("roles", []),
            applicable_policies=decision_info.get("policies", []),
            evaluation_time_ms=evaluation_time_ms,
            evaluated_at=end_time,
        )

    def bulk_check_authorization(
        self, request_dto: BulkAuthorizationRequestDTO
    ) -> BulkAuthorizationResponseDTO:
        """Check authorization for multiple requests."""
        results = []

        for request in request_dto.requests:
            result = self.check_authorization(request)
            results.append(result)

        # Calculate summary statistics
        authorized_count = sum(1 for r in results if r.is_authorized)
        total_evaluation_time = sum(r.evaluation_time_ms for r in results)

        return BulkAuthorizationResponseDTO(
            results=results,
            total_requests=len(results),
            authorized_count=authorized_count,
            denied_count=len(results) - authorized_count,
            total_evaluation_time_ms=total_evaluation_time,
        )

    def get_user_permissions(
        self,
        user_id: UUID,
        organization_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
    ) -> UserPermissionsResponseDTO:
        """Get all permissions for a user."""
        # Get user roles
        user_roles = self.role_repository.find_user_roles(user_id, organization_id)

        # Get permissions from roles
        all_permissions = []
        role_names = []

        for role in user_roles:
            role_names.append(role.name)
            role_permissions = self.role_repository.get_role_permissions(role.id)

            for permission in role_permissions:
                if resource_type is None or permission.resource_type == resource_type:
                    all_permissions.append(
                        {
                            "id": str(permission.id),
                            "name": permission.name,
                            "resource_type": permission.resource_type,
                            "permission_type": permission.permission_type,
                            "full_name": permission.full_name,
                            "source_role": role.name,
                        }
                    )

        # Remove duplicates while preserving source role info
        unique_permissions = {}
        for perm in all_permissions:
            key = f"{perm['resource_type']}:{perm['permission_type']}"
            if key not in unique_permissions:
                unique_permissions[key] = perm
            else:
                # Merge source roles
                existing_roles = unique_permissions[key].get(
                    "source_roles", [unique_permissions[key]["source_role"]]
                )
                if perm["source_role"] not in existing_roles:
                    existing_roles.append(perm["source_role"])
                unique_permissions[key]["source_roles"] = existing_roles
                del unique_permissions[key]["source_role"]

        return UserPermissionsResponseDTO(
            user_id=user_id,
            organization_id=organization_id,
            resource_type=resource_type,
            roles=role_names,
            permissions=list(unique_permissions.values()),
            permission_count=len(unique_permissions),
        )

    def assign_role_to_user(self, assignment_dto: RoleAssignmentDTO) -> bool:
        """Assign a role to a user."""
        # Validate role exists
        role = self.role_repository.find_by_id(assignment_dto.role_id)
        if not role:
            raise ValueError("Role not found")

        # Check organization scope
        if (
            role.organization_id
            and role.organization_id != assignment_dto.organization_id
        ):
            raise ValueError("Role does not belong to the specified organization")

        # Assign role
        self.role_repository.assign_role_to_user(
            user_id=assignment_dto.user_id,
            role_id=assignment_dto.role_id,
            organization_id=assignment_dto.organization_id,
            assigned_by=assignment_dto.assigned_by,
            expires_at=assignment_dto.expires_at,
        )

        return True

    def remove_role_from_user(
        self, user_id: UUID, role_id: UUID, organization_id: Optional[UUID] = None
    ) -> bool:
        """Remove a role from a user."""
        return self.role_repository.remove_role_from_user(
            user_id=user_id, role_id=role_id, organization_id=organization_id
        )

    def get_user_roles(
        self, user_id: UUID, organization_id: Optional[UUID] = None
    ) -> List[Dict[str, Any]]:
        """Get all roles assigned to a user."""
        roles = self.role_repository.find_user_roles(user_id, organization_id)

        return [
            {
                "id": str(role.id),
                "name": role.name,
                "description": role.description,
                "organization_id": str(role.organization_id)
                if role.organization_id
                else None,
                "is_system_role": role.is_system_role,
                "created_at": role.created_at.isoformat(),
            }
            for role in roles
        ]

    def check_user_has_permission(
        self,
        user_id: UUID,
        permission_name: str,
        resource_type: str,
        organization_id: Optional[UUID] = None,
    ) -> bool:
        """Check if a user has a specific permission."""
        context = AuthorizationContext(
            user_id=user_id,
            organization_id=organization_id,
            resource_type=resource_type,
            action=permission_name,
        )

        is_authorized, _ = self.authorization_service.is_authorized(context)
        return is_authorized

    def get_resource_policies(
        self,
        resource_type: str,
        action: Optional[str] = None,
        organization_id: Optional[UUID] = None,
    ) -> List[Dict[str, Any]]:
        """Get all policies applicable to a resource type."""
        if action:
            policies = self.policy_repository.find_by_resource_and_action(
                resource_type, action, organization_id
            )
        else:
            policies = self.policy_repository.find_by_resource_type(
                resource_type, organization_id
            )

        return [
            {
                "id": str(policy.id),
                "name": policy.name,
                "description": policy.description,
                "effect": policy.effect,
                "resource_type": policy.resource_type,
                "action": policy.action,
                "conditions": [
                    condition.model_dump() for condition in policy.conditions
                ],
                "priority": policy.priority,
                "is_active": policy.is_active,
            }
            for policy in policies
        ]
from .authorization_use_cases import AuthorizationUseCase
from .role_use_cases import RoleUseCase
from .permission_use_cases import PermissionUseCase
from .policy_use_cases import PolicyUseCase

__all__ = [
    "AuthorizationUseCase",
    "RoleUseCase", 
    "PermissionUseCase",
    "PolicyUseCase"
]
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, delete, and_
from sqlalchemy.exc import IntegrityError

from ...domain.entities.policy import Policy, PolicyCondition
from ...domain.repositories.policy_repository import PolicyRepository
from ....infrastructure.database.models.authorization_models import (
    PolicyModel,
    PolicyEffectEnum,
)


class SqlAlchemyPolicyRepository(PolicyRepository):
    """SQLAlchemy implementation of PolicyRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, policy: Policy) -> Policy:
        """Save a policy entity."""
        try:
            # Check if policy exists
            existing = self.session.get(PolicyModel, policy.id)

            if existing:
                # Update existing policy
                existing.name = policy.name
                existing.description = policy.description
                existing.effect = PolicyEffectEnum(policy.effect)
                existing.resource_type = policy.resource_type
                existing.action = policy.action
                existing.conditions = [
                    condition.to_dict() for condition in policy.conditions
                ]
                existing.organization_id = policy.organization_id
                existing.created_by = policy.created_by
                existing.priority = policy.priority
                existing.is_active = policy.is_active
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new policy
                policy_model = PolicyModel(
                    id=policy.id,
                    name=policy.name,
                    description=policy.description,
                    effect=PolicyEffectEnum(policy.effect),
                    resource_type=policy.resource_type,
                    action=policy.action,
                    conditions=[condition.to_dict() for condition in policy.conditions],
                    organization_id=policy.organization_id,
                    created_by=policy.created_by,
                    priority=policy.priority,
                    is_active=policy.is_active,
                    created_at=policy.created_at,
                    updated_at=policy.updated_at,
                )

                self.session.add(policy_model)
                self.session.flush()
                return self._to_domain_entity(policy_model)

        except IntegrityError as e:
            self.session.rollback()
            raise e

    def find_by_id(self, policy_id: UUID) -> Optional[Policy]:
        """Find a policy by ID."""
        result = self.session.execute(
            select(PolicyModel).where(PolicyModel.id == policy_id)
        )
        policy_model = result.scalar_one_or_none()

        if policy_model:
            return self._to_domain_entity(policy_model)
        return None

    def find_by_name(
        self, name: str, organization_id: Optional[UUID] = None
    ) -> Optional[Policy]:
        """Find a policy by name within organization scope."""
        result = self.session.execute(
            select(PolicyModel).where(
                and_(
                    PolicyModel.name == name,
                    PolicyModel.organization_id == organization_id,
                )
            )
        )
        policy_model = result.scalar_one_or_none()

        if policy_model:
            return self._to_domain_entity(policy_model)
        return None

    def find_by_resource_and_action(
        self, resource_type: str, action: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Find policies for specific resource type and action."""
        query_conditions = [
            PolicyModel.resource_type == resource_type,
            PolicyModel.action == action,
            PolicyModel.is_active,
        ]

        # Include both organization-specific and global policies
        if organization_id:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            query_conditions.append(org_condition)
        else:
            query_conditions.append(PolicyModel.organization_id.is_(None))

        result = self.session.execute(
            select(PolicyModel)
            .where(and_(*query_conditions))
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_by_resource_type(
        self, resource_type: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Find policies for a specific resource type."""
        query_conditions = [
            PolicyModel.resource_type == resource_type,
            PolicyModel.is_active,
        ]

        if organization_id:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            query_conditions.append(org_condition)
        else:
            query_conditions.append(PolicyModel.organization_id.is_(None))

        result = self.session.execute(
            select(PolicyModel)
            .where(and_(*query_conditions))
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_by_organization(self, organization_id: UUID) -> List[Policy]:
        """Find policies for an organization."""
        result = self.session.execute(
            select(PolicyModel)
            .where(
                and_(
                    PolicyModel.organization_id == organization_id,
                    PolicyModel.is_active,
                )
            )
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_global_policies(self) -> List[Policy]:
        """Find all global policies."""
        result = self.session.execute(
            select(PolicyModel)
            .where(and_(PolicyModel.organization_id.is_(None), PolicyModel.is_active))
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_by_effect(
        self, effect: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Find policies by effect (allow/deny)."""
        query_conditions = [
            PolicyModel.effect == PolicyEffectEnum(effect),
            PolicyModel.is_active,
        ]

        if organization_id:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            query_conditions.append(org_condition)

        result = self.session.execute(
            select(PolicyModel)
            .where(and_(*query_conditions))
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
        action: Optional[str] = None,
        effect: Optional[str] = None,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Policy], int]:
        """Find policies with pagination and filters."""
        query = select(PolicyModel)
        count_query = select(PolicyModel)

        # Apply filters
        if organization_id is not None:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            query = query.where(org_condition)
            count_query = count_query.where(org_condition)

        if resource_type:
            query = query.where(PolicyModel.resource_type == resource_type)
            count_query = count_query.where(PolicyModel.resource_type == resource_type)

        if action:
            query = query.where(PolicyModel.action == action)
            count_query = count_query.where(PolicyModel.action == action)

        if effect:
            query = query.where(PolicyModel.effect == PolicyEffectEnum(effect))
            count_query = count_query.where(
                PolicyModel.effect == PolicyEffectEnum(effect)
            )

        if is_active is not None:
            query = query.where(PolicyModel.is_active == is_active)
            count_query = count_query.where(PolicyModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(PolicyModel.priority.desc(), PolicyModel.created_at.desc())
        )
        result = self.session.execute(query)
        policy_models = result.scalars().all()

        policies = [self._to_domain_entity(model) for model in policy_models]
        return policies, total

    def delete(self, policy_id: UUID) -> bool:
        """Delete a policy (hard delete)."""
        result = self.session.execute(
            delete(PolicyModel).where(PolicyModel.id == policy_id)
        )
        return result.rowcount > 0

    def search(
        self,
        query: Optional[str] = None,
        organization_id: Optional[UUID] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Policy], int]:
        """Search policies with text query."""
        db_query = select(PolicyModel)
        count_query = select(PolicyModel)

        # Apply text search
        if query:
            search_filter = (
                PolicyModel.name.ilike(f"%{query}%")
                | PolicyModel.description.ilike(f"%{query}%")
                | PolicyModel.resource_type.ilike(f"%{query}%")
                | PolicyModel.action.ilike(f"%{query}%")
            )
            db_query = db_query.where(search_filter)
            count_query = count_query.where(search_filter)

        # Apply organization filter
        if organization_id is not None:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            db_query = db_query.where(org_condition)
            count_query = count_query.where(org_condition)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        db_query = (
            db_query.offset(offset)
            .limit(limit)
            .order_by(PolicyModel.priority.desc(), PolicyModel.created_at.desc())
        )
        result = self.session.execute(db_query)
        policy_models = result.scalars().all()

        policies = [self._to_domain_entity(model) for model in policy_models]
        return policies, total

    def get_resource_types(self) -> List[str]:
        """Get all unique resource types."""
        result = self.session.execute(select(PolicyModel.resource_type).distinct())
        return [row[0] for row in result.fetchall()]

    def get_actions(self) -> List[str]:
        """Get all unique actions."""
        result = self.session.execute(select(PolicyModel.action).distinct())
        return [row[0] for row in result.fetchall()]

    def count_policies_by_organization(self, organization_id: UUID) -> int:
        """Count policies for an organization."""
        result = self.session.execute(
            select(PolicyModel).where(
                and_(
                    PolicyModel.organization_id == organization_id,
                    PolicyModel.is_active,
                )
            )
        )
        return len(result.scalars().all())

    def _to_domain_entity(self, policy_model: PolicyModel) -> Policy:
        """Convert SQLAlchemy model to domain entity."""
        conditions = [
            PolicyCondition.from_dict(condition_dict)
            for condition_dict in policy_model.conditions
        ]

        return Policy(
            id=policy_model.id,
            name=policy_model.name,
            description=policy_model.description,
            effect=policy_model.effect.value,
            resource_type=policy_model.resource_type,
            action=policy_model.action,
            conditions=conditions,
            organization_id=policy_model.organization_id,
            created_by=policy_model.created_by,
            priority=policy_model.priority,
            is_active=policy_model.is_active,
            created_at=policy_model.created_at,
            updated_at=policy_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, delete, and_, text
from sqlalchemy.exc import IntegrityError

from ...domain.entities.role import Role
from ...domain.entities.permission import Permission
from ...domain.repositories.role_repository import RoleRepository
from ....infrastructure.database.models.authorization_models import (
    RoleModel,
    PermissionModel,
    role_permission_association,
    user_role_assignment,
)


class SqlAlchemyRoleRepository(RoleRepository):
    """SQLAlchemy implementation of RoleRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, role: Role) -> Role:
        """Save a role entity."""
        try:
            # Check if role exists
            existing = self.session.get(RoleModel, role.id)

            if existing:
                # Update existing role
                existing.name = role.name
                existing.description = role.description
                existing.organization_id = role.organization_id
                existing.created_by = role.created_by
                existing.is_active = role.is_active
                existing.is_system_role = role.is_system_role
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new role
                role_model = RoleModel(
                    id=role.id,
                    name=role.name,
                    description=role.description,
                    organization_id=role.organization_id,
                    created_by=role.created_by,
                    is_active=role.is_active,
                    is_system_role=role.is_system_role,
                    created_at=role.created_at,
                    updated_at=role.updated_at,
                )

                self.session.add(role_model)
                self.session.flush()
                return self._to_domain_entity(role_model)

        except IntegrityError as e:
            self.session.rollback()
            if "name" in str(e) and "organization_id" in str(e):
                org_scope = (
                    f" in organization {role.organization_id}"
                    if role.organization_id
                    else " globally"
                )
                raise ValueError(
                    f"Role with name '{role.name}' already exists{org_scope}"
                )
            raise e

    def find_by_id(self, role_id: UUID) -> Optional[Role]:
        """Find a role by ID."""
        result = self.session.execute(select(RoleModel).where(RoleModel.id == role_id))
        role_model = result.scalar_one_or_none()

        if role_model:
            return self._to_domain_entity(role_model)
        return None

    def find_by_name(
        self, name: str, organization_id: Optional[UUID] = None
    ) -> Optional[Role]:
        """Find a role by name within organization scope."""
        result = self.session.execute(
            select(RoleModel).where(
                and_(
                    RoleModel.name == name, RoleModel.organization_id == organization_id
                )
            )
        )
        role_model = result.scalar_one_or_none()

        if role_model:
            return self._to_domain_entity(role_model)
        return None

    def find_by_organization(self, organization_id: UUID) -> List[Role]:
        """Find roles for an organization."""
        result = self.session.execute(
            select(RoleModel).where(
                and_(
                    RoleModel.organization_id == organization_id,
                    RoleModel.is_active,
                )
            )
        )
        role_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in role_models]

    def find_system_roles(self) -> List[Role]:
        """Find all system roles."""
        result = self.session.execute(
            select(RoleModel).where(and_(RoleModel.is_system_role, RoleModel.is_active))
        )
        role_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in role_models]

    def find_user_roles(
        self, user_id: UUID, organization_id: Optional[UUID] = None
    ) -> List[Role]:
        """Find roles assigned to a user."""
        query = (
            select(RoleModel)
            .select_from(RoleModel.join(user_role_assignment))
            .where(
                and_(
                    user_role_assignment.c.user_id == user_id,
                    user_role_assignment.c.is_active,
                    RoleModel.is_active,
                )
            )
        )

        if organization_id:
            query = query.where(
                user_role_assignment.c.organization_id == organization_id
            )

        result = self.session.execute(query)
        role_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in role_models]

    def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        include_system: bool = True,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Role], int]:
        """Find roles with pagination and filters."""
        query = select(RoleModel)
        count_query = select(RoleModel)

        # Apply filters
        if organization_id is not None:
            query = query.where(RoleModel.organization_id == organization_id)
            count_query = count_query.where(
                RoleModel.organization_id == organization_id
            )

        if not include_system:
            query = query.where(not RoleModel.is_system_role)
            count_query = count_query.where(not RoleModel.is_system_role)

        if is_active is not None:
            query = query.where(RoleModel.is_active == is_active)
            count_query = count_query.where(RoleModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(RoleModel.created_at.desc())
        result = self.session.execute(query)
        role_models = result.scalars().all()

        roles = [self._to_domain_entity(model) for model in role_models]
        return roles, total

    def delete(self, role_id: UUID) -> bool:
        """Delete a role (hard delete)."""
        result = self.session.execute(delete(RoleModel).where(RoleModel.id == role_id))
        return result.rowcount > 0

    def assign_permissions(self, role_id: UUID, permission_ids: List[UUID]) -> bool:
        """Assign permissions to a role."""
        # Remove existing permissions first
        self.session.execute(
            text("DELETE FROM role_permissions WHERE role_id = :role_id").bindparam(
                role_id=role_id
            )
        )

        # Add new permissions
        for permission_id in permission_ids:
            self.session.execute(
                text(
                    "INSERT INTO role_permissions (role_id, permission_id) VALUES (:role_id, :permission_id)"
                ).bindparam(role_id=role_id, permission_id=permission_id)
            )

        return True

    def remove_permissions(self, role_id: UUID, permission_ids: List[UUID]) -> bool:
        """Remove specific permissions from a role."""
        for permission_id in permission_ids:
            self.session.execute(
                text(
                    "DELETE FROM role_permissions WHERE role_id = :role_id AND permission_id = :permission_id"
                ).bindparam(role_id=role_id, permission_id=permission_id)
            )

        return True

    def replace_permissions(self, role_id: UUID, permission_ids: List[UUID]) -> bool:
        """Replace all role permissions with new ones."""
        return self.assign_permissions(role_id, permission_ids)

    def get_role_permissions(self, role_id: UUID) -> List[Permission]:
        """Get all permissions for a role."""
        result = self.session.execute(
            select(PermissionModel)
            .select_from(PermissionModel.join(role_permission_association))
            .where(role_permission_association.c.role_id == role_id)
        )
        permission_models = result.scalars().all()

        return [self._permission_to_domain_entity(model) for model in permission_models]

    def assign_role_to_user(
        self,
        user_id: UUID,
        role_id: UUID,
        organization_id: Optional[UUID],
        assigned_by: UUID,
        expires_at: Optional[datetime] = None,
    ) -> bool:
        """Assign a role to a user."""
        self.session.execute(
            text("""
                INSERT INTO user_role_assignments 
                (user_id, role_id, organization_id, assigned_by, expires_at) 
                VALUES (:user_id, :role_id, :organization_id, :assigned_by, :expires_at)
            """).bindparam(
                user_id=user_id,
                role_id=role_id,
                organization_id=organization_id,
                assigned_by=assigned_by,
                expires_at=expires_at,
            )
        )
        return True

    def remove_role_from_user(
        self, user_id: UUID, role_id: UUID, organization_id: Optional[UUID] = None
    ) -> bool:
        """Remove a role from a user."""
        query = """
            UPDATE user_role_assignments 
            SET is_active = false 
            WHERE user_id = :user_id AND role_id = :role_id
        """
        params = {"user_id": user_id, "role_id": role_id}

        if organization_id:
            query += " AND organization_id = :organization_id"
            params["organization_id"] = organization_id

        result = self.session.execute(text(query).bindparam(**params))
        return result.rowcount > 0

    def get_permission_count(self, role_id: UUID) -> int:
        """Get the number of permissions assigned to a role."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM role_permissions WHERE role_id = :role_id"
            ).bindparam(role_id=role_id)
        )
        return result.scalar() or 0

    def get_assignment_count(self, role_id: UUID) -> int:
        """Get the number of users assigned to a role."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM user_role_assignments WHERE role_id = :role_id AND is_active = true"
            ).bindparam(role_id=role_id)
        )
        return result.scalar() or 0

    def _to_domain_entity(self, role_model: RoleModel) -> Role:
        """Convert SQLAlchemy model to domain entity."""
        return Role(
            id=role_model.id,
            name=role_model.name,
            description=role_model.description,
            organization_id=role_model.organization_id,
            created_by=role_model.created_by,
            is_active=role_model.is_active,
            is_system_role=role_model.is_system_role,
            created_at=role_model.created_at,
            updated_at=role_model.updated_at,
        )

    def _permission_to_domain_entity(
        self, permission_model: PermissionModel
    ) -> Permission:
        """Convert SQLAlchemy permission model to domain entity."""
        return Permission(
            id=permission_model.id,
            name=permission_model.name,
            description=permission_model.description,
            permission_type=permission_model.permission_type.value,
            resource_type=permission_model.resource_type,
            is_active=permission_model.is_active,
            is_system_permission=permission_model.is_system_permission,
            created_at=permission_model.created_at,
            updated_at=permission_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy import select, delete, and_, text
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from ...domain.entities.permission import Permission
from ...domain.repositories.permission_repository import PermissionRepository
from ....infrastructure.database.models.authorization_models import (
    PermissionModel,
    PermissionTypeEnum,
)


class SqlAlchemyPermissionRepository(PermissionRepository):
    """SQLAlchemy implementation of PermissionRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, permission: Permission) -> Permission:
        """Save a permission entity."""
        try:
            # Check if permission exists
            existing = self.session.get(PermissionModel, permission.id)

            if existing:
                # Update existing permission
                existing.name = permission.name
                existing.description = permission.description
                existing.permission_type = PermissionTypeEnum(
                    permission.permission_type
                )
                existing.resource_type = permission.resource_type
                existing.is_active = permission.is_active
                existing.is_system_permission = permission.is_system_permission
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new permission
                permission_model = PermissionModel(
                    id=permission.id,
                    name=permission.name,
                    description=permission.description,
                    permission_type=PermissionTypeEnum(permission.permission_type),
                    resource_type=permission.resource_type,
                    is_active=permission.is_active,
                    is_system_permission=permission.is_system_permission,
                    created_at=permission.created_at,
                    updated_at=permission.updated_at,
                )

                self.session.add(permission_model)
                self.session.flush()
                return self._to_domain_entity(permission_model)

        except IntegrityError as e:
            self.session.rollback()
            if "name" in str(e) and "resource_type" in str(e):
                raise ValueError(
                    f"Permission '{permission.name}' already exists for resource type '{permission.resource_type}'"
                )
            raise e

    def find_by_id(self, permission_id: UUID) -> Optional[Permission]:
        """Find a permission by ID."""
        result = self.session.execute(
            select(PermissionModel).where(PermissionModel.id == permission_id)
        )
        permission_model = result.scalar_one_or_none()

        if permission_model:
            return self._to_domain_entity(permission_model)
        return None

    def find_by_name_and_resource(
        self, name: str, resource_type: str
    ) -> Optional[Permission]:
        """Find a permission by name and resource type."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.name == name,
                    PermissionModel.resource_type == resource_type,
                )
            )
        )
        permission_model = result.scalar_one_or_none()

        if permission_model:
            return self._to_domain_entity(permission_model)
        return None

    def find_by_resource_type(self, resource_type: str) -> List[Permission]:
        """Find permissions for a specific resource type."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.resource_type == resource_type,
                    PermissionModel.is_active,
                )
            )
        )
        permission_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in permission_models]

    def find_by_type(self, permission_type: str) -> List[Permission]:
        """Find permissions by permission type."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.permission_type
                    == PermissionTypeEnum(permission_type),
                    PermissionModel.is_active,
                )
            )
        )
        permission_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in permission_models]

    def find_system_permissions(self) -> List[Permission]:
        """Find all system permissions."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.is_system_permission,
                    PermissionModel.is_active,
                )
            )
        )
        permission_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in permission_models]

    def find_by_ids(self, permission_ids: List[UUID]) -> List[Permission]:
        """Find permissions by list of IDs."""
        result = self.session.execute(
            select(PermissionModel).where(PermissionModel.id.in_(permission_ids))
        )
        permission_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in permission_models]

    def find_paginated(
        self,
        include_system: bool = True,
        is_active: Optional[bool] = None,
        resource_type: Optional[str] = None,
        permission_type: Optional[str] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Permission], int]:
        """Find permissions with pagination and filters."""
        query = select(PermissionModel)
        count_query = select(PermissionModel)

        # Apply filters
        if not include_system:
            query = query.where(not PermissionModel.is_system_permission)
            count_query = count_query.where(not PermissionModel.is_system_permission)

        if is_active is not None:
            query = query.where(PermissionModel.is_active == is_active)
            count_query = count_query.where(PermissionModel.is_active == is_active)

        if resource_type:
            query = query.where(PermissionModel.resource_type == resource_type)
            count_query = count_query.where(
                PermissionModel.resource_type == resource_type
            )

        if permission_type:
            query = query.where(
                PermissionModel.permission_type == PermissionTypeEnum(permission_type)
            )
            count_query = count_query.where(
                PermissionModel.permission_type == PermissionTypeEnum(permission_type)
            )

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(PermissionModel.created_at.desc())
        )
        result = self.session.execute(query)
        permission_models = result.scalars().all()

        permissions = [self._to_domain_entity(model) for model in permission_models]
        return permissions, total

    def search(
        self,
        query: Optional[str] = None,
        resource_type: Optional[str] = None,
        permission_type: Optional[str] = None,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Permission], int]:
        """Search permissions with text query and filters."""
        db_query = select(PermissionModel)
        count_query = select(PermissionModel)

        # Apply text search
        if query:
            search_filter = PermissionModel.name.ilike(
                f"%{query}%"
            ) | PermissionModel.description.ilike(f"%{query}%")
            db_query = db_query.where(search_filter)
            count_query = count_query.where(search_filter)

        # Apply filters
        if resource_type:
            db_query = db_query.where(PermissionModel.resource_type == resource_type)
            count_query = count_query.where(
                PermissionModel.resource_type == resource_type
            )

        if permission_type:
            db_query = db_query.where(
                PermissionModel.permission_type == PermissionTypeEnum(permission_type)
            )
            count_query = count_query.where(
                PermissionModel.permission_type == PermissionTypeEnum(permission_type)
            )

        if is_active is not None:
            db_query = db_query.where(PermissionModel.is_active == is_active)
            count_query = count_query.where(PermissionModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        db_query = (
            db_query.offset(offset)
            .limit(limit)
            .order_by(PermissionModel.created_at.desc())
        )
        result = self.session.execute(db_query)
        permission_models = result.scalars().all()

        permissions = [self._to_domain_entity(model) for model in permission_models]
        return permissions, total

    def delete(self, permission_id: UUID) -> bool:
        """Delete a permission (hard delete)."""
        result = self.session.execute(
            delete(PermissionModel).where(PermissionModel.id == permission_id)
        )
        return result.rowcount > 0

    def bulk_save(self, permissions: List[Permission]) -> List[Permission]:
        """Save multiple permissions in bulk."""
        saved_permissions = []

        for permission in permissions:
            # Check if permission exists
            existing = self.find_by_name_and_resource(
                permission.name, permission.resource_type
            )
            if existing:
                continue  # Skip existing permissions

            permission_model = PermissionModel(
                id=permission.id,
                name=permission.name,
                description=permission.description,
                permission_type=PermissionTypeEnum(permission.permission_type),
                resource_type=permission.resource_type,
                is_active=permission.is_active,
                is_system_permission=permission.is_system_permission,
                created_at=permission.created_at,
                updated_at=permission.updated_at,
            )

            self.session.add(permission_model)
            saved_permissions.append(permission)

        self.session.flush()
        return saved_permissions

    def get_role_count(self, permission_id: UUID) -> int:
        """Get the number of roles that have this permission."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM role_permissions WHERE permission_id = :permission_id"
            ).bindparam(permission_id=permission_id)
        )
        return result.scalar() or 0

    def get_resource_types(self) -> List[str]:
        """Get all unique resource types."""
        result = self.session.execute(select(PermissionModel.resource_type).distinct())
        return [row[0] for row in result.fetchall()]

    def get_permission_types(self) -> List[str]:
        """Get all permission types."""
        return [pt.value for pt in PermissionTypeEnum]

    def _to_domain_entity(self, permission_model: PermissionModel) -> Permission:
        """Convert SQLAlchemy model to domain entity."""
        return Permission(
            id=permission_model.id,
            name=permission_model.name,
            description=permission_model.description,
            permission_type=permission_model.permission_type.value,
            resource_type=permission_model.resource_type,
            is_active=permission_model.is_active,
            is_system_permission=permission_model.is_system_permission,
            created_at=permission_model.created_at,
            updated_at=permission_model.updated_at,
        )
from .sqlalchemy_role_repository import SqlAlchemyRoleRepository
from .sqlalchemy_permission_repository import SqlAlchemyPermissionRepository
from .sqlalchemy_policy_repository import SqlAlchemyPolicyRepository

__all__ = [
    "SqlAlchemyRoleRepository",
    "SqlAlchemyPermissionRepository", 
    "SqlAlchemyPolicyRepository"
]
from .repositories import (
    SqlAlchemyRoleRepository, SqlAlchemyPermissionRepository, SqlAlchemyPolicyRepository
)

__all__ = [
    "SqlAlchemyRoleRepository",
    "SqlAlchemyPermissionRepository", 
    "SqlAlchemyPolicyRepository"
]
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel, Field

from ..value_objects.email import Email
from ..value_objects.password import Password


class User(BaseModel):
    id: UUID
    email: Email
    name: str
    password: Password
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"arbitrary_types_allowed": True}

    @classmethod
    def create(cls, email: str, name: str, password: str) -> "User":
        return cls(
            id=uuid4(),
            email=Email(value=email),
            name=name,
            password=Password.create(password),
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "User":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "User":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "User":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
    
    def change_password(self, new_password: str) -> "User":
        return self.model_copy(update={
            "password": Password.create(new_password),
            "updated_at": datetime.utcnow()
        })
    
    def verify_password(self, plain_password: str) -> bool:
        return self.password.verify(plain_password)

    def can_access_organization(self, organization_id: UUID) -> bool:
        """Domain rule: User can access organization they belong to"""
        return self.is_active
from datetime import datetime, timedelta
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel


class UserSession(BaseModel):
    id: UUID
    user_id: UUID
    token: str
    expires_at: datetime
    created_at: datetime
    is_active: bool = True
    user_agent: Optional[str] = None
    ip_address: Optional[str] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls, 
        user_id: UUID, 
        token: str, 
        duration_hours: int = 24,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None
    ) -> "UserSession":
        return cls(
            id=uuid4(),
            user_id=user_id,
            token=token,
            expires_at=datetime.utcnow() + timedelta(hours=duration_hours),
            created_at=datetime.utcnow(),
            is_active=True,
            user_agent=user_agent,
            ip_address=ip_address
        )

    def is_expired(self) -> bool:
        return datetime.utcnow() > self.expires_at

    def is_valid(self) -> bool:
        return self.is_active and not self.is_expired()

    def revoke(self) -> "UserSession":
        return self.model_copy(update={"is_active": False})

    def extend(self, hours: int = 24) -> "UserSession":
        return self.model_copy(update={
            "expires_at": self.expires_at + timedelta(hours=hours)
        })
from .user import User
from .user_session import UserSession

__all__ = ["User", "UserSession"]
from typing import Optional
from uuid import UUID

from ..entities.user import User
from ..value_objects.email import Email
from ..repositories.user_repository import UserRepository


class UserDomainService:
    """Domain service for user-specific business logic."""

    def __init__(self, user_repository: UserRepository):
        self._user_repository = user_repository

    def is_email_available(
        self, email: Email, excluding_user_id: Optional[UUID] = None
    ) -> bool:
        """Check if email is available for registration or update."""
        existing_user = self._user_repository.get_by_email(email)

        if not existing_user:
            return True

        # If excluding a specific user (for updates), check if it's the same user
        if excluding_user_id and existing_user.id == excluding_user_id:
            return True

        return False

    def can_user_be_deleted(self, user_id: UUID) -> tuple[bool, str]:
        """Check if user can be safely deleted and return reason if not."""
        user = self._user_repository.get_by_id(user_id)

        if not user:
            return False, "User not found"

        # Add business rules for user deletion
        # For example: check if user is the only admin of an organization

        return True, "Can be deleted"


def validate_user_activation(self, user: User) -> tuple[bool, str]:
    """Validate if user can be activated."""
    if user.is_active:
        return False, "User is already active"

    # Add more business rules as needed
    return True, "Can be activated"


def validate_user_deactivation(self, user: User) -> tuple[bool, str]:
    """Validate if user can be deactivated."""
    if not user.is_active:
        return False, "User is already inactive"

    # Add business rules (e.g., check if user is sole admin of organizations)
    return True, "Can be deactivated"
from typing import Optional

from ..entities.user import User
from ..entities.user_session import UserSession
from ..repositories.user_repository import UserRepository
from ..repositories.user_session_repository import UserSessionRepository
from ..value_objects.email import Email


class AuthenticationService:
    """Domain service for authentication logic."""

    def __init__(
        self, user_repository: UserRepository, session_repository: UserSessionRepository
    ):
        self._user_repository = user_repository
        self._session_repository = session_repository

    def authenticate(self, email: str, password: str) -> Optional[User]:
        """Authenticate user with email and password."""
        try:
            email_vo = Email(value=email)
            user = self._user_repository.get_by_email(email_vo)

            if not user:
                return None

            if not user.is_active:
                return None

            if not user.verify_password(password):
                return None

            return user

        except ValueError:
            # Invalid email format
            return None

    def create_session(
        self,
        user: User,
        token: str,
        duration_hours: int = 24,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None,
    ) -> UserSession:
        """Create a new user session."""
        session = UserSession.create(
            user_id=user.id,
            token=token,
            duration_hours=duration_hours,
            user_agent=user_agent,
            ip_address=ip_address,
        )

        return self._session_repository.save(session)

    def validate_session(self, token: str) -> Optional[User]:
        """Validate session token and return user if valid."""
        session = self._session_repository.get_by_token(token)

        if not session or not session.is_valid():
            return None

        user = self._user_repository.get_by_id(session.user_id)

        if not user or not user.is_active:
            return None

        return user

    def revoke_session(self, token: str) -> bool:
        """Revoke a specific session."""
        session = self._session_repository.get_by_token(token)

        if not session:
            return False

        revoked_session = session.revoke()
        self._session_repository.save(revoked_session)

        return True

    def revoke_all_user_sessions(self, user_id) -> int:
        """Revoke all sessions for a user."""
        return self._session_repository.revoke_all_user_sessions(user_id)
from .user_domain_service import UserDomainService
from .authentication_service import AuthenticationService

__all__ = ["UserDomainService", "AuthenticationService"]
import re
from pydantic import BaseModel, field_validator
from typing import Any


class Email(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if not cls._is_valid_email(v):
            raise ValueError(f"Invalid email format: {v}")
        return v.lower().strip()

    @staticmethod
    def _is_valid_email(email: str) -> bool:
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None

    def domain(self) -> str:
        return self.value.split('@')[1]

    def local_part(self) -> str:
        return self.value.split('@')[0]

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, Email):
            return self.value == other.value
        return False
from pydantic import BaseModel
from typing import Any
import bcrypt
import re


class Password(BaseModel, frozen=True):
    """Password value object with bcrypt encryption and validation rules."""
    
    hashed_value: str
    
    @classmethod
    def create(cls, plain_password: str) -> "Password":
        """Create a new password by hashing the plain text."""
        cls._validate_password_strength(plain_password)
        
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(plain_password.encode('utf-8'), salt)
        return cls(hashed_value=hashed.decode('utf-8'))
    
    @classmethod
    def from_hash(cls, hashed_password: str) -> "Password":
        """Create password object from existing hash."""
        return cls(hashed_value=hashed_password)
    
    @staticmethod
    def _validate_password_strength(password: str) -> None:
        """Validate password strength according to business rules."""
        if not password or len(password.strip()) == 0:
            raise ValueError("Password cannot be empty")
        
        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters long")
        
        if len(password) > 128:
            raise ValueError("Password cannot exceed 128 characters")
        
        if not re.search(r'[A-Z]', password):
            raise ValueError("Password must contain at least one uppercase letter")
        
        if not re.search(r'[a-z]', password):
            raise ValueError("Password must contain at least one lowercase letter")
        
        if not re.search(r'\d', password):
            raise ValueError("Password must contain at least one digit")
    
    def verify(self, plain_password: str) -> bool:
        """Verify a plain password against this hashed password."""
        return bcrypt.checkpw(
            plain_password.encode('utf-8'), 
            self.hashed_value.encode('utf-8')
        )
    
    def __str__(self) -> str:
        return "[PROTECTED]"
    
    def __repr__(self) -> str:
        return "Password([PROTECTED])"
    
    def __hash__(self) -> int:
        return hash(self.hashed_value)
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Password):
            return False
        return self.hashed_value == other.hashed_value
from .email import Email
from .password import Password

__all__ = ["Email", "Password"]
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.user_session import UserSession


class UserSessionRepository(ABC):
    """User session repository interface for the User bounded context."""

    @abstractmethod
    def save(self, session: UserSession) -> UserSession:
        """Save or update a user session."""
        pass

    @abstractmethod
    def get_by_id(self, session_id: UUID) -> Optional[UserSession]:
        """Get session by ID."""
        pass

    @abstractmethod
    def get_by_token(self, token: str) -> Optional[UserSession]:
        """Get session by token."""
        pass

    @abstractmethod
    def get_active_by_user_id(self, user_id: UUID) -> List[UserSession]:
        """Get all active sessions for a user."""
        pass

    @abstractmethod
    def revoke_all_user_sessions(self, user_id: UUID) -> int:
        """Revoke all sessions for a user. Returns count of revoked sessions."""
        pass

    @abstractmethod
    def cleanup_expired_sessions(self) -> int:
        """Cleanup expired sessions. Returns count of cleaned sessions."""
        pass

    @abstractmethod
    def delete(self, session_id: UUID) -> bool:
        """Delete session by ID."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.user import User
from ..value_objects.email import Email


class UserRepository(ABC):
    """User repository interface for the User bounded context."""

    @abstractmethod
    def save(self, user: User) -> User:
        """Save or update a user."""
        pass

    @abstractmethod
    def get_by_id(self, user_id: UUID) -> Optional[User]:
        """Get user by ID."""
        pass

    @abstractmethod
    def get_by_email(self, email: Email) -> Optional[User]:
        """Get user by email."""
        pass

    @abstractmethod
    def exists_by_email(self, email: Email) -> bool:
        """Check if user exists by email."""
        pass

    @abstractmethod
    def delete(self, user_id: UUID) -> bool:
        """Delete user by ID."""
        pass

    @abstractmethod
    def list_active_users(self, limit: int = 100, offset: int = 0) -> List[User]:
        """List active users with pagination."""
        pass

    @abstractmethod
    def count_active_users(self) -> int:
        """Count total active users."""
        pass
from .user_repository import UserRepository
from .user_session_repository import UserSessionRepository

__all__ = ["UserRepository", "UserSessionRepository"]
from .entities import User, UserSession
from .value_objects import Email, Password
from .repositories import UserRepository, UserSessionRepository
from .services import UserDomainService, AuthenticationService

__all__ = [
    "User", 
    "UserSession",
    "Email", 
    "Password",
    "UserRepository", 
    "UserSessionRepository",
    "UserDomainService",
    "AuthenticationService"
]
from typing import Optional
from pydantic import BaseModel, Field
from .user_dto import UserResponseDTO
from .session_dto import SessionResponseDTO


class LoginDTO(BaseModel):
    """DTO for user login."""
    email: str = Field(..., description="User email address")
    password: str = Field(..., description="User password")
    remember_me: bool = Field(False, description="Extended session duration")
    user_agent: Optional[str] = Field(None, max_length=500, description="User agent string")
    ip_address: Optional[str] = Field(None, max_length=45, description="IP address")


class AuthResponseDTO(BaseModel):
    """DTO for authentication response."""
    user: UserResponseDTO
    session: SessionResponseDTO
    access_token: str
    token_type: str = "bearer"
    expires_in: int  # seconds


class LogoutDTO(BaseModel):
    """DTO for user logout."""
    revoke_all_sessions: bool = Field(False, description="Revoke all user sessions")


class RefreshTokenDTO(BaseModel):
    """DTO for token refresh."""
    refresh_token: str = Field(..., description="Refresh token")


class PasswordResetRequestDTO(BaseModel):
    """DTO for password reset request."""
    email: str = Field(..., description="User email address")


class PasswordResetConfirmDTO(BaseModel):
    """DTO for password reset confirmation."""
    token: str = Field(..., description="Password reset token")
    new_password: str = Field(..., min_length=8, description="New password")
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field, field_validator


class UserCreateDTO(BaseModel):
    """DTO for creating a new user."""
    email: str = Field(..., description="User email address")
    name: str = Field(..., min_length=2, max_length=100, description="User full name")
    password: str = Field(..., min_length=8, description="User password")
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if '@' not in v or '.' not in v.split('@')[-1]:
            raise ValueError('Invalid email format')
        return v.lower().strip()
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip()


class UserUpdateDTO(BaseModel):
    """DTO for updating an existing user."""
    name: Optional[str] = Field(None, min_length=2, max_length=100, description="User full name")
    is_active: Optional[bool] = Field(None, description="User active status")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: Optional[str]) -> Optional[str]:
        if v is not None and not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip() if v else None


class UserChangePasswordDTO(BaseModel):
    """DTO for changing user password."""
    current_password: str = Field(..., description="Current password")
    new_password: str = Field(..., min_length=8, description="New password")


class UserResponseDTO(BaseModel):
    """DTO for user response data."""
    id: UUID
    email: str
    name: str
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    model_config = {"from_attributes": True}


class UserListResponseDTO(BaseModel):
    """DTO for paginated user list response."""
    users: list[UserResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int
from .user_dto import UserCreateDTO, UserUpdateDTO, UserResponseDTO
from .session_dto import SessionCreateDTO, SessionResponseDTO
from .auth_dto import LoginDTO, AuthResponseDTO

__all__ = [
    "UserCreateDTO", "UserUpdateDTO", "UserResponseDTO",
    "SessionCreateDTO", "SessionResponseDTO", 
    "LoginDTO", "AuthResponseDTO"
]
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field


class SessionCreateDTO(BaseModel):
    """DTO for creating a new user session."""
    user_id: UUID = Field(..., description="User ID")
    duration_hours: int = Field(24, ge=1, le=720, description="Session duration in hours")
    user_agent: Optional[str] = Field(None, max_length=500, description="User agent string")
    ip_address: Optional[str] = Field(None, max_length=45, description="IP address")


class SessionResponseDTO(BaseModel):
    """DTO for session response data."""
    id: UUID
    user_id: UUID
    token: str
    expires_at: datetime
    created_at: datetime
    is_active: bool
    user_agent: Optional[str] = None
    ip_address: Optional[str] = None
    is_expired: bool
    is_valid: bool
    
    model_config = {"from_attributes": True}


class SessionListResponseDTO(BaseModel):
    """DTO for user sessions list response."""
    sessions: list[SessionResponseDTO]
    total: int
    active_count: int
from .dtos import (
    UserCreateDTO, UserUpdateDTO, UserResponseDTO,
    SessionCreateDTO, SessionResponseDTO,
    LoginDTO, AuthResponseDTO
)
from .use_cases import UserUseCase, AuthUseCase, SessionUseCase

__all__ = [
    # DTOs
    "UserCreateDTO", "UserUpdateDTO", "UserResponseDTO",
    "SessionCreateDTO", "SessionResponseDTO", 
    "LoginDTO", "AuthResponseDTO",
    
    # Use Cases
    "UserUseCase", "AuthUseCase", "SessionUseCase"
]
from typing import Optional
from uuid import UUID, uuid4

from ..dtos.auth_dto import (
    LoginDTO, AuthResponseDTO, LogoutDTO, 
    PasswordResetRequestDTO, PasswordResetConfirmDTO
)
from ..dtos.user_dto import UserResponseDTO
from ..dtos.session_dto import SessionResponseDTO
from ...domain.entities.user import User
from ...domain.entities.user_session import UserSession
from ...domain.repositories.user_repository import UserRepository
from ...domain.repositories.user_session_repository import UserSessionRepository
from ...domain.services.authentication_service import AuthenticationService


class AuthUseCase:
    """Use cases for authentication and authorization."""
    
    def __init__(
        self,
        user_repository: UserRepository,
        session_repository: UserSessionRepository,
        auth_service: AuthenticationService
    ):
        self._user_repository = user_repository
        self._session_repository = session_repository
        self._auth_service = auth_service
    
     def login(self, dto: LoginDTO) -> AuthResponseDTO:
        """Authenticate user and create session."""
        
        # Authenticate user
        user =  self._auth_service.authenticate(dto.email, dto.password)
        
        if not user:
            raise ValueError("Invalid email or password")
        
        # Determine session duration
        duration_hours = 720 if dto.remember_me else 24  # 30 days vs 1 day
        
        # Generate session token
        session_token = self._generate_session_token()
        
        # Create session
        session =  self._auth_service.create_session(
            user=user,
            token=session_token,
            duration_hours=duration_hours,
            user_agent=dto.user_agent,
            ip_address=dto.ip_address
        )
        
        # Create response DTOs
        user_dto = UserResponseDTO.model_validate(user)
        session_dto = SessionResponseDTO.model_validate({
            **session.model_dump(),
            "is_expired": session.is_expired(),
            "is_valid": session.is_valid()
        })
        
        return AuthResponseDTO(
            user=user_dto,
            session=session_dto,
            access_token=session_token,
            expires_in=int(duration_hours * 3600)  # Convert to seconds
        )
    
     def logout(self, token: str, dto: LogoutDTO) -> bool:
        """Logout user by revoking session(s)."""
        
        # Get session to find user
        session =  self._session_repository.get_by_token(token)
        
        if not session:
            return False
        
        if dto.revoke_all_sessions:
            # Revoke all user sessions
             self._auth_service.revoke_all_user_sessions(session.user_id)
        else:
            # Revoke only current session
             self._auth_service.revoke_session(token)
        
        return True
    
     def validate_session(self, token: str) -> Optional[UserResponseDTO]:
        """Validate session token and return user."""
        
        user =  self._auth_service.validate_session(token)
        
        if not user:
            return None
        
        return UserResponseDTO.model_validate(user)
    
     def refresh_session(self, token: str) -> Optional[AuthResponseDTO]:
        """Refresh session if valid."""
        
        # Validate current session
        user =  self._auth_service.validate_session(token)
        
        if not user:
            return None
        
        # Get current session
        session =  self._session_repository.get_by_token(token)
        
        if not session or not session.is_valid():
            return None
        
        # Generate new token
        new_token = self._generate_session_token()
        
        # Create new session with same duration
        original_duration = int((session.expires_at - session.created_at).total_seconds() / 3600)
        
        new_session =  self._auth_service.create_session(
            user=user,
            token=new_token,
            duration_hours=original_duration,
            user_agent=session.user_agent,
            ip_address=session.ip_address
        )
        
        # Revoke old session
         self._auth_service.revoke_session(token)
        
        # Create response DTOs
        user_dto = UserResponseDTO.model_validate(user)
        session_dto = SessionResponseDTO.model_validate({
            **new_session.model_dump(),
            "is_expired": new_session.is_expired(),
            "is_valid": new_session.is_valid()
        })
        
        return AuthResponseDTO(
            user=user_dto,
            session=session_dto,
            access_token=new_token,
            expires_in=int(original_duration * 3600)
        )
    
     def request_password_reset(self, dto: PasswordResetRequestDTO) -> bool:
        """Request password reset for user."""
        from ...domain.value_objects.email import Email
        
        # Check if user exists
        email_vo = Email(value=dto.email)
        user =  self._user_repository.get_by_email(email_vo)
        
        if not user or not user.is_active:
            # Don't reveal if email exists or not
            return True
        
        # Generate reset token (in real implementation, this would be sent via email)
        reset_token = self._generate_reset_token()
        
        # Store reset token (this would typically be in a separate table/cache)
        # For now, just return success
        
        return True
    
     def confirm_password_reset(self, dto: PasswordResetConfirmDTO) -> bool:
        """Confirm password reset with token."""
        
        # In real implementation, validate reset token and get associated user
        # For now, this is a placeholder implementation
        
        # Validate token format
        if len(dto.token) < 32:
            raise ValueError("Invalid reset token")
        
        # Here you would:
        # 1. Validate token exists and is not expired
        # 2. Get associated user
        # 3. Update user password
        # 4. Revoke all user sessions
        # 5. Delete/mark token as used
        
        return True
    
     def change_password_with_current(
        self, 
        user_id: UUID, 
        current_password: str, 
        new_password: str
    ) -> bool:
        """Change password with current password verification."""
        
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        # Verify current password
        if not user.verify_password(current_password):
            raise ValueError("Current password is incorrect")
        
        # Update password
        updated_user = user.change_password(new_password)
         self._user_repository.save(updated_user)
        
        # Revoke all sessions to force re-login
         self._auth_service.revoke_all_user_sessions(user_id)
        
        return True
    
    def _generate_session_token(self) -> str:
        """Generate secure session token."""
        import secrets
        return secrets.token_urlsafe(32)
    
    def _generate_reset_token(self) -> str:
        """Generate secure password reset token."""
        import secrets
        return secrets.token_urlsafe(32)
from typing import Optional
from uuid import UUID
import math

from ..dtos.user_dto import (
    UserCreateDTO, UserUpdateDTO, UserChangePasswordDTO, 
    UserResponseDTO, UserListResponseDTO
)
from ...domain.entities.user import User
from ...domain.repositories.user_repository import UserRepository
from ...domain.services.user_domain_service import UserDomainService
from ...domain.value_objects.email import Email


class UserUseCase:
    """Use cases for user management."""
    
    def __init__(
        self, 
        user_repository: UserRepository,
        user_domain_service: UserDomainService
    ):
        self._user_repository = user_repository
        self._user_domain_service = user_domain_service
    
     def create_user(self, dto: UserCreateDTO) -> UserResponseDTO:
        """Create a new user."""
        
        # Check if email is available
        email_vo = Email(value=dto.email)
        is_available =  self._user_domain_service.is_email_available(email_vo)
        
        if not is_available:
            raise ValueError(f"Email {dto.email} is already in use")
        
        # Create user entity
        user = User.create(
            email=dto.email,
            name=dto.name,
            password=dto.password
        )
        
        # Save user
        saved_user =  self._user_repository.save(user)
        
        return UserResponseDTO.model_validate(saved_user)
    
     def get_user_by_id(self, user_id: UUID) -> Optional[UserResponseDTO]:
        """Get user by ID."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            return None
        
        return UserResponseDTO.model_validate(user)
    
     def get_user_by_email(self, email: str) -> Optional[UserResponseDTO]:
        """Get user by email."""
        email_vo = Email(value=email)
        user =  self._user_repository.get_by_email(email_vo)
        
        if not user:
            return None
        
        return UserResponseDTO.model_validate(user)
    
     def update_user(self, user_id: UUID, dto: UserUpdateDTO) -> UserResponseDTO:
        """Update user information."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        updated_user = user
        
        # Update name if provided
        if dto.name is not None:
            updated_user = updated_user.update_name(dto.name)
        
        # Update active status if provided
        if dto.is_active is not None:
            if dto.is_active and not user.is_active:
                can_activate, reason = self._user_domain_service.validate_user_activation(user)
                if not can_activate:
                    raise ValueError(f"Cannot activate user: {reason}")
                updated_user = updated_user.activate()
            elif not dto.is_active and user.is_active:
                can_deactivate, reason = self._user_domain_service.validate_user_deactivation(user)
                if not can_deactivate:
                    raise ValueError(f"Cannot deactivate user: {reason}")
                updated_user = updated_user.deactivate()
        
        # Save updated user
        saved_user =  self._user_repository.save(updated_user)
        
        return UserResponseDTO.model_validate(saved_user)
    
     def change_password(self, user_id: UUID, dto: UserChangePasswordDTO) -> bool:
        """Change user password."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        # Verify current password
        if not user.verify_password(dto.current_password):
            raise ValueError("Current password is incorrect")
        
        # Update password
        updated_user = user.change_password(dto.new_password)
         self._user_repository.save(updated_user)
        
        return True
    
     def deactivate_user(self, user_id: UUID) -> UserResponseDTO:
        """Deactivate user account."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        can_deactivate, reason = self._user_domain_service.validate_user_deactivation(user)
        if not can_deactivate:
            raise ValueError(f"Cannot deactivate user: {reason}")
        
        updated_user = user.deactivate()
        saved_user =  self._user_repository.save(updated_user)
        
        return UserResponseDTO.model_validate(saved_user)
    
     def activate_user(self, user_id: UUID) -> UserResponseDTO:
        """Activate user account."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        can_activate, reason = self._user_domain_service.validate_user_activation(user)
        if not can_activate:
            raise ValueError(f"Cannot activate user: {reason}")
        
        updated_user = user.activate()
        saved_user =  self._user_repository.save(updated_user)
        
        return UserResponseDTO.model_validate(saved_user)
    
     def delete_user(self, user_id: UUID) -> bool:
        """Delete user account."""
        can_delete, reason =  self._user_domain_service.can_user_be_deleted(user_id)
        
        if not can_delete:
            raise ValueError(f"Cannot delete user: {reason}")
        
        return  self._user_repository.delete(user_id)
    
     def list_users(
        self, 
        page: int = 1, 
        page_size: int = 100, 
        active_only: bool = True
    ) -> UserListResponseDTO:
        """List users with pagination."""
        
        if page < 1:
            page = 1
        
        if page_size < 1 or page_size > 1000:
            page_size = 100
        
        offset = (page - 1) * page_size
        
        # Get users
        users =  self._user_repository.list_active_users(
            limit=page_size, 
            offset=offset
        )
        
        # Get total count
        total =  self._user_repository.count_active_users()
        
        # Convert to DTOs
        user_dtos = [UserResponseDTO.model_validate(user) for user in users]
        
        total_pages = math.ceil(total / page_size)
        
        return UserListResponseDTO(
            users=user_dtos,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages
        )
    
     def check_email_availability(self, email: str, excluding_user_id: Optional[UUID] = None) -> bool:
        """Check if email is available for use."""
        email_vo = Email(value=email)
        return  self._user_domain_service.is_email_available(email_vo, excluding_user_id)
from typing import Optional
from uuid import UUID

from ..dtos.session_dto import (
    SessionCreateDTO,
    SessionResponseDTO,
    SessionListResponseDTO,
)
from ...domain.entities.user_session import UserSession
from ...domain.repositories.user_repository import UserRepository
from ...domain.repositories.user_session_repository import UserSessionRepository
from ...domain.services.authentication_service import AuthenticationService


class SessionUseCase:
    """Use cases for session management."""

    def __init__(
        self,
        user_repository: UserRepository,
        session_repository: UserSessionRepository,
        auth_service: AuthenticationService,
    ):
        self._user_repository = user_repository
        self._session_repository = session_repository
        self._auth_service = auth_service

     def create_session(self, dto: SessionCreateDTO) -> SessionResponseDTO:
        """Create a new user session."""

        # Verify user exists and is active
        user = self._user_repository.get_by_id(dto.user_id)

        if not user:
            raise ValueError("User not found")

        if not user.is_active:
            raise ValueError("User account is not active")

        # Generate session token
        session_token = self._generate_session_token()

        # Create session
        session = self._auth_service.create_session(
            user=user,
            token=session_token,
            duration_hours=dto.duration_hours,
            user_agent=dto.user_agent,
            ip_address=dto.ip_address,
        )

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

     def get_session_by_id(self, session_id: UUID) -> Optional[SessionResponseDTO]:
        """Get session by ID."""
        session = self._session_repository.get_by_id(session_id)

        if not session:
            return None

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

     def get_session_by_token(self, token: str) -> Optional[SessionResponseDTO]:
        """Get session by token."""
        session = self._session_repository.get_by_token(token)

        if not session:
            return None

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

     def get_user_sessions(self, user_id: UUID) -> SessionListResponseDTO:
        """Get all sessions for a user."""

        # Get active sessions
        sessions = self._session_repository.get_active_by_user_id(user_id)

        # Convert to DTOs
        session_dtos = []
        active_count = 0

        for session in sessions:
            session_dto = SessionResponseDTO.model_validate(
                {
                    **session.model_dump(),
                    "is_expired": session.is_expired(),
                    "is_valid": session.is_valid(),
                }
            )
            session_dtos.append(session_dto)

            if session_dto.is_valid:
                active_count += 1

        return SessionListResponseDTO(
            sessions=session_dtos, total=len(session_dtos), active_count=active_count
        )

     def revoke_session(self, session_id: UUID) -> bool:
        """Revoke a specific session."""
        session = self._session_repository.get_by_id(session_id)

        if not session:
            return False

        return self._auth_service.revoke_session(session.token)

     def revoke_session_by_token(self, token: str) -> bool:
        """Revoke session by token."""
        return self._auth_service.revoke_session(token)

     def revoke_all_user_sessions(self, user_id: UUID) -> int:
        """Revoke all sessions for a user."""
        return self._auth_service.revoke_all_user_sessions(user_id)

     def extend_session(
        self, session_id: UUID, hours: int = 24
    ) -> Optional[SessionResponseDTO]:
        """Extend session duration."""
        session = self._session_repository.get_by_id(session_id)

        if not session or not session.is_valid():
            return None

        # Extend session
        extended_session = session.extend(hours)
        saved_session = self._session_repository.save(extended_session)

        return SessionResponseDTO.model_validate(
            {
                **saved_session.model_dump(),
                "is_expired": saved_session.is_expired(),
                "is_valid": saved_session.is_valid(),
            }
        )

     def cleanup_expired_sessions(self) -> int:
        """Clean up expired sessions."""
        return self._session_repository.cleanup_expired_sessions()

     def validate_session_access(
        self, token: str, required_permissions: list[str] = None
    ) -> bool:
        """Validate session and optional permissions."""

        # Validate session
        user = self._auth_service.validate_session(token)

        if not user:
            return False

        # If no specific permissions required, just return session validity
        if not required_permissions:
            return True

        # Here you would integrate with authorization service to check permissions
        # For now, assume all authenticated users have basic permissions

        return True

    def _generate_session_token(self) -> str:
        """Generate secure session token."""
        import secrets

        return secrets.token_urlsafe(32)
from .user_use_cases import UserUseCase
from .auth_use_cases import AuthUseCase
from .session_use_cases import SessionUseCase

__all__ = ["UserUseCase", "AuthUseCase", "SessionUseCase"]
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete
from sqlalchemy.exc import IntegrityError

from ...domain.entities.user_session import UserSession
from ...domain.repositories.user_session_repository import UserSessionRepository
from ....infrastructure.database.models.user_models import (
    UserSessionModel,
    SessionStatusEnum,
)


class SqlAlchemyUserSessionRepository(UserSessionRepository):
    """SQLAlchemy implementation of UserSessionRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, session_entity: UserSession) -> UserSession:
        """Save a user session entity."""
        try:
            # Check if session exists
            existing = self.session.get(UserSessionModel, session_entity.id)

            if existing:
                # Update existing session
                existing.user_id = session_entity.user_id
                existing.session_token = session_entity.session_token
                existing.status = SessionStatusEnum(session_entity.status)
                existing.expires_at = session_entity.expires_at
                existing.ip_address = session_entity.ip_address
                existing.user_agent = session_entity.user_agent
                existing.last_activity_at = session_entity.last_activity_at
                existing.logout_at = session_entity.logout_at
                existing.metadata = session_entity.metadata
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new session
                session_model = UserSessionModel(
                    id=session_entity.id,
                    user_id=session_entity.user_id,
                    session_token=session_entity.session_token,
                    status=SessionStatusEnum(session_entity.status),
                    expires_at=session_entity.expires_at,
                    ip_address=session_entity.ip_address,
                    user_agent=session_entity.user_agent,
                    last_activity_at=session_entity.last_activity_at,
                    logout_at=session_entity.logout_at,
                    metadata=session_entity.metadata,
                    created_at=session_entity.created_at,
                    updated_at=session_entity.updated_at,
                )

                self.session.add(session_model)
                self.session.flush()
                return self._to_domain_entity(session_model)

        except IntegrityError as e:
            self.session.rollback()
            if "session_token" in str(e):
                raise ValueError("Session token must be unique")
            raise e

    def find_by_id(self, session_id: UUID) -> Optional[UserSession]:
        """Find a session by ID."""
        result = self.session.execute(
            select(UserSessionModel).where(UserSessionModel.id == session_id)
        )
        session_model = result.scalar_one_or_none()

        if session_model:
            return self._to_domain_entity(session_model)
        return None

    def find_by_token(self, session_token: str) -> Optional[UserSession]:
        """Find a session by token."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.session_token == session_token
            )
        )
        session_model = result.scalar_one_or_none()

        if session_model:
            return self._to_domain_entity(session_model)
        return None

    def find_active_by_user(self, user_id: UUID) -> List[UserSession]:
        """Find all active sessions for a user."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.user_id == user_id,
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
                UserSessionModel.expires_at > datetime.now(timezone.utc),
            )
        )
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def find_expired_sessions(self) -> List[UserSession]:
        """Find all expired sessions."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.expires_at <= datetime.now(timezone.utc),
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
            )
        )
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def find_user_sessions(
        self, user_id: UUID, status: Optional[str] = None, limit: int = 10
    ) -> List[UserSession]:
        """Find sessions for a user with optional status filter."""
        query = select(UserSessionModel).where(UserSessionModel.user_id == user_id)

        if status:
            query = query.where(UserSessionModel.status == SessionStatusEnum(status))

        query = query.order_by(UserSessionModel.last_activity_at.desc()).limit(limit)

        result = self.session.execute(query)
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def delete(self, session_id: UUID) -> bool:
        """Delete a session (hard delete)."""
        result = self.session.execute(
            delete(UserSessionModel).where(UserSessionModel.id == session_id)
        )
        return result.rowcount > 0

    def delete_user_sessions(self, user_id: UUID) -> int:
        """Delete all sessions for a user."""
        result = self.session.execute(
            delete(UserSessionModel).where(UserSessionModel.user_id == user_id)
        )
        return result.rowcount

    def revoke_session(self, session_id: UUID) -> bool:
        """Revoke a session by changing its status."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(UserSessionModel.id == session_id)
            .values(
                status=SessionStatusEnum.REVOKED,
                logout_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc),
            )
        )
        return result.rowcount > 0

    def revoke_user_sessions(
        self, user_id: UUID, exclude_session_id: Optional[UUID] = None
    ) -> int:
        """Revoke all sessions for a user, optionally excluding one session."""
        query = update(UserSessionModel).where(
            UserSessionModel.user_id == user_id,
            UserSessionModel.status == SessionStatusEnum.ACTIVE,
        )

        if exclude_session_id:
            query = query.where(UserSessionModel.id != exclude_session_id)

        query = query.values(
            status=SessionStatusEnum.REVOKED,
            logout_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc),
        )

        result = self.session.execute(query)
        return result.rowcount

    def update_activity(self, session_id: UUID, activity_time: datetime) -> bool:
        """Update session's last activity time."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(UserSessionModel.id == session_id)
            .values(
                last_activity_at=activity_time, updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0

    def cleanup_expired_sessions(self) -> int:
        """Clean up expired sessions by updating their status."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(
                UserSessionModel.expires_at <= datetime.now(timezone.utc),
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
            )
            .values(
                status=SessionStatusEnum.EXPIRED, updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount

    def _to_domain_entity(self, session_model: UserSessionModel) -> UserSession:
        """Convert SQLAlchemy model to domain entity."""
        return UserSession(
            id=session_model.id,
            user_id=session_model.user_id,
            session_token=session_model.session_token,
            status=session_model.status.value,
            expires_at=session_model.expires_at,
            ip_address=session_model.ip_address,
            user_agent=session_model.user_agent,
            last_activity_at=session_model.last_activity_at,
            logout_at=session_model.logout_at,
            metadata=session_model.metadata,
            created_at=session_model.created_at,
            updated_at=session_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete
from sqlalchemy.exc import IntegrityError

from ...domain.entities.user import User
from ...domain.repositories.user_repository import UserRepository
from ...domain.value_objects.email import Email
from ...domain.value_objects.password import Password
from ....infrastructure.database.models.user_models import UserModel


class SqlAlchemyUserRepository(UserRepository):
    """SQLAlchemy implementation of UserRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, user: User) -> User:
        """Save a user entity."""
        try:
            # Check if user exists
            existing = self.session.get(UserModel, user.id)

            if existing:
                # Update existing user
                existing.email = str(user.email.value)
                existing.name = user.name
                existing.password_hash = user.password.hash
                existing.is_active = user.is_active
                existing.is_verified = user.is_verified
                existing.last_login_at = user.last_login_at
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new user
                user_model = UserModel(
                    id=user.id,
                    email=str(user.email.value),
                    name=user.name,
                    password_hash=user.password.hash,
                    is_active=user.is_active,
                    is_verified=user.is_verified,
                    last_login_at=user.last_login_at,
                    created_at=user.created_at,
                    updated_at=user.updated_at,
                )

                self.session.add(user_model)
                self.session.flush()
                return self._to_domain_entity(user_model)

        except IntegrityError as e:
            self.session.rollback()
            if "email" in str(e):
                raise ValueError(f"User with email {user.email.value} already exists")
            raise e

    def find_by_id(self, user_id: UUID) -> Optional[User]:
        """Find a user by ID."""
        result = self.session.execute(select(UserModel).where(UserModel.id == user_id))
        user_model = result.scalar_one_or_none()

        if user_model:
            return self._to_domain_entity(user_model)
        return None

    def find_by_email(self, email: Email) -> Optional[User]:
        """Find a user by email."""
        result = self.session.execute(
            select(UserModel).where(UserModel.email == str(email.value))
        )
        user_model = result.scalar_one_or_none()

        if user_model:
            return self._to_domain_entity(user_model)
        return None

    def find_active_users(self) -> List[User]:
        """Find all active users."""
        result = self.session.execute(select(UserModel).where(UserModel.is_active))
        user_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in user_models]

    def find_paginated(
        self,
        offset: int = 0,
        limit: int = 20,
        email_filter: Optional[str] = None,
        name_filter: Optional[str] = None,
        is_active: Optional[bool] = None,
    ) -> tuple[List[User], int]:
        """Find users with pagination and filters."""
        query = select(UserModel)
        count_query = select(UserModel)

        # Apply filters
        if email_filter:
            query = query.where(UserModel.email.ilike(f"%{email_filter}%"))
            count_query = count_query.where(UserModel.email.ilike(f"%{email_filter}%"))

        if name_filter:
            query = query.where(UserModel.name.ilike(f"%{name_filter}%"))
            count_query = count_query.where(UserModel.name.ilike(f"%{name_filter}%"))

        if is_active is not None:
            query = query.where(UserModel.is_active == is_active)
            count_query = count_query.where(UserModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(UserModel.created_at.desc())
        result = self.session.execute(query)
        user_models = result.scalars().all()

        users = [self._to_domain_entity(model) for model in user_models]
        return users, total

    def delete(self, user_id: UUID) -> bool:
        """Delete a user (hard delete)."""
        result = self.session.execute(delete(UserModel).where(UserModel.id == user_id))
        return result.rowcount > 0

    def exists_by_email(self, email: Email) -> bool:
        """Check if a user with the given email exists."""
        result = self.session.execute(
            select(UserModel.id).where(UserModel.email == str(email.value))
        )
        return result.scalar_one_or_none() is not None

    def count_active_users(self) -> int:
        """Count active users."""
        result = self.session.execute(select(UserModel).where(UserModel.is_active))
        return len(result.scalars().all())

    def find_users_created_after(self, date: datetime) -> List[User]:
        """Find users created after a specific date."""
        result = self.session.execute(
            select(UserModel).where(UserModel.created_at >= date)
        )
        user_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in user_models]

    def update_last_login(self, user_id: UUID, login_time: datetime) -> bool:
        """Update user's last login time."""
        result = self.session.execute(
            update(UserModel)
            .where(UserModel.id == user_id)
            .values(last_login_at=login_time, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def _to_domain_entity(self, user_model: UserModel) -> User:
        """Convert SQLAlchemy model to domain entity."""
        return User(
            id=user_model.id,
            email=Email(user_model.email),
            name=user_model.name,
            password=Password.from_hash(user_model.password_hash),
            is_active=user_model.is_active,
            is_verified=user_model.is_verified,
            last_login_at=user_model.last_login_at,
            created_at=user_model.created_at,
            updated_at=user_model.updated_at,
        )
from .sqlalchemy_user_repository import SqlAlchemyUserRepository
from .sqlalchemy_user_session_repository import SqlAlchemyUserSessionRepository

__all__ = [
    "SqlAlchemyUserRepository",
    "SqlAlchemyUserSessionRepository"
]
from .repositories import SqlAlchemyUserRepository, SqlAlchemyUserSessionRepository

__all__ = [
    "SqlAlchemyUserRepository",
    "SqlAlchemyUserSessionRepository"
]
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List
from pydantic import BaseModel


class UserOrganizationRole(BaseModel):
    id: UUID
    user_id: UUID
    organization_id: UUID
    role_id: UUID
    assigned_at: datetime
    assigned_by: UUID
    revoked_at: Optional[datetime] = None
    revoked_by: Optional[UUID] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(cls, user_id: UUID, organization_id: UUID, role_id: UUID, assigned_by: UUID) -> "UserOrganizationRole":
        return cls(
            id=uuid4(),
            user_id=user_id,
            organization_id=organization_id,
            role_id=role_id,
            assigned_by=assigned_by,
            assigned_at=datetime.utcnow(),
            is_active=True
        )

    def revoke(self, revoked_by: UUID) -> "UserOrganizationRole":
        return self.model_copy(update={
            "revoked_at": datetime.utcnow(),
            "revoked_by": revoked_by,
            "is_active": False
        })

    def reactivate(self) -> "UserOrganizationRole":
        return self.model_copy(update={
            "revoked_at": None,
            "revoked_by": None,
            "is_active": True
        })
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel, Field

from domain.value_objects.email import Email
from domain.value_objects.password import Password


class User(BaseModel):
    id: UUID
    email: Email
    name: str
    password: Password
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"arbitrary_types_allowed": True}

    @classmethod
    def create(cls, email: str, name: str, password: str) -> "User":
        return cls(
            id=uuid4(),
            email=Email(value=email),
            name=name,
            password=Password.create(password),
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "User":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "User":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "User":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
    
    def change_password(self, new_password: str) -> "User":
        return self.model_copy(update={
            "password": Password.create(new_password),
            "updated_at": datetime.utcnow()
        })
    
    def verify_password(self, plain_password: str) -> bool:
        return self.password.verify(plain_password)
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel


class Organization(BaseModel):
    id: UUID
    name: str
    description: Optional[str] = None
    owner_id: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(cls, name: str, owner_id: UUID, description: Optional[str] = None) -> "Organization":
        return cls(
            id=uuid4(),
            name=name,
            description=description,
            owner_id=owner_id,
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "Organization":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def update_description(self, description: str) -> "Organization":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def transfer_ownership(self, new_owner_id: UUID) -> "Organization":
        return self.model_copy(update={
            "owner_id": new_owner_id,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Organization":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Organization":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class PermissionEffect(str, Enum):
    ALLOW = "allow"
    DENY = "deny"


class ContextCondition(BaseModel):
    """Defines conditions that must be met for the permission to apply"""
    attribute: str  # e.g., "user.department", "resource.project_code", "context.time"
    operator: str  # e.g., "equals", "in", "contains", "greater_than"
    value: Any  # e.g., "engineering", ["proj_a", "proj_b"], "2024-01-01"

    model_config = {"frozen": True}


class ResourcePermission(BaseModel):
    """Specific permission for a user/role on a resource with contextual conditions"""
    id: UUID
    user_id: Optional[UUID] = None  # Direct user permission
    role_id: Optional[UUID] = None  # Role-based permission
    resource_id: UUID
    permission_id: UUID  # Links to base Permission (read, write, delete, etc.)
    effect: PermissionEffect = PermissionEffect.ALLOW
    conditions: list[ContextCondition] = []  # ABAC conditions
    priority: int = 0  # Higher priority rules override lower ones
    assigned_at: datetime
    assigned_by: UUID
    revoked_at: Optional[datetime] = None
    revoked_by: Optional[UUID] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create_user_permission(
        cls,
        user_id: UUID,
        resource_id: UUID,
        permission_id: UUID,
        assigned_by: UUID,
        effect: PermissionEffect = PermissionEffect.ALLOW,
        conditions: Optional[list[ContextCondition]] = None,
        priority: int = 0,
    ) -> "ResourcePermission":
        return cls(
            id=uuid4(),
            user_id=user_id,
            resource_id=resource_id,
            permission_id=permission_id,
            effect=effect,
            conditions=conditions or [],
            priority=priority,
            assigned_at=datetime.utcnow(),
            assigned_by=assigned_by,
            is_active=True,
        )

    @classmethod
    def create_role_permission(
        cls,
        role_id: UUID,
        resource_id: UUID,
        permission_id: UUID,
        assigned_by: UUID,
        effect: PermissionEffect = PermissionEffect.ALLOW,
        conditions: Optional[list[ContextCondition]] = None,
        priority: int = 0,
    ) -> "ResourcePermission":
        return cls(
            id=uuid4(),
            role_id=role_id,
            resource_id=resource_id,
            permission_id=permission_id,
            effect=effect,
            conditions=conditions or [],
            priority=priority,
            assigned_at=datetime.utcnow(),
            assigned_by=assigned_by,
            is_active=True,
        )

    def revoke(self, revoked_by: UUID) -> "ResourcePermission":
        return self.model_copy(update={
            "revoked_at": datetime.utcnow(),
            "revoked_by": revoked_by,
            "is_active": False,
        })

    def update_conditions(self, conditions: list[ContextCondition]) -> "ResourcePermission":
        return self.model_copy(update={"conditions": conditions})

    def update_priority(self, priority: int) -> "ResourcePermission":
        return self.model_copy(update={"priority": priority})
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel


class Permission(BaseModel):
    id: UUID
    name: str
    description: Optional[str] = None
    resource: str
    action: str
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(cls, name: str, resource: str, action: str, description: Optional[str] = None) -> "Permission":
        return cls(
            id=uuid4(),
            name=name,
            resource=resource,
            action=action,
            description=description,
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "Permission":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def update_description(self, description: str) -> "Permission":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Permission":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Permission":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List
from pydantic import BaseModel


class Role(BaseModel):
    id: UUID
    name: str
    description: Optional[str] = None
    is_system: bool = False
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(cls, name: str, description: Optional[str] = None, is_system: bool = False) -> "Role":
        return cls(
            id=uuid4(),
            name=name,
            description=description,
            is_system=is_system,
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "Role":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def update_description(self, description: str) -> "Role":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Role":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Role":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class ResourceType(str, Enum):
    PROJECT = "project"
    DOCUMENT = "document"
    DATASET = "dataset"
    REPORT = "report"
    DASHBOARD = "dashboard"
    FOLDER = "folder"
    CUSTOM = "custom"


class Resource(BaseModel):
    id: UUID
    name: str
    resource_type: ResourceType
    description: Optional[str] = None
    parent_id: Optional[UUID] = None  # For hierarchical resources
    organization_id: Optional[UUID] = None  # Multi-tenant support
    metadata: Dict[str, Any] = {}  # Flexible attributes (project_code, department, etc.)
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        name: str,
        resource_type: ResourceType,
        description: Optional[str] = None,
        parent_id: Optional[UUID] = None,
        organization_id: Optional[UUID] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> "Resource":
        return cls(
            id=uuid4(),
            name=name,
            resource_type=resource_type,
            description=description,
            parent_id=parent_id,
            organization_id=organization_id,
            metadata=metadata or {},
            created_at=datetime.utcnow(),
            is_active=True,
        )

    def update_metadata(self, metadata: Dict[str, Any]) -> "Resource":
        return self.model_copy(update={
            "metadata": {**self.metadata, **metadata},
            "updated_at": datetime.utcnow()
        })

    def set_parent(self, parent_id: UUID) -> "Resource":
        return self.model_copy(update={
            "parent_id": parent_id,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Resource":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Resource":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
from datetime import datetime
from uuid import UUID
from typing import Optional, Dict, Any
from pydantic import BaseModel


class AuthorizationContext(BaseModel):
    """Context information used for ABAC authorization decisions"""
    user_id: UUID
    resource_id: Optional[UUID] = None
    organization_id: Optional[UUID] = None
    user_attributes: Dict[str, Any] = {}  # department, team, level, etc.
    resource_attributes: Dict[str, Any] = {}  # project_code, classification, owner, etc.
    environment_attributes: Dict[str, Any] = {}  # time, ip_address, location, etc.
    request_attributes: Dict[str, Any] = {}  # action, client_type, etc.

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        resource_id: Optional[UUID] = None,
        organization_id: Optional[UUID] = None,
        user_attributes: Optional[Dict[str, Any]] = None,
        resource_attributes: Optional[Dict[str, Any]] = None,
        environment_attributes: Optional[Dict[str, Any]] = None,
        request_attributes: Optional[Dict[str, Any]] = None,
    ) -> "AuthorizationContext":
        # Add default environment attributes
        env_attrs = environment_attributes or {}
        env_attrs.setdefault("timestamp", datetime.utcnow().isoformat())
        
        return cls(
            user_id=user_id,
            resource_id=resource_id,
            organization_id=organization_id,
            user_attributes=user_attributes or {},
            resource_attributes=resource_attributes or {},
            environment_attributes=env_attrs,
            request_attributes=request_attributes or {},
        )

    def get_attribute(self, attribute_path: str) -> Any:
        """Get attribute value using dot notation (e.g., 'user.department', 'resource.project_code')"""
        parts = attribute_path.split('.')
        if len(parts) != 2:
            return None
            
        category, key = parts
        if category == "user":
            return self.user_attributes.get(key)
        elif category == "resource":
            return self.resource_attributes.get(key)
        elif category == "environment":
            return self.environment_attributes.get(key)
        elif category == "request":
            return self.request_attributes.get(key)
        else:
            return None

    def with_user_attributes(self, **attributes) -> "AuthorizationContext":
        return self.model_copy(update={
            "user_attributes": {**self.user_attributes, **attributes}
        })

    def with_resource_attributes(self, **attributes) -> "AuthorizationContext":
        return self.model_copy(update={
            "resource_attributes": {**self.resource_attributes, **attributes}
        })

    def with_environment_attributes(self, **attributes) -> "AuthorizationContext":
        return self.model_copy(update={
            "environment_attributes": {**self.environment_attributes, **attributes}
        })

    def with_request_attributes(self, **attributes) -> "AuthorizationContext":
        return self.model_copy(update={
            "request_attributes": {**self.request_attributes, **attributes}
        })
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel
from enum import Enum


class SessionStatus(str, Enum):
    ACTIVE = "active"
    EXPIRED = "expired"
    LOGGED_OUT = "logged_out"
    REVOKED = "revoked"


class UserSession(BaseModel):
    id: UUID
    user_id: UUID
    session_token: str
    status: SessionStatus
    login_at: datetime
    logout_at: Optional[datetime] = None
    expires_at: datetime
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        session_token: str,
        expires_at: datetime,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> "UserSession":
        now = datetime.utcnow()
        return cls(
            id=uuid4(),
            user_id=user_id,
            session_token=session_token,
            status=SessionStatus.ACTIVE,
            login_at=now,
            expires_at=expires_at,
            ip_address=ip_address,
            user_agent=user_agent,
            created_at=now
        )

    def logout(self) -> "UserSession":
        """Mark session as logged out."""
        return self.model_copy(update={
            "status": SessionStatus.LOGGED_OUT,
            "logout_at": datetime.utcnow(),
            "updated_at": datetime.utcnow()
        })

    def expire(self) -> "UserSession":
        """Mark session as expired."""
        return self.model_copy(update={
            "status": SessionStatus.EXPIRED,
            "updated_at": datetime.utcnow()
        })

    def revoke(self) -> "UserSession":
        """Mark session as revoked (admin action)."""
        return self.model_copy(update={
            "status": SessionStatus.REVOKED,
            "logout_at": datetime.utcnow(),
            "updated_at": datetime.utcnow()
        })

    def is_active(self) -> bool:
        """Check if session is currently active."""
        if self.status != SessionStatus.ACTIVE:
            return False
        
        return datetime.utcnow() < self.expires_at

    def is_expired(self) -> bool:
        """Check if session has expired."""
        return datetime.utcnow() >= self.expires_at

    def get_session_duration(self) -> Optional[int]:
        """Get session duration in seconds. Returns None if still active."""
        if not self.logout_at:
            return None
        
        duration = self.logout_at - self.login_at
        return int(duration.total_seconds())

    def extend_session(self, new_expires_at: datetime) -> "UserSession":
        """Extend session expiration time."""
        if self.status != SessionStatus.ACTIVE:
            raise ValueError("Cannot extend inactive session")
        
        return self.model_copy(update={
            "expires_at": new_expires_at,
            "updated_at": datetime.utcnow()
        })
import re
from pydantic import BaseModel, field_validator
from typing import Any


class Email(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if not cls._is_valid_email(v):
            raise ValueError(f"Invalid email format: {v}")
        return v

    @staticmethod
    def _is_valid_email(email: str) -> bool:
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, Email):
            return self.value == other.value
        return False
from pydantic import BaseModel
from typing import Any
import bcrypt


class Password(BaseModel, frozen=True):
    """Password value object with bcrypt encryption."""
    
    hashed_value: str
    
    @classmethod
    def create(cls, plain_password: str) -> "Password":
        """Create a new password by hashing the plain text."""
        if not plain_password or len(plain_password.strip()) == 0:
            raise ValueError("Password cannot be empty")
        
        if len(plain_password) < 8:
            raise ValueError("Password must be at least 8 characters long")
        
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(plain_password.encode('utf-8'), salt)
        return cls(hashed_value=hashed.decode('utf-8'))
    
    @classmethod
    def from_hash(cls, hashed_password: str) -> "Password":
        """Create password object from existing hash."""
        return cls(hashed_value=hashed_password)
    
    def verify(self, plain_password: str) -> bool:
        """Verify a plain password against this hashed password."""
        return bcrypt.checkpw(
            plain_password.encode('utf-8'), 
            self.hashed_value.encode('utf-8')
        )
    
    def __str__(self) -> str:
        return "[PROTECTED]"
    
    def __repr__(self) -> str:
        return "Password([PROTECTED])"
    
    def __hash__(self) -> int:
        return hash(self.hashed_value)
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Password):
            return False
        return self.hashed_value == other.hashed_value
from abc import ABC, abstractmethod
from typing import Generic, TypeVar, List, Optional
from uuid import UUID

T = TypeVar('T')


class Repository(ABC, Generic[T]):
    @abstractmethod
     def create(self, entity: T) -> T:
        pass

    @abstractmethod
     def get_by_id(self, entity_id: UUID) -> Optional[T]:
        pass

    @abstractmethod
     def get_all(self) -> List[T]:
        pass

    @abstractmethod
     def update(self, entity: T) -> T:
        pass

    @abstractmethod
     def delete(self, entity_id: UUID) -> bool:
        pass
from abc import ABC, abstractmethod
from typing import ContextManager

from domain.repositories.user_repository import UserRepository
from domain.repositories.user_session_repository import UserSessionRepository
from domain.repositories.organization_repository import OrganizationRepository


class UnitOfWork(ABC):
    users: UserRepository
    user_sessions: UserSessionRepository
    organizations: OrganizationRepository

     def __aenter__(self) -> "UnitOfWork":
        return self

     def __aexit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            self.commit()
        else:
            self.rollback()

    @abstractmethod
     def commit(self) -> None:
        pass

    @abstractmethod
     def rollback(self) -> None:
        pass
from abc import abstractmethod
from typing import List, Optional
from uuid import UUID

from ..entities.resource_permission import ResourcePermission, PermissionEffect
from .base_repository import Repository


class ResourcePermissionRepository(Repository[ResourcePermission]):
    @abstractmethod
     def find_by_user_and_resource(self, user_id: UUID, resource_id: UUID) -> List[ResourcePermission]:
        pass

    @abstractmethod
     def find_by_role_and_resource(self, role_id: UUID, resource_id: UUID) -> List[ResourcePermission]:
        pass

    @abstractmethod
     def find_by_user(self, user_id: UUID) -> List[ResourcePermission]:
        pass

    @abstractmethod
     def find_by_resource(self, resource_id: UUID) -> List[ResourcePermission]:
        pass

    @abstractmethod
     def find_by_permission_and_resource(self, permission_id: UUID, resource_id: UUID) -> List[ResourcePermission]:
        pass

    @abstractmethod
     def find_effective_permissions(
        self,
        user_id: UUID,
        resource_id: UUID,
        permission_id: UUID,
        user_roles: List[UUID],
    ) -> List[ResourcePermission]:
        """Find all permissions (user + role-based) for a specific user, resource, and permission"""
        pass

    @abstractmethod
     def find_active_by_user_and_resource(self, user_id: UUID, resource_id: UUID) -> List[ResourcePermission]:
        pass

    @abstractmethod
     def find_by_effect(self, effect: PermissionEffect) -> List[ResourcePermission]:
        pass
from abc import abstractmethod
from typing import List, Optional
from uuid import UUID

from ..entities.resource import Resource, ResourceType
from .base_repository import Repository


class ResourceRepository(Repository[Resource]):
    @abstractmethod
     def find_by_name(self, name: str, organization_id: Optional[UUID] = None) -> Optional[Resource]:
        pass

    @abstractmethod
     def find_by_type(self, resource_type: ResourceType, organization_id: Optional[UUID] = None) -> List[Resource]:
        pass

    @abstractmethod
     def find_by_parent_id(self, parent_id: UUID) -> List[Resource]:
        pass

    @abstractmethod
     def find_by_organization(self, organization_id: UUID) -> List[Resource]:
        pass

    @abstractmethod
     def find_by_metadata_attribute(self, key: str, value: str, organization_id: Optional[UUID] = None) -> List[Resource]:
        pass

    @abstractmethod
     def find_hierarchical_children(self, parent_id: UUID, recursive: bool = False) -> List[Resource]:
        pass

    @abstractmethod
     def find_active_resources(self, organization_id: Optional[UUID] = None) -> List[Resource]:
        pass
from abc import ABC
from typing import List, Optional
from uuid import UUID
from domain.entities.user_session import UserSession
from domain.repositories.base_repository import Repository


class UserSessionRepository(Repository[UserSession], ABC):
    """Repository interface for UserSession aggregate."""
    
     def get_by_session_token(self, session_token: str) -> Optional[UserSession]:
        """Get session by session token."""
        pass
    
     def get_active_sessions_by_user_id(self, user_id: UUID) -> List[UserSession]:
        """Get all active sessions for a user."""
        pass
    
     def get_all_sessions_by_user_id(self, user_id: UUID) -> List[UserSession]:
        """Get all sessions (active and inactive) for a user."""
        pass
    
     def expire_sessions_by_user_id(self, user_id: UUID) -> int:
        """Expire all active sessions for a user. Returns count of expired sessions."""
        pass
    
     def cleanup_expired_sessions(self) -> int:
        """Remove expired sessions from storage. Returns count of cleaned sessions."""
        pass
from abc import abstractmethod
from typing import Optional, List
from uuid import UUID

from domain.repositories.base_repository import Repository
from domain.entities.organization import Organization


class OrganizationRepository(Repository[Organization]):
    @abstractmethod
     def get_by_name(self, name: str) -> Optional[Organization]:
        pass

    @abstractmethod
     def get_by_owner_id(self, owner_id: UUID) -> List[Organization]:
        pass

    @abstractmethod
     def get_organizations_by_user_id(self, user_id: UUID) -> List[Organization]:
        pass

    @abstractmethod
     def add_user_to_organization(self, organization_id: UUID, user_id: UUID) -> None:
        pass

    @abstractmethod
     def remove_user_from_organization(self, organization_id: UUID, user_id: UUID) -> None:
        pass

    @abstractmethod
     def is_user_in_organization(self, organization_id: UUID, user_id: UUID) -> bool:
        pass
from abc import abstractmethod
from typing import Optional

from domain.repositories.base_repository import Repository
from domain.entities.user import User


class UserRepository(Repository[User]):
    @abstractmethod
     def get_by_email(self, email: str) -> Optional[User]:
        pass
from typing import List
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status

from application.dtos.user_dto import CreateUserDto, UpdateUserDto, UserResponseDto
from application.services.user_service import UserService
from infrastructure.database.dependencies import get_unit_of_work
from infrastructure.repositories.sqlalchemy_unit_of_work import SQLAlchemyUnitOfWork

router = APIRouter(prefix="/users", tags=["users"])


def get_user_service(
    uow: SQLAlchemyUnitOfWork = Depends(get_unit_of_work),
) -> UserService:
    return UserService(uow)


@router.post("/", response_model=UserResponseDto, status_code=status.HTTP_201_CREATED)
@router.post(
    "", response_model=UserResponseDto, status_code=status.HTTP_201_CREATED
)  # Sem trailing slash
 def create_user(
    create_dto: CreateUserDto, user_service: UserService = Depends(get_user_service)
):
    try:
        return user_service.create_user(create_dto)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{user_id}", response_model=UserResponseDto)
 def get_user_by_id(
    user_id: UUID, user_service: UserService = Depends(get_user_service)
):
    user = user_service.get_user_by_id(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    return user


@router.get("/", response_model=List[UserResponseDto])
 def get_all_users(user_service: UserService = Depends(get_user_service)):
    return user_service.get_all_users()


@router.put("/{user_id}", response_model=UserResponseDto)
 def update_user(
    user_id: UUID,
    update_dto: UpdateUserDto,
    user_service: UserService = Depends(get_user_service),
):
    user = user_service.update_user(user_id, update_dto)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    return user


@router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
 def delete_user(
    user_id: UUID, user_service: UserService = Depends(get_user_service)
):
    success = user_service.delete_user(user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )


@router.patch("/{user_id}/deactivate", response_model=UserResponseDto)
 def deactivate_user(
    user_id: UUID, user_service: UserService = Depends(get_user_service)
):
    user = user_service.deactivate_user(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    return user


@router.patch("/{user_id}/activate", response_model=UserResponseDto)
 def activate_user(
    user_id: UUID, user_service: UserService = Depends(get_user_service)
):
    user = user_service.activate_user(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    return user
from fastapi import APIRouter, HTTPException, Depends, status, Request
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Optional

from application.use_cases.auth_use_cases import AuthUseCases
from application.use_cases.session_use_cases import SessionUseCases
from application.dtos.auth_dto import SignupDto, LoginDto, AuthResponseDto, UserInfoDto
from application.dtos.session_dto import (
    LogoutDto,
    LogoutResponseDto,
    UserSessionsResponseDto,
)
from application.services.jwt_service import JWTService
from domain.repositories.unit_of_work import UnitOfWork
from infrastructure.repositories.sqlalchemy_unit_of_work import SQLAlchemyUnitOfWork
from infrastructure.database.connection import get_db

router = APIRouter(prefix="/auth", tags=["Authentication"])
security = HTTPBearer()


def get_unit_of_work(db=Depends(get_db)) -> UnitOfWork:
    return SQLAlchemyUnitOfWork(db)


def get_jwt_service() -> JWTService:
    return JWTService()


def get_auth_use_cases(
    uow: UnitOfWork = Depends(get_unit_of_work),
    jwt_service: JWTService = Depends(get_jwt_service),
) -> AuthUseCases:
    return AuthUseCases(uow, jwt_service)


def get_session_use_cases(
    uow: UnitOfWork = Depends(get_unit_of_work),
    jwt_service: JWTService = Depends(get_jwt_service),
) -> SessionUseCases:
    return SessionUseCases(uow, jwt_service)


 def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    auth_use_cases: AuthUseCases = Depends(get_auth_use_cases),
) -> UserInfoDto:
    token = credentials.credentials
    user = auth_use_cases.get_current_user(token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user


@router.post(
    "/signup", response_model=AuthResponseDto, status_code=status.HTTP_201_CREATED
)
 def signup(
    signup_dto: SignupDto,
    request: Request,
    auth_use_cases: AuthUseCases = Depends(get_auth_use_cases),
):
    try:
        ip_address = request.client.host if request.client else None
        user_agent = request.headers.get("user-agent")

        return auth_use_cases.signup(signup_dto, ip_address, user_agent)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during signup",
        )


@router.post("/login", response_model=AuthResponseDto)
 def login(
    login_dto: LoginDto,
    request: Request,
    auth_use_cases: AuthUseCases = Depends(get_auth_use_cases),
):
    try:
        ip_address = request.client.host if request.client else None
        user_agent = request.headers.get("user-agent")

        auth_response = auth_use_cases.login(login_dto, ip_address, user_agent)
        if not auth_response:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid email or password",
            )
        return auth_response
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during login",
        )


@router.get("/me", response_model=UserInfoDto)
 def get_current_user_info(current_user: UserInfoDto = Depends(get_current_user)):
    return current_user


@router.post("/verify-token")
 def verify_token(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    auth_use_cases: AuthUseCases = Depends(get_auth_use_cases),
):
    token = credentials.credentials
    is_valid = auth_use_cases.verify_token(token)
    if not is_valid:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or expired token"
        )
    return {"valid": True}


@router.post("/logout", response_model=LogoutResponseDto)
 def logout(
    logout_dto: LogoutDto,
    credentials: HTTPAuthorizationCredentials = Depends(security),
    current_user: UserInfoDto = Depends(get_current_user),
    session_use_cases: SessionUseCases = Depends(get_session_use_cases),
):
    try:
        token = credentials.credentials

        if logout_dto.revoke_all_sessions:
            # Get current session ID from token to exclude it
            jwt_service = JWTService()
            token_payload = jwt_service.verify_token(token)
            current_session_id = token_payload.session_id if token_payload else None

            return session_use_cases.logout_all_sessions(
                user_id=current_user.id, except_session_id=current_session_id
            )
        else:
            return session_use_cases.logout_session(token)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during logout",
        )


@router.get("/sessions", response_model=UserSessionsResponseDto)
 def get_user_sessions(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    current_user: UserInfoDto = Depends(get_current_user),
    session_use_cases: SessionUseCases = Depends(get_session_use_cases),
):
    try:
        token = credentials.credentials
        return session_use_cases.get_user_sessions(
            user_id=current_user.id, current_session_token=token
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error while fetching sessions",
        )


@router.post("/logout-all", response_model=LogoutResponseDto)
 def logout_all_sessions(
    current_user: UserInfoDto = Depends(get_current_user),
    session_use_cases: SessionUseCases = Depends(get_session_use_cases),
):
    try:
        return session_use_cases.logout_all_sessions(current_user.id)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during logout",
        )
from typing import Optional
from application.use_cases.auth_use_cases import AuthUseCases
from application.dtos.auth_dto import SignupDto, LoginDto, AuthResponseDto, UserInfoDto


class AuthService:
    """Application service facade for authentication operations."""

    def __init__(self, auth_use_cases: AuthUseCases):
        self.auth_use_cases = auth_use_cases

     def signup(self, signup_dto: SignupDto) -> AuthResponseDto:
        return self.auth_use_cases.signup(signup_dto)

     def login(self, login_dto: LoginDto) -> Optional[AuthResponseDto]:
        return self.auth_use_cases.login(login_dto)

     def get_current_user(self, token: str) -> Optional[UserInfoDto]:
        return self.auth_use_cases.get_current_user(token)

    def verify_token(self, token: str) -> bool:
        return self.auth_use_cases.verify_token(token)
import os
from datetime import datetime, timedelta
from typing import Optional
from uuid import UUID
from jose import JWTError, jwt
from application.dtos.auth_dto import TokenPayloadDto


class JWTService:
    def __init__(self):
        self.secret_key = os.getenv("JWT_SECRET_KEY", "your-secret-key-change-in-production")
        self.algorithm = "HS256"
        self.access_token_expire_minutes = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "60"))
    
    def create_access_token(self, user_id: UUID, email: str, session_id: Optional[UUID] = None) -> tuple[str, datetime]:
        now = datetime.utcnow()
        expire = now + timedelta(minutes=self.access_token_expire_minutes)
        
        payload = {
            "user_id": str(user_id),
            "email": email,
            "exp": expire,
            "iat": now
        }
        
        if session_id:
            payload["session_id"] = str(session_id)
        
        token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        return token, expire
    
    def verify_token(self, token: str) -> Optional[TokenPayloadDto]:
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            
            user_id = UUID(payload.get("user_id"))
            email = payload.get("email")
            session_id = UUID(payload.get("session_id")) if payload.get("session_id") else None
            exp = datetime.fromtimestamp(payload.get("exp"))
            iat = datetime.fromtimestamp(payload.get("iat"))
            
            if not user_id or not email:
                return None
                
            return TokenPayloadDto(
                user_id=user_id,
                email=email,
                session_id=session_id,
                exp=exp,
                iat=iat
            )
        except (JWTError, ValueError, TypeError):
            return None
    
    def is_token_expired(self, token: str) -> bool:
        payload_data = self.verify_token(token)
        if not payload_data:
            return True
        
        return datetime.utcnow() > payload_data.exp
from typing import List, Dict, Any, Optional
from uuid import UUID
from datetime import datetime

from domain.entities.authorization_context import AuthorizationContext
from domain.entities.resource_permission import (
    ResourcePermission,
    PermissionEffect,
    ContextCondition,
)
from domain.entities.permission import Permission
from domain.entities.role import Role
from domain.repositories.unit_of_work import UnitOfWork
from domain.repositories.resource_permission_repository import (
    ResourcePermissionRepository,
)
from domain.repositories.resource_repository import ResourceRepository
from application.services.permission_service import PermissionService


class AuthorizationDecision:
    def __init__(self, allowed: bool, reason: str, applied_rules: List[str]):
        self.allowed = allowed
        self.reason = reason
        self.applied_rules = applied_rules


class ConditionEvaluator:
    """Evaluates ABAC conditions against authorization context"""

    @staticmethod
    def evaluate_condition(
        condition: ContextCondition, context: AuthorizationContext
    ) -> bool:
        """Evaluate a single condition against the context"""
        actual_value = context.get_attribute(condition.attribute)
        expected_value = condition.value

        if actual_value is None:
            return False

        operator = condition.operator.lower()

        if operator == "equals":
            return actual_value == expected_value
        elif operator == "not_equals":
            return actual_value != expected_value
        elif operator == "in":
            return (
                actual_value in expected_value
                if isinstance(expected_value, (list, tuple, set))
                else False
            )
        elif operator == "not_in":
            return (
                actual_value not in expected_value
                if isinstance(expected_value, (list, tuple, set))
                else True
            )
        elif operator == "contains":
            return expected_value in str(actual_value)
        elif operator == "not_contains":
            return expected_value not in str(actual_value)
        elif operator == "starts_with":
            return str(actual_value).startswith(str(expected_value))
        elif operator == "ends_with":
            return str(actual_value).endswith(str(expected_value))
        elif operator == "greater_than":
            try:
                return float(actual_value) > float(expected_value)
            except (ValueError, TypeError):
                return False
        elif operator == "less_than":
            try:
                return float(actual_value) < float(expected_value)
            except (ValueError, TypeError):
                return False
        elif operator == "greater_equal":
            try:
                return float(actual_value) >= float(expected_value)
            except (ValueError, TypeError):
                return False
        elif operator == "less_equal":
            try:
                return float(actual_value) <= float(expected_value)
            except (ValueError, TypeError):
                return False
        else:
            return False

    @classmethod
    def evaluate_conditions(
        cls, conditions: List[ContextCondition], context: AuthorizationContext
    ) -> bool:
        """Evaluate all conditions (AND logic)"""
        return all(
            cls.evaluate_condition(condition, context) for condition in conditions
        )


class HybridAuthorizationService:
    """
    Hybrid RBAC + ABAC authorization service

    Decision flow:
    1. Check role-based permissions (RBAC)
    2. Check resource-specific permissions (ABAC)
    3. Evaluate contextual conditions
    4. Apply priority and effect rules (ALLOW/DENY)
    """

    def __init__(self, uow: UnitOfWork, permission_service: PermissionService):
        self.uow = uow
        self.permission_service = permission_service
        self.condition_evaluator = ConditionEvaluator()

    def is_authorized(
        self,
        context: AuthorizationContext,
        permission_name: str,
        resource_id: Optional[UUID] = None,
    ) -> AuthorizationDecision:
        """
        Main authorization method that combines RBAC and ABAC

        Args:
            context: Authorization context with user, resource, and environment info
            permission_name: Name of the permission to check (e.g., "read", "write", "delete")
            resource_id: Optional specific resource ID to check

        Returns:
            AuthorizationDecision with result and reasoning
        """
        with self.uow:
            # Get the permission by name
            permission = self.uow.permissions.find_by_name(permission_name)
            if not permission:
                return AuthorizationDecision(
                    allowed=False,
                    reason=f"Permission '{permission_name}' not found",
                    applied_rules=[],
                )

            # Step 1: Check basic RBAC permissions (role-based)
            rbac_decision = self._check_rbac_permissions(context, permission)

            # Step 2: Check resource-specific permissions (ABAC)
            if resource_id:
                abac_decision = self._check_abac_permissions(
                    context, permission, resource_id
                )

                # Combine RBAC and ABAC decisions
                return self._combine_decisions(rbac_decision, abac_decision)
            else:
                # No specific resource, rely on RBAC only
                return rbac_decision

    def _check_rbac_permissions(
        self,
        context: AuthorizationContext,
        permission: Permission,
    ) -> AuthorizationDecision:
        """Check traditional role-based permissions"""
        # Get all user permissions (from roles, groups, and direct assignments)
        user_permissions = self.permission_service.get_all_user_permissions(
            context.user_id
        )

        # Check if user has the required permission
        has_permission = any(perm.name == permission.name for perm in user_permissions)

        if has_permission:
            return AuthorizationDecision(
                allowed=True,
                reason=f"User has role-based permission '{permission.name}'",
                applied_rules=["RBAC_ALLOW"],
            )
        else:
            return AuthorizationDecision(
                allowed=False,
                reason=f"User lacks role-based permission '{permission.name}'",
                applied_rules=["RBAC_DENY"],
            )

    def _check_abac_permissions(
        self,
        context: AuthorizationContext,
        permission: Permission,
        resource_id: UUID,
    ) -> AuthorizationDecision:
        """Check attribute-based permissions for specific resources"""
        # Get user roles for role-based resource permissions
        user_roles = self.permission_service.get_user_roles(context.user_id)
        user_role_ids = [role.id for role in self._get_role_entities(user_roles)]

        # Get all applicable resource permissions
        resource_permissions = self.uow.resource_permissions.find_effective_permissions(
            user_id=context.user_id,
            resource_id=resource_id,
            permission_id=permission.id,
            user_roles=user_role_ids,
        )

        if not resource_permissions:
            return AuthorizationDecision(
                allowed=False,
                reason=f"No resource-specific permissions found for resource {resource_id}",
                applied_rules=["ABAC_NO_RULES"],
            )

        # Evaluate each permission with its conditions
        applicable_permissions = []
        for res_perm in resource_permissions:
            if res_perm.conditions:
                # Evaluate ABAC conditions
                conditions_met = self.condition_evaluator.evaluate_conditions(
                    res_perm.conditions, context
                )
                if conditions_met:
                    applicable_permissions.append(res_perm)
            else:
                # No conditions, permission applies
                applicable_permissions.append(res_perm)

        if not applicable_permissions:
            return AuthorizationDecision(
                allowed=False,
                reason="Resource permissions exist but conditions not met",
                applied_rules=["ABAC_CONDITIONS_NOT_MET"],
            )

        # Sort by priority (higher first) and apply effect logic
        applicable_permissions.sort(key=lambda p: p.priority, reverse=True)

        # Apply the highest priority rule
        highest_priority = applicable_permissions[0]

        if highest_priority.effect == PermissionEffect.ALLOW:
            return AuthorizationDecision(
                allowed=True,
                reason=f"Resource permission allows access (priority: {highest_priority.priority})",
                applied_rules=[f"ABAC_ALLOW_P{highest_priority.priority}"],
            )
        else:
            return AuthorizationDecision(
                allowed=False,
                reason=f"Resource permission denies access (priority: {highest_priority.priority})",
                applied_rules=[f"ABAC_DENY_P{highest_priority.priority}"],
            )

    def _combine_decisions(
        self,
        rbac_decision: AuthorizationDecision,
        abac_decision: AuthorizationDecision,
    ) -> AuthorizationDecision:
        """
        Combine RBAC and ABAC decisions

        Logic:
        - If ABAC explicitly denies, deny (ABAC override)
        - If ABAC allows, allow regardless of RBAC (resource-specific override)
        - If ABAC has no rules, fall back to RBAC
        """
        combined_rules = rbac_decision.applied_rules + abac_decision.applied_rules

        # ABAC DENY has highest priority
        if abac_decision.applied_rules and any(
            "DENY" in rule for rule in abac_decision.applied_rules
        ):
            return AuthorizationDecision(
                allowed=False,
                reason=f"ABAC DENY overrides RBAC: {abac_decision.reason}",
                applied_rules=combined_rules,
            )

        # ABAC ALLOW overrides RBAC DENY
        if abac_decision.allowed:
            return AuthorizationDecision(
                allowed=True,
                reason=f"ABAC ALLOW: {abac_decision.reason}",
                applied_rules=combined_rules,
            )

        # No specific ABAC rules or conditions not met, fall back to RBAC
        if (
            "ABAC_NO_RULES" in abac_decision.applied_rules
            or "ABAC_CONDITIONS_NOT_MET" in abac_decision.applied_rules
        ):
            return AuthorizationDecision(
                allowed=rbac_decision.allowed,
                reason=f"RBAC fallback: {rbac_decision.reason}",
                applied_rules=combined_rules,
            )

        # Default to most restrictive
        return AuthorizationDecision(
            allowed=False,
            reason="Combined decision: access denied",
            applied_rules=combined_rules,
        )

    def _get_role_entities(self, role_names: List[str]) -> List[Role]:
        """Helper to get Role entities from role names"""
        roles = []
        for name in role_names:
            role = self.uow.roles.find_by_name(name)
            if role:
                roles.append(role)
        return roles

    def get_accessible_resources(
        self,
        context: AuthorizationContext,
        permission_name: str,
        resource_type: Optional[str] = None,
    ) -> List[UUID]:
        """Get list of resource IDs that user can access with given permission"""
        with self.uow:
            permission = self.uow.permissions.find_by_name(permission_name)
            if not permission:
                return []

            # Get all resources (optionally filtered by type)
            if resource_type:
                from domain.entities.resource import ResourceType

                resources = self.uow.resources.find_by_type(ResourceType(resource_type))
            else:
                resources = self.uow.resources.find_active_resources()

            accessible_resources = []
            for resource in resources:
                decision = self.is_authorized(
                    context.with_resource_attributes(**resource.metadata),
                    permission_name,
                    resource.id,
                )
                if decision.allowed:
                    accessible_resources.append(resource.id)

            return accessible_resources
from typing import List, Optional
from uuid import UUID

from domain.repositories.unit_of_work import UnitOfWork
from application.dtos.user_dto import CreateUserDto, UpdateUserDto, UserResponseDto
from application.use_cases.user_use_cases import UserUseCases


class UserService:
    def __init__(self, uow: UnitOfWork):
        self.user_use_cases = UserUseCases(uow)

    def create_user(self, create_dto: CreateUserDto) -> UserResponseDto:
        return self.user_use_cases.create_user(create_dto)

    def get_user_by_id(self, user_id: UUID) -> Optional[UserResponseDto]:
        return self.user_use_cases.get_user_by_id(user_id)

    def get_user_by_email(self, email: str) -> Optional[UserResponseDto]:
        return self.user_use_cases.get_user_by_email(email)

    def get_all_users(self) -> List[UserResponseDto]:
        return self.user_use_cases.get_all_users()

    def update_user(
        self, user_id: UUID, update_dto: UpdateUserDto
    ) -> Optional[UserResponseDto]:
        return self.user_use_cases.update_user(user_id, update_dto)

    def delete_user(self, user_id: UUID) -> bool:
        return self.user_use_cases.delete_user(user_id)

    def deactivate_user(self, user_id: UUID) -> Optional[UserResponseDto]:
        return self.user_use_cases.deactivate_user(user_id)

    def activate_user(self, user_id: UUID) -> Optional[UserResponseDto]:
        return self.user_use_cases.activate_user(user_id)
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, EmailStr, Field


class SignupDto(BaseModel):
    email: EmailStr
    name: str = Field(..., min_length=1, max_length=255)
    password: str = Field(..., min_length=8, max_length=255)


class LoginDto(BaseModel):
    email: EmailStr
    password: str = Field(..., min_length=1)


class AuthResponseDto(BaseModel):
    access_token: str
    token_type: str = "bearer"
    expires_in: int
    user: "UserInfoDto"


class UserInfoDto(BaseModel):
    id: UUID
    email: str
    name: str
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime]


class TokenPayloadDto(BaseModel):
    user_id: UUID
    email: str
    session_id: Optional[UUID] = None
    exp: datetime
    iat: datetime
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, EmailStr, Field


class CreateUserDto(BaseModel):
    email: EmailStr
    name: str = Field(..., min_length=1, max_length=255)
    password: str = Field(..., min_length=8, max_length=255)


class UpdateUserDto(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)


class ChangePasswordDto(BaseModel):
    old_password: str = Field(..., min_length=1)
    new_password: str = Field(..., min_length=8, max_length=255)


class UserResponseDto(BaseModel):
    id: UUID
    email: str
    name: str
    created_at: datetime
    updated_at: Optional[datetime]
    is_active: bool

    model_config = {"from_attributes": True}
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field


class CreateOrganizationDto(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = Field(None, max_length=1000)


class UpdateOrganizationDto(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    description: Optional[str] = Field(None, max_length=1000)


class TransferOwnershipDto(BaseModel):
    new_owner_id: UUID


class AddUserToOrganizationDto(BaseModel):
    user_id: UUID


class OrganizationResponseDto(BaseModel):
    id: UUID
    name: str
    description: Optional[str]
    owner_id: UUID
    created_at: datetime
    updated_at: Optional[datetime]
    is_active: bool

    model_config = {"from_attributes": True}


class OrganizationMembershipDto(BaseModel):
    organization: OrganizationResponseDto
    joined_at: datetime

    model_config = {"from_attributes": True}
from datetime import datetime
from typing import Optional, List
from uuid import UUID
from pydantic import BaseModel
from domain.entities.user_session import SessionStatus


class SessionInfoDto(BaseModel):
    id: UUID
    user_id: UUID
    status: SessionStatus
    login_at: datetime
    logout_at: Optional[datetime]
    expires_at: datetime
    ip_address: Optional[str]
    user_agent: Optional[str]
    is_current: bool = False
    session_duration: Optional[int] = None


class UserSessionsResponseDto(BaseModel):
    sessions: List[SessionInfoDto]
    total_sessions: int
    active_sessions: int


class LogoutDto(BaseModel):
    revoke_all_sessions: bool = False


class LogoutResponseDto(BaseModel):
    message: str
    revoked_sessions_count: int


class SessionStatsDto(BaseModel):
    total_sessions: int
    active_sessions: int
    expired_sessions: int
    logged_out_sessions: int
    revoked_sessions: int
# Legacy Application Layer - Deprecated
# 
# This legacy application layer is deprecated in favor of the new DDD bounded context 
# application layers. Please use the following bounded context application layers instead:
#
# - src/user/application/ - User management (authentication, sessions)
# - src/organization/application/ - Organization management (organizations, memberships)
# - src/authorization/application/ - Authorization (RBAC + ABAC, roles, permissions, policies)
# - src/plans/application/ - Plans management (plans, subscriptions, resources)
#
# This file provides backward compatibility imports but should be migrated to use
# the specific bounded context application layers directly.

from user.application import (
    UserCreateDTO, UserUpdateDTO, UserResponseDTO, UserListResponseDTO,
    AuthLoginDTO, AuthResponseDTO, SessionCreateDTO, SessionResponseDTO,
    UserUseCase, AuthUseCase, SessionUseCase
)

from organization.application import (
    OrganizationCreateDTO, OrganizationUpdateDTO, OrganizationResponseDTO,
    MembershipCreateDTO, MembershipUpdateDTO, MembershipResponseDTO,
    OrganizationUseCase, MembershipUseCase
)

from authorization.application import (
    RoleCreateDTO, RoleUpdateDTO, RoleResponseDTO,
    PermissionCreateDTO, PermissionResponseDTO,
    PolicyCreateDTO, PolicyUpdateDTO, PolicyResponseDTO,
    AuthorizationRequestDTO, AuthorizationResponseDTO,
    AuthorizationUseCase, RoleUseCase, PermissionUseCase, PolicyUseCase
)

from plans.application import (
    PlanCreateDTO, PlanUpdateDTO, PlanResponseDTO,
    SubscriptionCreateDTO, SubscriptionUpdateDTO, SubscriptionResponseDTO,
    PlanUseCase, SubscriptionUseCase, PlanResourceUseCase
)

# Legacy compatibility aliases
# TODO: Remove these once migration is complete
CreateUserDto = UserCreateDTO
UpdateUserDto = UserUpdateDTO
UserResponseDto = UserResponseDTO
UserUseCases = UserUseCase

__all__ = [
    # User context
    "UserCreateDTO", "UserUpdateDTO", "UserResponseDTO", "UserListResponseDTO",
    "AuthLoginDTO", "AuthResponseDTO", "SessionCreateDTO", "SessionResponseDTO",
    "UserUseCase", "AuthUseCase", "SessionUseCase",
    
    # Organization context
    "OrganizationCreateDTO", "OrganizationUpdateDTO", "OrganizationResponseDTO",
    "MembershipCreateDTO", "MembershipUpdateDTO", "MembershipResponseDTO",
    "OrganizationUseCase", "MembershipUseCase",
    
    # Authorization context
    "RoleCreateDTO", "RoleUpdateDTO", "RoleResponseDTO",
    "PermissionCreateDTO", "PermissionResponseDTO",
    "PolicyCreateDTO", "PolicyUpdateDTO", "PolicyResponseDTO",
    "AuthorizationRequestDTO", "AuthorizationResponseDTO",
    "AuthorizationUseCase", "RoleUseCase", "PermissionUseCase", "PolicyUseCase",
    
    # Plans context
    "PlanCreateDTO", "PlanUpdateDTO", "PlanResponseDTO",
    "SubscriptionCreateDTO", "SubscriptionUpdateDTO", "SubscriptionResponseDTO",
    "PlanUseCase", "SubscriptionUseCase", "PlanResourceUseCase",
    
    # Legacy aliases (deprecated)
    "CreateUserDto", "UpdateUserDto", "UserResponseDto", "UserUseCases"
]
from typing import Optional
from domain.repositories.unit_of_work import UnitOfWork
from domain.entities.user import User
from application.dtos.auth_dto import SignupDto, LoginDto, AuthResponseDto, UserInfoDto
from application.services.jwt_service import JWTService
from application.use_cases.session_use_cases import SessionUseCases


class AuthUseCases:
    def __init__(self, uow: UnitOfWork, jwt_service: JWTService):
        self.uow = uow
        self.jwt_service = jwt_service
        self.session_use_cases = SessionUseCases(uow, jwt_service)

    def _to_user_info_dto(self, user: User) -> UserInfoDto:
        return UserInfoDto(
            id=user.id,
            email=str(user.email.value),
            name=user.name,
            is_active=user.is_active,
            created_at=user.created_at,
            updated_at=user.updated_at,
        )

    def signup(
        self,
        signup_dto: SignupDto,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> AuthResponseDto:
        with self.uow:
            existing_user = self.uow.users.get_by_email(signup_dto.email)
            if existing_user:
                raise ValueError(f"User with email {signup_dto.email} already exists")

            user = User.create(
                email=signup_dto.email,
                name=signup_dto.name,
                password=signup_dto.password,
            )

            created_user = self.uow.users.create(user)

            # Create session for the new user
            session, access_token = self.session_use_cases.create_session(
                user_id=created_user.id, ip_address=ip_address, user_agent=user_agent
            )

            return AuthResponseDto(
                access_token=access_token,
                token_type="bearer",
                expires_in=self.jwt_service.access_token_expire_minutes * 60,
                user=self._to_user_info_dto(created_user),
            )

    def login(
        self,
        login_dto: LoginDto,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> Optional[AuthResponseDto]:
        with self.uow:
            user = self.uow.users.get_by_email(login_dto.email)
            if not user:
                return None

            if not user.is_active:
                raise ValueError("User account is deactivated")

            if not user.verify_password(login_dto.password):
                return None

            # Create session for the login
            session, access_token = self.session_use_cases.create_session(
                user_id=user.id, ip_address=ip_address, user_agent=user_agent
            )

            return AuthResponseDto(
                access_token=access_token,
                token_type="bearer",
                expires_in=self.jwt_service.access_token_expire_minutes * 60,
                user=self._to_user_info_dto(user),
            )

    def get_current_user(self, token: str) -> Optional[UserInfoDto]:
        # Validate session first
        session = self.session_use_cases.validate_session(token)
        if not session:
            return None

        token_payload = self.jwt_service.verify_token(token)
        if not token_payload:
            return None

        with self.uow:
            user = self.uow.users.get_by_id(token_payload.user_id)
            if not user or not user.is_active:
                return None

            return self._to_user_info_dto(user)

    def verify_token(self, token: str) -> bool:
        session = self.session_use_cases.validate_session(token)
        return session is not None

    def logout(self, token: str) -> bool:
        """Logout current session."""
        try:
            self.session_use_cases.logout_session(token)
            return True
        except ValueError:
            return False
from typing import List, Optional
from uuid import UUID

from domain.entities.user import User
from domain.repositories.unit_of_work import UnitOfWork
from application.dtos.user_dto import (
    CreateUserDto,
    UpdateUserDto,
    UserResponseDto,
    ChangePasswordDto,
)


class UserUseCases:
    def __init__(self, uow: UnitOfWork):
        self.uow = uow

    def _to_response_dto(self, user: User) -> UserResponseDto:
        return UserResponseDto(
            id=user.id,
            email=str(user.email.value),
            name=user.name,
            created_at=user.created_at,
            updated_at=user.updated_at,
            is_active=user.is_active,
        )

    def create_user(self, create_dto: CreateUserDto) -> UserResponseDto:
        with self.uow:
            existing_user = self.uow.users.get_by_email(create_dto.email)
            if existing_user:
                raise ValueError(f"User with email {create_dto.email} already exists")

            user = User.create(
                email=create_dto.email,
                name=create_dto.name,
                password=create_dto.password,
            )
            created_user = self.uow.users.create(user)
            return self._to_response_dto(created_user)

    def get_user_by_id(self, user_id: UUID) -> Optional[UserResponseDto]:
        with self.uow:
            user = self.uow.users.get_by_id(user_id)
            return self._to_response_dto(user) if user else None

    def get_user_by_email(self, email: str) -> Optional[UserResponseDto]:
        with self.uow:
            user = self.uow.users.get_by_email(email)
            return self._to_response_dto(user) if user else None

    def get_all_users(self) -> List[UserResponseDto]:
        with self.uow:
            users = self.uow.users.get_all()
            return [self._to_response_dto(user) for user in users]

    def update_user(
        self, user_id: UUID, update_dto: UpdateUserDto
    ) -> Optional[UserResponseDto]:
        with self.uow:
            user = self.uow.users.get_by_id(user_id)
            if not user:
                return None

            updated_user = user
            if update_dto.name:
                updated_user = user.update_name(update_dto.name)

            final_user = self.uow.users.update(updated_user)
            return self._to_response_dto(final_user)

    def delete_user(self, user_id: UUID) -> bool:
        with self.uow:
            return self.uow.users.delete(user_id)

    def deactivate_user(self, user_id: UUID) -> Optional[UserResponseDto]:
        with self.uow:
            user = self.uow.users.get_by_id(user_id)
            if not user:
                return None

            deactivated_user = user.deactivate()
            updated_user = self.uow.users.update(deactivated_user)
            return self._to_response_dto(updated_user)

    def activate_user(self, user_id: UUID) -> Optional[UserResponseDto]:
        with self.uow:
            user = self.uow.users.get_by_id(user_id)
            if not user:
                return None

            activated_user = user.activate()
            updated_user = self.uow.users.update(activated_user)
            return self._to_response_dto(updated_user)

    def change_password(
        self, user_id: UUID, change_password_dto: ChangePasswordDto
    ) -> Optional[UserResponseDto]:
        with self.uow:
            user = self.uow.users.get_by_id(user_id)
            if not user:
                return None

            if not user.verify_password(change_password_dto.old_password):
                raise ValueError("Invalid old password")

            updated_user = user.change_password(change_password_dto.new_password)
            final_user = self.uow.users.update(updated_user)
            return self._to_response_dto(final_user)

    def verify_user_password(
        self, email: str, password: str
    ) -> Optional[UserResponseDto]:
        with self.uow:
            user = self.uow.users.get_by_email(email)
            if not user:
                return None

            if not user.verify_password(password):
                return None

            return self._to_response_dto(user)
from typing import List, Optional
from uuid import UUID

from domain.entities.organization import Organization
from domain.repositories.unit_of_work import UnitOfWork
from application.dtos.organization_dto import (
    CreateOrganizationDto,
    UpdateOrganizationDto,
    TransferOwnershipDto,
    AddUserToOrganizationDto,
    OrganizationResponseDto,
)


class OrganizationUseCases:
    def __init__(self, uow: UnitOfWork):
        self.uow = uow

    def _to_response_dto(self, organization: Organization) -> OrganizationResponseDto:
        return OrganizationResponseDto(
            id=organization.id,
            name=organization.name,
            description=organization.description,
            owner_id=organization.owner_id,
            created_at=organization.created_at,
            updated_at=organization.updated_at,
            is_active=organization.is_active,
        )

    def create_organization(
        self, owner_id: UUID, create_dto: CreateOrganizationDto
    ) -> OrganizationResponseDto:
        with self.uow:
            existing_org = self.uow.organizations.get_by_name(create_dto.name)
            if existing_org:
                raise ValueError(
                    f"Organization with name {create_dto.name} already exists"
                )

            user = self.uow.users.get_by_id(owner_id)
            if not user:
                raise ValueError(f"User with id {owner_id} does not exist")

            organization = Organization.create(
                name=create_dto.name,
                owner_id=owner_id,
                description=create_dto.description,
            )
            created_org = self.uow.organizations.create(organization)

            self.uow.organizations.add_user_to_organization(created_org.id, owner_id)

            return self._to_response_dto(created_org)

    def get_organization_by_id(
        self, organization_id: UUID
    ) -> Optional[OrganizationResponseDto]:
        with self.uow:
            organization = self.uow.organizations.get_by_id(organization_id)
            return self._to_response_dto(organization) if organization else None

    def get_organization_by_name(self, name: str) -> Optional[OrganizationResponseDto]:
        with self.uow:
            organization = self.uow.organizations.get_by_name(name)
            return self._to_response_dto(organization) if organization else None

    def get_organizations_by_owner(
        self, owner_id: UUID
    ) -> List[OrganizationResponseDto]:
        with self.uow:
            organizations = self.uow.organizations.get_by_owner_id(owner_id)
            return [self._to_response_dto(org) for org in organizations]

    def get_user_organizations(self, user_id: UUID) -> List[OrganizationResponseDto]:
        with self.uow:
            organizations = self.uow.organizations.get_organizations_by_user_id(user_id)
            return [self._to_response_dto(org) for org in organizations]

    def update_organization(
        self,
        organization_id: UUID,
        update_dto: UpdateOrganizationDto,
        requester_id: UUID,
    ) -> Optional[OrganizationResponseDto]:
        with self.uow:
            organization = self.uow.organizations.get_by_id(organization_id)
            if not organization:
                return None

            if organization.owner_id != requester_id:
                raise PermissionError(
                    "Only the organization owner can update the organization"
                )

            updated_org = organization
            if update_dto.name:
                existing_org = self.uow.organizations.get_by_name(update_dto.name)
                if existing_org and existing_org.id != organization_id:
                    raise ValueError(
                        f"Organization with name {update_dto.name} already exists"
                    )
                updated_org = updated_org.update_name(update_dto.name)

            if update_dto.description is not None:
                updated_org = updated_org.update_description(update_dto.description)

            final_org = self.uow.organizations.update(updated_org)
            return self._to_response_dto(final_org)

    def transfer_ownership(
        self,
        organization_id: UUID,
        transfer_dto: TransferOwnershipDto,
        current_owner_id: UUID,
    ) -> Optional[OrganizationResponseDto]:
        with self.uow:
            organization = self.uow.organizations.get_by_id(organization_id)
            if not organization:
                return None

            if organization.owner_id != current_owner_id:
                raise PermissionError("Only the current owner can transfer ownership")

            new_owner = self.uow.users.get_by_id(transfer_dto.new_owner_id)
            if not new_owner:
                raise ValueError(
                    f"User with id {transfer_dto.new_owner_id} does not exist"
                )

            is_member = self.uow.organizations.is_user_in_organization(
                organization_id, transfer_dto.new_owner_id
            )
            if not is_member:
                self.uow.organizations.add_user_to_organization(
                    organization_id, transfer_dto.new_owner_id
                )

            transferred_org = organization.transfer_ownership(transfer_dto.new_owner_id)
            final_org = self.uow.organizations.update(transferred_org)
            return self._to_response_dto(final_org)

    def add_user_to_organization(
        self,
        organization_id: UUID,
        add_user_dto: AddUserToOrganizationDto,
        requester_id: UUID,
    ) -> bool:
        with self.uow:
            organization = self.uow.organizations.get_by_id(organization_id)
            if not organization:
                raise ValueError(
                    f"Organization with id {organization_id} does not exist"
                )

            if organization.owner_id != requester_id:
                raise PermissionError("Only the organization owner can add users")

            user = self.uow.users.get_by_id(add_user_dto.user_id)
            if not user:
                raise ValueError(f"User with id {add_user_dto.user_id} does not exist")

            is_already_member = self.uow.organizations.is_user_in_organization(
                organization_id, add_user_dto.user_id
            )
            if is_already_member:
                raise ValueError("User is already a member of this organization")

            self.uow.organizations.add_user_to_organization(
                organization_id, add_user_dto.user_id
            )
            return True

    def remove_user_from_organization(
        self, organization_id: UUID, user_id: UUID, requester_id: UUID
    ) -> bool:
        with self.uow:
            organization = self.uow.organizations.get_by_id(organization_id)
            if not organization:
                raise ValueError(
                    f"Organization with id {organization_id} does not exist"
                )

            if organization.owner_id != requester_id and requester_id != user_id:
                raise PermissionError(
                    "Only the organization owner or the user themselves can remove membership"
                )

            if organization.owner_id == user_id:
                raise ValueError(
                    "The organization owner cannot be removed from the organization"
                )

            is_member = self.uow.organizations.is_user_in_organization(
                organization_id, user_id
            )
            if not is_member:
                raise ValueError("User is not a member of this organization")

            self.uow.organizations.remove_user_from_organization(
                organization_id, user_id
            )
            return True

    def deactivate_organization(
        self, organization_id: UUID, requester_id: UUID
    ) -> Optional[OrganizationResponseDto]:
        with self.uow:
            organization = self.uow.organizations.get_by_id(organization_id)
            if not organization:
                return None

            if organization.owner_id != requester_id:
                raise PermissionError(
                    "Only the organization owner can deactivate the organization"
                )

            deactivated_org = organization.deactivate()
            updated_org = self.uow.organizations.update(deactivated_org)
            return self._to_response_dto(updated_org)

    def activate_organization(
        self, organization_id: UUID, requester_id: UUID
    ) -> Optional[OrganizationResponseDto]:
        with self.uow:
            organization = self.uow.organizations.get_by_id(organization_id)
            if not organization:
                return None

            if organization.owner_id != requester_id:
                raise PermissionError(
                    "Only the organization owner can activate the organization"
                )

            activated_org = organization.activate()
            updated_org = self.uow.organizations.update(activated_org)
            return self._to_response_dto(updated_org)
from typing import Optional
from uuid import UUID
from datetime import datetime, timedelta

from domain.repositories.unit_of_work import UnitOfWork
from domain.entities.user_session import UserSession
from application.dtos.session_dto import (
    SessionInfoDto,
    UserSessionsResponseDto,
    LogoutResponseDto,
    SessionStatsDto,
)
from application.services.jwt_service import JWTService


class SessionUseCases:
    def __init__(self, uow: UnitOfWork, jwt_service: JWTService):
        self.uow = uow
        self.jwt_service = jwt_service

    def _to_session_info_dto(
        self, session: UserSession, current_session_id: Optional[UUID] = None
    ) -> SessionInfoDto:
        return SessionInfoDto(
            id=session.id,
            user_id=session.user_id,
            status=session.status,
            login_at=session.login_at,
            logout_at=session.logout_at,
            expires_at=session.expires_at,
            ip_address=session.ip_address,
            user_agent=session.user_agent,
            is_current=session.id == current_session_id,
            session_duration=session.get_session_duration(),
        )

    def create_session(
        self,
        user_id: UUID,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> tuple[UserSession, str]:
        """Create a new user session and return session with JWT token."""
        with self.uow:
            # Calculate expiration time
            expires_at = datetime.utcnow() + timedelta(
                minutes=self.jwt_service.access_token_expire_minutes
            )

            # Create session without token first
            session = UserSession.create(
                user_id=user_id,
                session_token="",  # Will be updated with actual JWT
                expires_at=expires_at,
                ip_address=ip_address,
                user_agent=user_agent,
            )

            # Create the session in database to get the ID
            created_session = self.uow.user_sessions.create(session)

            # Get user for JWT creation
            user = self.uow.users.get_by_id(user_id)
            if not user:
                raise ValueError("User not found")

            # Create JWT token with session ID
            access_token, _ = self.jwt_service.create_access_token(
                user_id=user.id,
                email=str(user.email.value),
                session_id=created_session.id,
            )

            # Update session with the actual JWT token
            updated_session = created_session.model_copy(
                update={"session_token": access_token, "updated_at": datetime.utcnow()}
            )

            final_session = self.uow.user_sessions.update(updated_session)
            return final_session, access_token

    def logout_session(self, session_token: str) -> LogoutResponseDto:
        """Logout a specific session."""
        with self.uow:
            session = self.uow.user_sessions.get_by_session_token(session_token)
            if not session:
                raise ValueError("Session not found")

            if not session.is_active():
                raise ValueError("Session is not active")

            logged_out_session = session.logout()
            self.uow.user_sessions.update(logged_out_session)

            return LogoutResponseDto(
                message="Session logged out successfully", revoked_sessions_count=1
            )

    def logout_all_sessions(
        self, user_id: UUID, except_session_id: Optional[UUID] = None
    ) -> LogoutResponseDto:
        """Logout all sessions for a user, optionally excluding current session."""
        with self.uow:
            if except_session_id:
                # Get all active sessions except the current one
                all_sessions = self.uow.user_sessions.get_active_sessions_by_user_id(
                    user_id
                )
                sessions_to_logout = [
                    s for s in all_sessions if s.id != except_session_id
                ]

                count = 0
                for session in sessions_to_logout:
                    logged_out_session = session.logout()
                    self.uow.user_sessions.update(logged_out_session)
                    count += 1

                return LogoutResponseDto(
                    message=f"Logged out {count} other sessions",
                    revoked_sessions_count=count,
                )
            else:
                # Logout all sessions using repository method
                count = self.uow.user_sessions.expire_sessions_by_user_id(user_id)
                return LogoutResponseDto(
                    message=f"Logged out all {count} sessions",
                    revoked_sessions_count=count,
                )

    def get_user_sessions(
        self, user_id: UUID, current_session_token: Optional[str] = None
    ) -> UserSessionsResponseDto:
        """Get all sessions for a user."""
        with self.uow:
            sessions = self.uow.user_sessions.get_all_sessions_by_user_id(user_id)

            # Determine current session ID from token
            current_session_id = None
            if current_session_token:
                token_payload = self.jwt_service.verify_token(current_session_token)
                if token_payload and token_payload.session_id:
                    current_session_id = token_payload.session_id

            session_dtos = [
                self._to_session_info_dto(session, current_session_id)
                for session in sessions
            ]

            active_count = sum(1 for session in sessions if session.is_active())

            return UserSessionsResponseDto(
                sessions=session_dtos,
                total_sessions=len(sessions),
                active_sessions=active_count,
            )

    def revoke_session(
        self, session_id: UUID, admin_user_id: UUID
    ) -> LogoutResponseDto:
        """Revoke a session (admin action)."""
        with self.uow:
            session = self.uow.user_sessions.get_by_id(session_id)
            if not session:
                raise ValueError("Session not found")

            revoked_session = session.revoke()
            self.uow.user_sessions.update(revoked_session)

            return LogoutResponseDto(
                message="Session revoked by admin", revoked_sessions_count=1
            )

    def cleanup_expired_sessions(self) -> int:
        """Clean up expired sessions."""
        with self.uow:
            return self.uow.user_sessions.cleanup_expired_sessions()

    def get_session_stats(self, user_id: UUID) -> SessionStatsDto:
        """Get session statistics for a user."""
        with self.uow:
            sessions = self.uow.user_sessions.get_all_sessions_by_user_id(user_id)

            stats = {
                "total_sessions": len(sessions),
                "active_sessions": 0,
                "expired_sessions": 0,
                "logged_out_sessions": 0,
                "revoked_sessions": 0,
            }

            for session in sessions:
                if session.status.value == "active" and session.is_active():
                    stats["active_sessions"] += 1
                elif session.status.value == "expired" or (
                    session.status.value == "active" and session.is_expired()
                ):
                    stats["expired_sessions"] += 1
                elif session.status.value == "logged_out":
                    stats["logged_out_sessions"] += 1
                elif session.status.value == "revoked":
                    stats["revoked_sessions"] += 1

            return SessionStatsDto(**stats)

    def validate_session(self, session_token: str) -> Optional[UserSession]:
        """Validate if a session is still active and not expired."""
        with self.uow:
            session = self.uow.user_sessions.get_by_session_token(session_token)
            if not session:
                return None

            if not session.is_active():
                return None

            # Auto-expire if needed
            if session.is_expired():
                expired_session = session.expire()
                self.uow.user_sessions.update(expired_session)
                return None

            return session
import os
from sqlalchemy import create_engine, MetaData
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://postgres:password@localhost:5432/ddd_app"
)

SCHEMA_NAME = "contas"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create Base with schema support
metadata = MetaData(schema=SCHEMA_NAME)
Base = declarative_base(metadata=metadata)


def get_db():
    """Legacy dependency - use get_unit_of_work instead for new code."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
from sqlalchemy import Column, String, DateTime, Boolean, ForeignKey, Enum, Table, Text, Integer, JSON
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import uuid
import enum

from .connection import Base


class SessionStatusEnum(enum.Enum):
    ACTIVE = "active"
    EXPIRED = "expired"
    LOGGED_OUT = "logged_out"
    REVOKED = "revoked"


class ResourceTypeEnum(enum.Enum):
    PROJECT = "project"
    DOCUMENT = "document"
    DATASET = "dataset"
    REPORT = "report"
    DASHBOARD = "dashboard"
    FOLDER = "folder"
    CUSTOM = "custom"


class PermissionEffectEnum(enum.Enum):
    ALLOW = "allow"
    DENY = "deny"


class UserModel(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)
    password = Column(String(255), nullable=False)
    cpf = Column(String(255), nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    is_active = Column(Boolean, default=False)


class UserSessionModel(Base):
    __tablename__ = "user_sessions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    session_token = Column(String(500), nullable=False, unique=True, index=True)
    status = Column(Enum(SessionStatusEnum), nullable=False, default=SessionStatusEnum.ACTIVE, index=True)
    login_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now())
    logout_at = Column(DateTime(timezone=True), nullable=True)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(String(500), nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())


user_organization_association = Table(
    'user_organizations',
    Base.metadata,
    Column('user_id', UUID(as_uuid=True), ForeignKey('users.id'), primary_key=True),
    Column('organization_id', UUID(as_uuid=True), ForeignKey('organizations.id'), primary_key=True),
    Column('joined_at', DateTime(timezone=True), server_default=func.now())
)


class OrganizationModel(Base):
    __tablename__ = "organizations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False, index=True)
    description = Column(Text, nullable=True)
    owner_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    is_active = Column(Boolean, default=True)


class RoleModel(Base):
    __tablename__ = "roles"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False, unique=True, index=True)
    description = Column(Text, nullable=True)
    is_system = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    is_active = Column(Boolean, default=True)


class PermissionModel(Base):
    __tablename__ = "permissions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False, unique=True, index=True)
    description = Column(Text, nullable=True)
    resource = Column(String(255), nullable=False, index=True)
    action = Column(String(255), nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    is_active = Column(Boolean, default=True)


role_permission_association = Table(
    'role_permissions',
    Base.metadata,
    Column('role_id', UUID(as_uuid=True), ForeignKey('roles.id'), primary_key=True),
    Column('permission_id', UUID(as_uuid=True), ForeignKey('permissions.id'), primary_key=True),
    Column('assigned_at', DateTime(timezone=True), server_default=func.now())
)


class UserOrganizationRoleModel(Base):
    __tablename__ = "user_organization_roles"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True)
    role_id = Column(UUID(as_uuid=True), ForeignKey("roles.id"), nullable=False, index=True)
    assigned_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now())
    assigned_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    revoked_at = Column(DateTime(timezone=True), nullable=True)
    revoked_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    is_active = Column(Boolean, default=True)


# RBAC + ABAC Models
class ResourceModel(Base):
    __tablename__ = "resources"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String(255), nullable=False, index=True)
    resource_type = Column(Enum(ResourceTypeEnum), nullable=False, index=True)
    description = Column(Text, nullable=True)
    parent_id = Column(UUID(as_uuid=True), ForeignKey("resources.id"), nullable=True, index=True)
    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=True, index=True)
    metadata = Column(JSON, nullable=False, default={})  # Flexible attributes for ABAC
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    is_active = Column(Boolean, default=True)


class ResourcePermissionModel(Base):
    __tablename__ = "resource_permissions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True, index=True)  # Direct user permission
    role_id = Column(UUID(as_uuid=True), ForeignKey("roles.id"), nullable=True, index=True)  # Role-based permission
    resource_id = Column(UUID(as_uuid=True), ForeignKey("resources.id"), nullable=False, index=True)
    permission_id = Column(UUID(as_uuid=True), ForeignKey("permissions.id"), nullable=False, index=True)
    effect = Column(Enum(PermissionEffectEnum), nullable=False, default=PermissionEffectEnum.ALLOW)
    conditions = Column(JSON, nullable=False, default=[])  # ABAC conditions
    priority = Column(Integer, nullable=False, default=0)  # Rule priority
    assigned_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now())
    assigned_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    revoked_at = Column(DateTime(timezone=True), nullable=True)
    revoked_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    is_active = Column(Boolean, default=True)
from sqlalchemy import Column, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from sqlalchemy.ext.declarative import declarative_base
import uuid

Base = declarative_base()


class BaseModel(Base):
    """Base model with common fields for all entities."""
    __abstract__ = True
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)
from sqlalchemy import Column, String, Boolean, ForeignKey, DateTime, Text, Enum, Integer
from sqlalchemy.dialects.postgresql import UUID, JSON
from sqlalchemy.sql import func
import enum

from .base import BaseModel


class OrganizationRoleEnum(str, enum.Enum):
    OWNER = "owner"
    ADMIN = "admin"
    MEMBER = "member"
    VIEWER = "viewer"


class OrganizationModel(BaseModel):
    """SQLAlchemy model for Organization entity."""
    __tablename__ = "organizations"

    name = Column(String(255), nullable=False, index=True)
    description = Column(Text, nullable=True)
    owner_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    is_active = Column(Boolean, default=True, nullable=False)
    settings = Column(JSON, nullable=False, default={})  # Organization settings as JSON
    member_count = Column(Integer, default=1, nullable=False)
    max_members = Column(Integer, nullable=True)


class UserOrganizationRoleModel(BaseModel):
    """SQLAlchemy model for UserOrganizationRole entity."""
    __tablename__ = "user_organization_roles"

    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True)
    role = Column(Enum(OrganizationRoleEnum), nullable=False, index=True)
    assigned_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Ensure unique active membership per user per organization
    __table_args__ = (
        {'postgresql_where': 'is_active = true'},
    )
from sqlalchemy import Column, String, Boolean, ForeignKey, Text, Enum, Integer, Table
from sqlalchemy.dialects.postgresql import UUID, JSON
from sqlalchemy.sql import func
import enum

from .base import BaseModel, Base


class PermissionTypeEnum(str, enum.Enum):
    CREATE = "create"
    READ = "read"
    UPDATE = "update"
    DELETE = "delete"
    EXECUTE = "execute"
    MANAGE = "manage"


class PolicyEffectEnum(str, enum.Enum):
    ALLOW = "allow"
    DENY = "deny"


# Association table for role-permission many-to-many relationship
role_permission_association = Table(
    'role_permissions',
    Base.metadata,
    Column('role_id', UUID(as_uuid=True), ForeignKey('authorization_roles.id'), primary_key=True),
    Column('permission_id', UUID(as_uuid=True), ForeignKey('authorization_permissions.id'), primary_key=True),
    Column('assigned_at', Column(DateTime(timezone=True), server_default=func.now(), nullable=False))
)


# Association table for user-role assignments
user_role_assignment = Table(
    'user_role_assignments',
    Base.metadata,
    Column('user_id', UUID(as_uuid=True), ForeignKey('users.id'), primary_key=True),
    Column('role_id', UUID(as_uuid=True), ForeignKey('authorization_roles.id'), primary_key=True),
    Column('organization_id', UUID(as_uuid=True), ForeignKey('organizations.id'), nullable=True),
    Column('assigned_by', UUID(as_uuid=True), ForeignKey('users.id'), nullable=False),
    Column('assigned_at', Column(DateTime(timezone=True), server_default=func.now(), nullable=False)),
    Column('expires_at', Column(DateTime(timezone=True), nullable=True)),
    Column('is_active', Boolean, default=True, nullable=False)
)


class RoleModel(BaseModel):
    """SQLAlchemy model for Role entity."""
    __tablename__ = "authorization_roles"

    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=False)
    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=True, index=True)
    created_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    is_system_role = Column(Boolean, default=False, nullable=False)
    
    # Ensure unique role names within organization scope (null for global roles)
    __table_args__ = (
        {'postgresql_unique': ['name', 'organization_id']},
    )


class PermissionModel(BaseModel):
    """SQLAlchemy model for Permission entity."""
    __tablename__ = "authorization_permissions"

    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=False)
    permission_type = Column(Enum(PermissionTypeEnum), nullable=False, index=True)
    resource_type = Column(String(50), nullable=False, index=True)
    is_active = Column(Boolean, default=True, nullable=False)
    is_system_permission = Column(Boolean, default=False, nullable=False)
    
    # Ensure unique permission names within resource type
    __table_args__ = (
        {'postgresql_unique': ['name', 'resource_type']},
    )


class PolicyModel(BaseModel):
    """SQLAlchemy model for Policy entity."""
    __tablename__ = "authorization_policies"

    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=False)
    effect = Column(Enum(PolicyEffectEnum), nullable=False, index=True)
    resource_type = Column(String(50), nullable=False, index=True)
    action = Column(String(50), nullable=False, index=True)
    conditions = Column(JSON, nullable=False, default=[])  # List of policy conditions
    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=True, index=True)
    created_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    priority = Column(Integer, default=0, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Index for efficient policy lookup
    __table_args__ = (
        {'postgresql_index': ['resource_type', 'action', 'organization_id']},
    )
from .base import BaseModel, Base
from .user_models import UserModel, UserSessionModel, SessionStatusEnum
from .organization_models import (
    OrganizationModel, UserOrganizationRoleModel, OrganizationRoleEnum
)
from .authorization_models import (
    RoleModel, PermissionModel, PolicyModel,
    PermissionTypeEnum, PolicyEffectEnum,
    role_permission_association, user_role_assignment
)
from .plans_models import (
    PlanModel, PlanResourceModel, SubscriptionModel, 
    PlanConfigurationModel, FeatureUsageModel,
    PlanTypeEnum, PlanResourceTypeEnum, SubscriptionStatusEnum, BillingCycleEnum
)

__all__ = [
    # Base
    "BaseModel", "Base",
    
    # User models
    "UserModel", "UserSessionModel", "SessionStatusEnum",
    
    # Organization models
    "OrganizationModel", "UserOrganizationRoleModel", "OrganizationRoleEnum",
    
    # Authorization models
    "RoleModel", "PermissionModel", "PolicyModel",
    "PermissionTypeEnum", "PolicyEffectEnum",
    "role_permission_association", "user_role_assignment",
    
    # Plans models
    "PlanModel", "PlanResourceModel", "SubscriptionModel",
    "PlanConfigurationModel", "FeatureUsageModel",
    "PlanTypeEnum", "PlanResourceTypeEnum", "SubscriptionStatusEnum", "BillingCycleEnum"
]
from sqlalchemy import Column, String, Boolean, ForeignKey, DateTime, Text, Enum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import enum

from .base import BaseModel


class SessionStatusEnum(enum.Enum):
    ACTIVE = "active"
    EXPIRED = "expired"
    LOGGED_OUT = "logged_out"
    REVOKED = "revoked"


class UserModel(BaseModel):
    """SQLAlchemy model for User entity."""
    __tablename__ = "users"

    email = Column(String(255), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    is_verified = Column(Boolean, default=False, nullable=False)
    last_login_at = Column(DateTime(timezone=True), nullable=True)


class UserSessionModel(BaseModel):
    """SQLAlchemy model for UserSession entity."""
    __tablename__ = "user_sessions"

    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    session_token = Column(String(500), nullable=False, unique=True, index=True)
    status = Column(Enum(SessionStatusEnum), nullable=False, default=SessionStatusEnum.ACTIVE, index=True)
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    last_activity_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now())
    logout_at = Column(DateTime(timezone=True), nullable=True)
    metadata = Column(Text, nullable=True)  # JSON string for additional session data
from sqlalchemy import Column, String, Boolean, ForeignKey, Text, Enum, Integer, Numeric, DateTime
from sqlalchemy.dialects.postgresql import UUID, JSON
from sqlalchemy.sql import func
import enum

from .base import BaseModel


class PlanTypeEnum(str, enum.Enum):
    BASIC = "basic"
    PREMIUM = "premium"
    ENTERPRISE = "enterprise"


class PlanResourceTypeEnum(str, enum.Enum):
    CHAT_WHATSAPP = "chat_whatsapp"
    CHAT_IFRAME = "chat_iframe"


class SubscriptionStatusEnum(str, enum.Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    CANCELLED = "cancelled"
    EXPIRED = "expired"
    PAUSED = "paused"


class BillingCycleEnum(str, enum.Enum):
    MONTHLY = "monthly"
    YEARLY = "yearly"


class PlanModel(BaseModel):
    """SQLAlchemy model for Plan entity."""
    __tablename__ = "plans"

    name = Column(String(100), nullable=False, unique=True, index=True)
    description = Column(Text, nullable=False)
    plan_type = Column(Enum(PlanTypeEnum), nullable=False, index=True)
    resources = Column(JSON, nullable=False, default={})  # Plan resources configuration
    price_monthly = Column(Numeric(10, 2), nullable=True)
    price_yearly = Column(Numeric(10, 2), nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    features = Column(JSON, nullable=False, default=[])  # List of plan features
    limits = Column(JSON, nullable=False, default={})  # Plan limits configuration


class PlanResourceModel(BaseModel):
    """SQLAlchemy model for PlanResource entity."""
    __tablename__ = "plan_resources"

    plan_id = Column(UUID(as_uuid=True), ForeignKey("plans.id"), nullable=False, index=True)
    resource_type = Column(Enum(PlanResourceTypeEnum), nullable=False, index=True)
    configuration = Column(JSON, nullable=False, default={})  # Resource-specific configuration
    is_enabled = Column(Boolean, default=True, nullable=False)
    limits = Column(JSON, nullable=False, default={})  # Resource limits
    
    # Ensure unique resource type per plan
    __table_args__ = (
        {'postgresql_unique': ['plan_id', 'resource_type']},
    )


class SubscriptionModel(BaseModel):
    """SQLAlchemy model for Subscription entity."""
    __tablename__ = "subscriptions"

    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True)
    plan_id = Column(UUID(as_uuid=True), ForeignKey("plans.id"), nullable=False, index=True)
    status = Column(Enum(SubscriptionStatusEnum), nullable=False, default=SubscriptionStatusEnum.PENDING, index=True)
    billing_cycle = Column(Enum(BillingCycleEnum), nullable=False, index=True)
    starts_at = Column(DateTime(timezone=True), nullable=False, index=True)
    ends_at = Column(DateTime(timezone=True), nullable=True)
    next_billing_date = Column(DateTime(timezone=True), nullable=True)
    cancelled_at = Column(DateTime(timezone=True), nullable=True)
    metadata = Column(JSON, nullable=False, default={})  # Additional subscription data
    
    # Ensure one active subscription per organization
    __table_args__ = (
        {'postgresql_where': 'status = \'active\''},
    )


class PlanConfigurationModel(BaseModel):
    """SQLAlchemy model for PlanConfiguration entity."""
    __tablename__ = "plan_configurations"

    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True)
    plan_id = Column(UUID(as_uuid=True), ForeignKey("plans.id"), nullable=False, index=True)
    configuration_data = Column(JSON, nullable=False, default={})  # Configuration settings
    api_keys = Column(JSON, nullable=False, default={})  # Encrypted API keys
    limits = Column(JSON, nullable=False, default={})  # Custom limits
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Ensure unique configuration per organization-plan
    __table_args__ = (
        {'postgresql_unique': ['organization_id', 'plan_id']},
    )


class FeatureUsageModel(BaseModel):
    """SQLAlchemy model for FeatureUsage entity."""
    __tablename__ = "feature_usage"

    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True)
    resource_type = Column(String(50), nullable=False, index=True)
    feature_name = Column(String(100), nullable=False, index=True)
    usage_count = Column(Integer, default=0, nullable=False)
    usage_date = Column(DateTime(timezone=True), nullable=False, index=True)
    usage_details = Column(JSON, nullable=False, default={})  # Detailed usage information
    cost = Column(Numeric(10, 4), nullable=True)  # Cost associated with usage
    
    # Index for efficient usage queries
    __table_args__ = (
        {'postgresql_index': ['organization_id', 'resource_type', 'usage_date']},
    )
from sqlalchemy.orm import Session
from fastapi import Depends

from infrastructure.database.connection import SessionLocal
from infrastructure.repositories.sqlalchemy_unit_of_work import SQLAlchemyUnitOfWork


def get_db_session() -> Session:
    """Get a new database session."""
    db = SessionLocal()
    return db


def get_unit_of_work(db: Session = Depends(get_db_session)) -> SQLAlchemyUnitOfWork:
    """Get a UnitOfWork instance with the current database session."""
    return SQLAlchemyUnitOfWork(db)
from abc import abstractmethod
from typing import Generic, TypeVar, List, Optional, Type
from uuid import UUID
from sqlalchemy.orm import Session

from domain.repositories.base_repository import Repository

DomainEntity = TypeVar('DomainEntity')
DatabaseModel = TypeVar('DatabaseModel')


class SQLAlchemyRepository(Repository[DomainEntity], Generic[DomainEntity, DatabaseModel]):
    def __init__(self, db: Session, model_class: Type[DatabaseModel]):
        self.db = db
        self.model_class = model_class

    @abstractmethod
    def _to_domain(self, model: DatabaseModel) -> DomainEntity:
        pass

    @abstractmethod
    def _to_model(self, entity: DomainEntity) -> DatabaseModel:
        pass

    @abstractmethod
    def _update_model(self, model: DatabaseModel, entity: DomainEntity) -> DatabaseModel:
        pass

     def create(self, entity: DomainEntity) -> DomainEntity:
        model = self._to_model(entity)
        self.db.add(model)
        self.db.flush()  # Flush to get the ID but don't commit
        self.db.refresh(model)
        return self._to_domain(model)

     def get_by_id(self, entity_id: UUID) -> Optional[DomainEntity]:
        model = self.db.query(self.model_class).filter(self.model_class.id == entity_id).first()
        return self._to_domain(model) if model else None

     def get_all(self) -> List[DomainEntity]:
        models = self.db.query(self.model_class).all()
        return [self._to_domain(model) for model in models]

     def update(self, entity: DomainEntity) -> DomainEntity:
        model = self.db.query(self.model_class).filter(self.model_class.id == entity.id).first()
        if model:
            updated_model = self._update_model(model, entity)
            self.db.flush()  # Flush changes but don't commit
            self.db.refresh(updated_model)
            return self._to_domain(updated_model)
        raise ValueError(f"Entity with id {entity.id} not found")

     def delete(self, entity_id: UUID) -> bool:
        model = self.db.query(self.model_class).filter(self.model_class.id == entity_id).first()
        if model:
            self.db.delete(model)
            self.db.flush()  # Flush changes but don't commit
            return True
        return False
from typing import Optional
from sqlalchemy.orm import Session

from domain.entities.user import User
from domain.repositories.user_repository import UserRepository
from domain.value_objects.email import Email
from domain.value_objects.password import Password
from infrastructure.database.models import UserModel
from infrastructure.repositories.base_sqlalchemy_repository import SQLAlchemyRepository


class UserRepositoryImpl(SQLAlchemyRepository[User, UserModel], UserRepository):
    def __init__(self, db: Session):
        super().__init__(db, UserModel)

    def _to_domain(self, model: UserModel) -> User:
        return User(
            id=model.id,
            email=Email(value=model.email),
            name=model.name,
            password=Password.from_hash(model.password),
            created_at=model.created_at,
            updated_at=model.updated_at,
            is_active=model.is_active,
        )

    def _to_model(self, user: User) -> UserModel:
        return UserModel(
            id=user.id,
            email=str(user.email.value),
            name=user.name,
            password=user.password.hashed_value,
            created_at=user.created_at,
            updated_at=user.updated_at,
            is_active=user.is_active,
        )

    def _update_model(self, model: UserModel, user: User) -> UserModel:
        model.email = str(user.email.value)
        model.name = user.name
        model.password = user.password.hashed_value
        model.updated_at = user.updated_at
        model.is_active = user.is_active
        return model

     def get_by_email(self, email: str) -> Optional[User]:
        model = self.db.query(UserModel).filter(UserModel.email == email).first()
        return self._to_domain(model) if model else None
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import and_
from datetime import datetime

from domain.entities.user_session import UserSession, SessionStatus
from domain.repositories.user_session_repository import UserSessionRepository
from infrastructure.database.models import UserSessionModel, SessionStatusEnum
from infrastructure.repositories.base_sqlalchemy_repository import SQLAlchemyRepository


class UserSessionRepositoryImpl(SQLAlchemyRepository[UserSession, UserSessionModel], UserSessionRepository):
    def __init__(self, db: Session):
        super().__init__(db, UserSessionModel)

    def _to_domain(self, model: UserSessionModel) -> UserSession:
        return UserSession(
            id=model.id,
            user_id=model.user_id,
            session_token=model.session_token,
            status=SessionStatus(model.status.value),
            login_at=model.login_at,
            logout_at=model.logout_at,
            expires_at=model.expires_at,
            ip_address=model.ip_address,
            user_agent=model.user_agent,
            created_at=model.created_at,
            updated_at=model.updated_at,
        )

    def _to_model(self, session: UserSession) -> UserSessionModel:
        return UserSessionModel(
            id=session.id,
            user_id=session.user_id,
            session_token=session.session_token,
            status=SessionStatusEnum(session.status.value),
            login_at=session.login_at,
            logout_at=session.logout_at,
            expires_at=session.expires_at,
            ip_address=session.ip_address,
            user_agent=session.user_agent,
            created_at=session.created_at,
            updated_at=session.updated_at,
        )

    def _update_model(self, model: UserSessionModel, session: UserSession) -> UserSessionModel:
        model.status = SessionStatusEnum(session.status.value)
        model.logout_at = session.logout_at
        model.expires_at = session.expires_at
        model.ip_address = session.ip_address
        model.user_agent = session.user_agent
        model.updated_at = session.updated_at
        return model

     def get_by_session_token(self, session_token: str) -> Optional[UserSession]:
        model = self.db.query(UserSessionModel).filter(
            UserSessionModel.session_token == session_token
        ).first()
        return self._to_domain(model) if model else None

     def get_active_sessions_by_user_id(self, user_id: UUID) -> List[UserSession]:
        models = self.db.query(UserSessionModel).filter(
            and_(
                UserSessionModel.user_id == user_id,
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
                UserSessionModel.expires_at > datetime.utcnow()
            )
        ).all()
        return [self._to_domain(model) for model in models]

     def get_all_sessions_by_user_id(self, user_id: UUID) -> List[UserSession]:
        models = self.db.query(UserSessionModel).filter(
            UserSessionModel.user_id == user_id
        ).order_by(UserSessionModel.login_at.desc()).all()
        return [self._to_domain(model) for model in models]

     def expire_sessions_by_user_id(self, user_id: UUID) -> int:
        count = self.db.query(UserSessionModel).filter(
            and_(
                UserSessionModel.user_id == user_id,
                UserSessionModel.status == SessionStatusEnum.ACTIVE
            )
        ).update({
            UserSessionModel.status: SessionStatusEnum.EXPIRED,
            UserSessionModel.logout_at: datetime.utcnow(),
            UserSessionModel.updated_at: datetime.utcnow()
        })
        self.db.commit()
        return count

     def cleanup_expired_sessions(self) -> int:
        # Mark expired sessions based on expires_at timestamp
        count = self.db.query(UserSessionModel).filter(
            and_(
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
                UserSessionModel.expires_at <= datetime.utcnow()
            )
        ).update({
            UserSessionModel.status: SessionStatusEnum.EXPIRED,
            UserSessionModel.updated_at: datetime.utcnow()
        })
        self.db.commit()
        return count
from typing import Optional, List
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import and_

from domain.entities.organization import Organization
from domain.repositories.organization_repository import OrganizationRepository
from infrastructure.database.models import OrganizationModel, user_organization_association
from infrastructure.repositories.base_sqlalchemy_repository import SQLAlchemyRepository


class OrganizationRepositoryImpl(SQLAlchemyRepository[Organization, OrganizationModel], OrganizationRepository):
    def __init__(self, db: Session):
        super().__init__(db, OrganizationModel)

    def _to_domain(self, model: OrganizationModel) -> Organization:
        return Organization(
            id=model.id,
            name=model.name,
            description=model.description,
            owner_id=model.owner_id,
            created_at=model.created_at,
            updated_at=model.updated_at,
            is_active=model.is_active,
        )

    def _to_model(self, organization: Organization) -> OrganizationModel:
        return OrganizationModel(
            id=organization.id,
            name=organization.name,
            description=organization.description,
            owner_id=organization.owner_id,
            created_at=organization.created_at,
            updated_at=organization.updated_at,
            is_active=organization.is_active,
        )

    def _update_model(self, model: OrganizationModel, organization: Organization) -> OrganizationModel:
        model.name = organization.name
        model.description = organization.description
        model.owner_id = organization.owner_id
        model.updated_at = organization.updated_at
        model.is_active = organization.is_active
        return model

     def get_by_name(self, name: str) -> Optional[Organization]:
        model = self.db.query(OrganizationModel).filter(OrganizationModel.name == name).first()
        return self._to_domain(model) if model else None

     def get_by_owner_id(self, owner_id: UUID) -> List[Organization]:
        models = self.db.query(OrganizationModel).filter(OrganizationModel.owner_id == owner_id).all()
        return [self._to_domain(model) for model in models]

     def get_organizations_by_user_id(self, user_id: UUID) -> List[Organization]:
        models = (
            self.db.query(OrganizationModel)
            .join(user_organization_association)
            .filter(user_organization_association.c.user_id == user_id)
            .all()
        )
        return [self._to_domain(model) for model in models]

     def add_user_to_organization(self, organization_id: UUID, user_id: UUID) -> None:
        insert_stmt = user_organization_association.insert().values(
            user_id=user_id,
            organization_id=organization_id
        )
        self.db.execute(insert_stmt)

     def remove_user_from_organization(self, organization_id: UUID, user_id: UUID) -> None:
        delete_stmt = user_organization_association.delete().where(
            and_(
                user_organization_association.c.user_id == user_id,
                user_organization_association.c.organization_id == organization_id
            )
        )
        self.db.execute(delete_stmt)

     def is_user_in_organization(self, organization_id: UUID, user_id: UUID) -> bool:
        result = self.db.query(user_organization_association).filter(
            and_(
                user_organization_association.c.user_id == user_id,
                user_organization_association.c.organization_id == organization_id
            )
        ).first()
        return result is not None
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError

from domain.repositories.unit_of_work import UnitOfWork
from infrastructure.repositories.user_repository_impl import UserRepositoryImpl
from infrastructure.repositories.user_session_repository_impl import UserSessionRepositoryImpl
from infrastructure.repositories.organization_repository_impl import OrganizationRepositoryImpl


class SQLAlchemyUnitOfWork(UnitOfWork):
    def __init__(self, session: Session):
        self.session = session
        self.users = UserRepositoryImpl(session)
        self.user_sessions = UserSessionRepositoryImpl(session)
        self.organizations = OrganizationRepositoryImpl(session)
        self._committed = False

     def __aenter__(self) -> "SQLAlchemyUnitOfWork":
        return self

     def __aexit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            try:
                 self.commit()
            except SQLAlchemyError:
                 self.rollback()
                raise
        else:
             self.rollback()
        self.session.close()

     def commit(self) -> None:
        if not self._committed:
            try:
                self.session.commit()
                self._committed = True
            except SQLAlchemyError:
                 self.rollback()
                raise

     def rollback(self) -> None:
        self.session.rollback()
        self._committed = False
# Infrastructure Layer - SQLAlchemy Repository Implementations
#
# This module provides SQLAlchemy implementations for all domain repositories
# across the bounded contexts following the DDD pattern.

from .database.models import (
    # Base
    BaseModel, Base,
    
    # User models
    UserModel, UserSessionModel, SessionStatusEnum,
    
    # Organization models
    OrganizationModel, UserOrganizationRoleModel, OrganizationRoleEnum,
    
    # Authorization models
    RoleModel, PermissionModel, PolicyModel,
    PermissionTypeEnum, PolicyEffectEnum,
    role_permission_association, user_role_assignment,
    
    # Plans models
    PlanModel, PlanResourceModel, SubscriptionModel,
    PlanConfigurationModel, FeatureUsageModel,
    PlanTypeEnum, PlanResourceTypeEnum, SubscriptionStatusEnum, BillingCycleEnum
)

# Repository implementations by bounded context
from user.infrastructure import SqlAlchemyUserRepository, SqlAlchemyUserSessionRepository
from organization.infrastructure import SqlAlchemyOrganizationRepository, SqlAlchemyUserOrganizationRoleRepository
from authorization.infrastructure import SqlAlchemyRoleRepository, SqlAlchemyPermissionRepository, SqlAlchemyPolicyRepository
from plans.infrastructure import SqlAlchemyPlanRepository, SqlAlchemyPlanResourceRepository, SqlAlchemySubscriptionRepository

__all__ = [
    # Database models
    "BaseModel", "Base",
    "UserModel", "UserSessionModel", "SessionStatusEnum",
    "OrganizationModel", "UserOrganizationRoleModel", "OrganizationRoleEnum",
    "RoleModel", "PermissionModel", "PolicyModel",
    "PermissionTypeEnum", "PolicyEffectEnum",
    "role_permission_association", "user_role_assignment",
    "PlanModel", "PlanResourceModel", "SubscriptionModel",
    "PlanConfigurationModel", "FeatureUsageModel",
    "PlanTypeEnum", "PlanResourceTypeEnum", "SubscriptionStatusEnum", "BillingCycleEnum",
    
    # Repository implementations
    "SqlAlchemyUserRepository", "SqlAlchemyUserSessionRepository",
    "SqlAlchemyOrganizationRepository", "SqlAlchemyUserOrganizationRoleRepository",
    "SqlAlchemyRoleRepository", "SqlAlchemyPermissionRepository", "SqlAlchemyPolicyRepository",
    "SqlAlchemyPlanRepository", "SqlAlchemyPlanResourceRepository", "SqlAlchemySubscriptionRepository"
]
from datetime import datetime, timezone
from uuid import UUID, uuid4
from typing import Optional, Dict, Any, List
from pydantic import BaseModel, field_validator


class PlanConfiguration(BaseModel):
    id: UUID
    plan_id: UUID
    api_keys: Dict[str, str]
    limits: Dict[str, int]
    enabled_features: List[str]
    custom_settings: Dict[str, Any]
    is_active: bool = True
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        plan_id: UUID,
        api_keys: Optional[Dict[str, str]] = None,
        limits: Optional[Dict[str, int]] = None,
        enabled_features: Optional[List[str]] = None,
        custom_settings: Optional[Dict[str, Any]] = None
    ) -> "PlanConfiguration":
        return cls(
            id=uuid4(),
            plan_id=plan_id,
            api_keys=api_keys or {},
            limits=limits or {},
            enabled_features=enabled_features or [],
            custom_settings=custom_settings or {},
            is_active=True,
            created_at=datetime.now(timezone.utc)
        )

    @classmethod
    def create_basic_configuration(cls, plan_id: UUID) -> "PlanConfiguration":
        """Create basic plan configuration."""
        return cls.create(
            plan_id=plan_id,
            limits={
                "monthly_messages": 10000,
                "monthly_api_calls": 50000,
                "storage_mb": 1000,
                "concurrent_sessions": 25
            },
            enabled_features=[
                "chat_iframe",
                "chat_whatsapp", 
                "webhook_support",
                "basic_analytics"
            ]
        )

    @classmethod
    def create_premium_configuration(cls, plan_id: UUID) -> "PlanConfiguration":
        """Create premium plan configuration."""
        return cls.create(
            plan_id=plan_id,
            api_keys={
                "whatsapp_api_key": "premium-whatsapp-key",
                "iframe_api_key": "premium-iframe-key"
            },
            limits={
                "monthly_messages": 100000,
                "monthly_api_calls": 500000,
                "storage_mb": 10000,
                "concurrent_sessions": 100,
                "webhook_endpoints": 10
            },
            enabled_features=[
                "chat_iframe",
                "chat_whatsapp",
                "custom_branding",
                "webhook_support",
                "advanced_analytics",
                "custom_css",
                "priority_support"
            ]
        )

    @classmethod
    def create_enterprise_configuration(cls, plan_id: UUID) -> "PlanConfiguration":
        """Create enterprise plan configuration."""
        return cls.create(
            plan_id=plan_id,
            api_keys={
                "whatsapp_api_key": "enterprise-whatsapp-key",
                "iframe_api_key": "enterprise-iframe-key",
                "sso_api_key": "enterprise-sso-key"
            },
            limits={
                "monthly_messages": -1,  # Unlimited
                "monthly_api_calls": -1,  # Unlimited
                "storage_mb": -1,  # Unlimited
                "concurrent_sessions": -1,  # Unlimited
                "webhook_endpoints": -1,  # Unlimited
                "custom_fields": -1  # Unlimited
            },
            enabled_features=[
                "chat_iframe",
                "chat_whatsapp",
                "custom_branding",
                "webhook_support",
                "advanced_analytics",
                "custom_css",
                "priority_support",
                "sso",
                "audit_logs",
                "white_label",
                "dedicated_support"
            ]
        )

    def update_api_key(self, key_name: str, api_key: str) -> "PlanConfiguration":
        """Update or add an API key."""
        new_api_keys = self.api_keys.copy()
        new_api_keys[key_name] = api_key
        
        return self.model_copy(update={
            "api_keys": new_api_keys,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_api_key(self, key_name: str) -> "PlanConfiguration":
        """Remove an API key."""
        new_api_keys = self.api_keys.copy()
        new_api_keys.pop(key_name, None)
        
        return self.model_copy(update={
            "api_keys": new_api_keys,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_limit(self, limit_name: str, value: int) -> "PlanConfiguration":
        """Update or add a limit."""
        new_limits = self.limits.copy()
        new_limits[limit_name] = value
        
        return self.model_copy(update={
            "limits": new_limits,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_limit(self, limit_name: str) -> "PlanConfiguration":
        """Remove a limit."""
        new_limits = self.limits.copy()
        new_limits.pop(limit_name, None)
        
        return self.model_copy(update={
            "limits": new_limits,
            "updated_at": datetime.now(timezone.utc)
        })

    def add_feature(self, feature: str) -> "PlanConfiguration":
        """Add a feature to enabled features."""
        if feature not in self.enabled_features:
            new_features = self.enabled_features.copy()
            new_features.append(feature)
            
            return self.model_copy(update={
                "enabled_features": new_features,
                "updated_at": datetime.now(timezone.utc)
            })
        
        return self

    def remove_feature(self, feature: str) -> "PlanConfiguration":
        """Remove a feature from enabled features."""
        if feature in self.enabled_features:
            new_features = self.enabled_features.copy()
            new_features.remove(feature)
            
            return self.model_copy(update={
                "enabled_features": new_features,
                "updated_at": datetime.now(timezone.utc)
            })
        
        return self

    def update_custom_setting(self, key: str, value: Any) -> "PlanConfiguration":
        """Update or add a custom setting."""
        new_settings = self.custom_settings.copy()
        new_settings[key] = value
        
        return self.model_copy(update={
            "custom_settings": new_settings,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_custom_setting(self, key: str) -> "PlanConfiguration":
        """Remove a custom setting."""
        new_settings = self.custom_settings.copy()
        new_settings.pop(key, None)
        
        return self.model_copy(update={
            "custom_settings": new_settings,
            "updated_at": datetime.now(timezone.utc)
        })

    def bulk_update(
        self,
        api_keys: Optional[Dict[str, str]] = None,
        limits: Optional[Dict[str, int]] = None,
        enabled_features: Optional[List[str]] = None,
        custom_settings: Optional[Dict[str, Any]] = None
    ) -> "PlanConfiguration":
        """Bulk update configuration."""
        updates = {"updated_at": datetime.now(timezone.utc)}
        
        if api_keys is not None:
            new_api_keys = self.api_keys.copy()
            new_api_keys.update(api_keys)
            updates["api_keys"] = new_api_keys
        
        if limits is not None:
            new_limits = self.limits.copy()
            new_limits.update(limits)
            updates["limits"] = new_limits
        
        if enabled_features is not None:
            updates["enabled_features"] = enabled_features
        
        if custom_settings is not None:
            new_settings = self.custom_settings.copy()
            new_settings.update(custom_settings)
            updates["custom_settings"] = new_settings
        
        return self.model_copy(update=updates)

    def activate(self) -> "PlanConfiguration":
        """Activate configuration."""
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.now(timezone.utc)
        })

    def deactivate(self) -> "PlanConfiguration":
        """Deactivate configuration."""
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.now(timezone.utc)
        })

    def get_api_key(self, key_name: str) -> Optional[str]:
        """Get specific API key."""
        return self.api_keys.get(key_name)

    def get_limit(self, limit_name: str) -> Optional[int]:
        """Get specific limit."""
        return self.limits.get(limit_name)

    def has_feature(self, feature: str) -> bool:
        """Check if feature is enabled."""
        return feature in self.enabled_features

    def get_custom_setting(self, key: str, default: Any = None) -> Any:
        """Get custom setting value."""
        return self.custom_settings.get(key, default)

    def is_limit_unlimited(self, limit_name: str) -> bool:
        """Check if limit is unlimited (-1)."""
        limit = self.get_limit(limit_name)
        return limit == -1 if limit is not None else False

    def has_required_api_keys_for_chat_whatsapp(self) -> bool:
        """Check if required API keys for WhatsApp are present."""
        return self.get_api_key("whatsapp_api_key") is not None

    def has_required_api_keys_for_chat_iframe(self) -> bool:
        """Check if required API keys for iframe chat are present."""
        return self.get_api_key("iframe_api_key") is not None

    def validate_configuration(self) -> tuple[bool, List[str]]:
        """Validate the configuration."""
        errors = []
        
        # Check for required API keys if features are enabled
        if self.has_feature("chat_whatsapp") and not self.has_required_api_keys_for_chat_whatsapp():
            errors.append("WhatsApp API key is required when chat_whatsapp feature is enabled")
        
        if self.has_feature("chat_iframe") and not self.has_required_api_keys_for_chat_iframe():
            errors.append("Iframe API key is required when chat_iframe feature is enabled")
        
        # Check for negative limits (except -1 for unlimited)
        for limit_name, limit_value in self.limits.items():
            if limit_value < -1:
                errors.append(f"Invalid limit value for {limit_name}: {limit_value}")
        
        return len(errors) == 0, errors

    def get_configuration_summary(self) -> Dict[str, Any]:
        """Get a summary of the configuration."""
        return {
            "id": str(self.id),
            "plan_id": str(self.plan_id),
            "api_keys_count": len(self.api_keys),
            "api_key_names": list(self.api_keys.keys()),
            "limits": self.limits,
            "enabled_features": self.enabled_features,
            "custom_settings_count": len(self.custom_settings),
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert configuration to dictionary (hiding sensitive API keys)."""
        return {
            "id": str(self.id),
            "plan_id": str(self.plan_id),
            "api_keys": {k: "***" for k in self.api_keys.keys()},  # Hide actual keys
            "limits": self.limits,
            "enabled_features": self.enabled_features,
            "custom_settings": self.custom_settings,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
from datetime import datetime, timezone
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum

from ..value_objects.plan_name import PlanName
from ..value_objects.pricing import Pricing


class PlanType(str, Enum):
    BASIC = "basic"
    PREMIUM = "premium"
    ENTERPRISE = "enterprise"


class PlanStatus(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    DEPRECATED = "deprecated"


class Plan(BaseModel):
    id: UUID
    name: PlanName
    description: str
    plan_type: PlanType
    pricing: Pricing
    max_users: int
    max_organizations: int
    resources: Dict[str, Any]  # Associated resources configuration
    is_active: bool = True
    status: PlanStatus
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_public: bool = True

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls,
        name: str,
        description: str,
        plan_type: PlanType,
        pricing: Pricing,
        max_users: int = 10,
        max_organizations: int = 1,
        resources: Optional[Dict[str, Any]] = None,
        is_public: bool = True
    ) -> "Plan":
        return cls(
            id=uuid4(),
            name=PlanName(value=name),
            description=description,
            plan_type=plan_type,
            pricing=pricing,
            max_users=max_users,
            max_organizations=max_organizations,
            resources=resources or cls._get_default_resources(plan_type),
            is_active=True,
            status=PlanStatus.ACTIVE,
            created_at=datetime.now(timezone.utc),
            is_public=is_public
        )

    @staticmethod
    def _get_default_resources(plan_type: PlanType) -> Dict[str, Any]:
        """Get default resources configuration based on plan type."""
        if plan_type == PlanType.BASIC:
            return {
                "chat_iframe": {
                    "enabled": True,
                    "api_keys": {"iframe_api_key": "basic-iframe-key"},
                    "limits": {"concurrent_sessions": 25, "domains_allowed": 3},
                    "enabled_features": ["basic_chat", "emoji_support"]
                },
                "chat_whatsapp": {
                    "enabled": True,
                    "api_keys": {"whatsapp_api_key": "basic-whatsapp-key"},
                    "limits": {"messages_per_day": 1000},
                    "enabled_features": ["auto_reply", "business_hours"]
                }
            }
        
        elif plan_type == PlanType.PREMIUM:
            return {
                "chat_iframe": {
                    "enabled": True,
                    "api_keys": {"iframe_api_key": "premium-iframe-key"},
                    "limits": {"concurrent_sessions": 100, "domains_allowed": 10},
                    "enabled_features": ["basic_chat", "emoji_support", "custom_css", "file_upload"]
                },
                "chat_whatsapp": {
                    "enabled": True,
                    "api_keys": {"whatsapp_api_key": "premium-whatsapp-key"},
                    "limits": {"messages_per_day": 5000},
                    "enabled_features": ["auto_reply", "business_hours", "template_messages", "media_messages"]
                }
            }
        
        elif plan_type == PlanType.ENTERPRISE:
            return {
                "chat_iframe": {
                    "enabled": True,
                    "api_keys": {"iframe_api_key": "enterprise-iframe-key"},
                    "limits": {"concurrent_sessions": -1, "domains_allowed": -1},  # Unlimited
                    "enabled_features": ["basic_chat", "emoji_support", "custom_css", "file_upload", "custom_branding", "white_label"]
                },
                "chat_whatsapp": {
                    "enabled": True,
                    "api_keys": {"whatsapp_api_key": "enterprise-whatsapp-key"},
                    "limits": {"messages_per_day": -1},  # Unlimited
                    "enabled_features": ["auto_reply", "business_hours", "template_messages", "media_messages", "bulk_messaging", "analytics"]
                }
            }
        
        return {}

    def update_description(self, description: str) -> "Plan":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_pricing(self, pricing: Pricing) -> "Plan":
        return self.model_copy(update={
            "pricing": pricing,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_resource(self, resource_type: str, config: Dict[str, Any]) -> "Plan":
        new_resources = self.resources.copy()
        new_resources[resource_type] = config
        
        return self.model_copy(update={
            "resources": new_resources,
            "updated_at": datetime.now(timezone.utc)
        })

    def enable_resource(self, resource_type: str) -> "Plan":
        new_resources = self.resources.copy()
        if resource_type in new_resources:
            new_resources[resource_type]["enabled"] = True
        
        return self.model_copy(update={
            "resources": new_resources,
            "updated_at": datetime.now(timezone.utc)
        })

    def disable_resource(self, resource_type: str) -> "Plan":
        new_resources = self.resources.copy()
        if resource_type in new_resources:
            new_resources[resource_type]["enabled"] = False
        
        return self.model_copy(update={
            "resources": new_resources,
            "updated_at": datetime.now(timezone.utc)
        })

    def deactivate(self) -> "Plan":
        return self.model_copy(update={
            "is_active": False,
            "status": PlanStatus.INACTIVE,
            "updated_at": datetime.now(timezone.utc)
        })

    def activate(self) -> "Plan":
        return self.model_copy(update={
            "is_active": True,
            "status": PlanStatus.ACTIVE,
            "updated_at": datetime.now(timezone.utc)
        })

    def deprecate(self) -> "Plan":
        return self.model_copy(update={
            "is_active": False,
            "status": PlanStatus.DEPRECATED,
            "is_public": False,
            "updated_at": datetime.now(timezone.utc)
        })

    def has_resource(self, resource_type: str) -> bool:
        resource = self.resources.get(resource_type, {})
        return resource.get("enabled", False)

    def get_resource_config(self, resource_type: str) -> Dict[str, Any]:
        return self.resources.get(resource_type, {})

    def get_resource_api_key(self, resource_type: str, key_name: str) -> Optional[str]:
        resource = self.get_resource_config(resource_type)
        api_keys = resource.get("api_keys", {})
        return api_keys.get(key_name)

    def get_resource_limit(self, resource_type: str, limit_name: str) -> Optional[int]:
        resource = self.get_resource_config(resource_type)
        limits = resource.get("limits", {})
        return limits.get(limit_name)

    def get_resource_features(self, resource_type: str) -> list:
        resource = self.get_resource_config(resource_type)
        return resource.get("enabled_features", [])

    def can_support_users(self, user_count: int) -> bool:
        return user_count <= self.max_users

    def can_support_organizations(self, org_count: int) -> bool:
        return org_count <= self.max_organizations

    def has_chat_whatsapp(self) -> bool:
        return self.has_resource("chat_whatsapp")

    def has_chat_iframe(self) -> bool:
        return self.has_resource("chat_iframe")

    def is_available_for_signup(self) -> bool:
        return self.status == PlanStatus.ACTIVE and self.is_public and self.is_active

    def validate_resource_requirements(self, resource_type: str) -> tuple[bool, list[str]]:
        """Validate if resource has required configuration."""
        errors = []
        resource = self.get_resource_config(resource_type)
        
        if not resource:
            errors.append(f"Resource {resource_type} not configured")
            return False, errors
        
        if not resource.get("enabled", False):
            errors.append(f"Resource {resource_type} is not enabled")
        
        # Validate required API keys
        api_keys = resource.get("api_keys", {})
        if resource_type == "chat_whatsapp" and not api_keys.get("whatsapp_api_key"):
            errors.append("WhatsApp API key is required")
        
        if resource_type == "chat_iframe" and not api_keys.get("iframe_api_key"):
            errors.append("Iframe API key is required")
        
        return len(errors) == 0, errors
from datetime import datetime, timedelta
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class UsagePeriod(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    YEARLY = "yearly"


class FeatureUsage(BaseModel):
    id: UUID
    organization_id: UUID
    feature_name: str
    usage_period: UsagePeriod
    period_start: datetime
    period_end: datetime
    current_usage: int
    limit_value: int  # -1 for unlimited
    metadata: Dict[str, Any]  # Additional usage data
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        organization_id: UUID,
        feature_name: str,
        usage_period: UsagePeriod,
        limit_value: int,
        current_usage: int = 0,
        metadata: Optional[Dict[str, Any]] = None
    ) -> "FeatureUsage":
        now = datetime.utcnow()
        period_start, period_end = cls._calculate_period_boundaries(now, usage_period)
        
        return cls(
            id=uuid4(),
            organization_id=organization_id,
            feature_name=feature_name,
            usage_period=usage_period,
            period_start=period_start,
            period_end=period_end,
            current_usage=current_usage,
            limit_value=limit_value,
            metadata=metadata or {},
            created_at=now
        )

    @staticmethod
    def _calculate_period_boundaries(date: datetime, period: UsagePeriod) -> tuple[datetime, datetime]:
        """Calculate period start and end dates."""
        if period == UsagePeriod.DAILY:
            start = date.replace(hour=0, minute=0, second=0, microsecond=0)
            end = start + timedelta(days=1) - timedelta(microseconds=1)
        
        elif period == UsagePeriod.WEEKLY:
            # Start on Monday
            days_since_monday = date.weekday()
            start = (date - timedelta(days=days_since_monday)).replace(
                hour=0, minute=0, second=0, microsecond=0
            )
            end = start + timedelta(days=7) - timedelta(microseconds=1)
        
        elif period == UsagePeriod.MONTHLY:
            start = date.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            if start.month == 12:
                end = start.replace(year=start.year + 1, month=1) - timedelta(microseconds=1)
            else:
                end = start.replace(month=start.month + 1) - timedelta(microseconds=1)
        
        elif period == UsagePeriod.YEARLY:
            start = date.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
            end = start.replace(year=start.year + 1) - timedelta(microseconds=1)
        
        else:
            raise ValueError(f"Unsupported usage period: {period}")
        
        return start, end

    def increment_usage(self, amount: int = 1, metadata_update: Optional[Dict[str, Any]] = None) -> "FeatureUsage":
        """Increment usage counter."""
        new_metadata = self.metadata.copy()
        if metadata_update:
            new_metadata.update(metadata_update)
        
        return self.model_copy(update={
            "current_usage": self.current_usage + amount,
            "metadata": new_metadata,
            "updated_at": datetime.utcnow()
        })

    def reset_usage(self) -> "FeatureUsage":
        """Reset usage counter for new period."""
        now = datetime.utcnow()
        period_start, period_end = self._calculate_period_boundaries(now, self.usage_period)
        
        return self.model_copy(update={
            "current_usage": 0,
            "period_start": period_start,
            "period_end": period_end,
            "metadata": {},
            "updated_at": now
        })

    def update_limit(self, new_limit: int) -> "FeatureUsage":
        """Update usage limit."""
        return self.model_copy(update={
            "limit_value": new_limit,
            "updated_at": datetime.utcnow()
        })

    def is_unlimited(self) -> bool:
        """Check if feature has unlimited usage."""
        return self.limit_value == -1

    def is_limit_exceeded(self) -> bool:
        """Check if usage limit is exceeded."""
        if self.is_unlimited():
            return False
        
        return self.current_usage >= self.limit_value

    def is_limit_near(self, threshold_percent: float = 0.8) -> bool:
        """Check if usage is near the limit."""
        if self.is_unlimited():
            return False
        
        threshold = int(self.limit_value * threshold_percent)
        return self.current_usage >= threshold

    def get_usage_percentage(self) -> float:
        """Get usage as percentage of limit."""
        if self.is_unlimited():
            return 0.0
        
        if self.limit_value == 0:
            return 100.0 if self.current_usage > 0 else 0.0
        
        return (self.current_usage / self.limit_value) * 100

    def get_remaining_usage(self) -> int:
        """Get remaining usage before hitting limit."""
        if self.is_unlimited():
            return -1  # Unlimited
        
        return max(0, self.limit_value - self.current_usage)

    def is_current_period(self) -> bool:
        """Check if this record is for the current period."""
        now = datetime.utcnow()
        return self.period_start <= now <= self.period_end

    def is_period_expired(self) -> bool:
        """Check if the usage period has expired."""
        return datetime.utcnow() > self.period_end

    def days_until_reset(self) -> int:
        """Get days until usage resets."""
        if self.is_period_expired():
            return 0
        
        delta = self.period_end - datetime.utcnow()
        return max(0, delta.days + 1)  # +1 to include current day

    def can_use_feature(self, amount: int = 1) -> tuple[bool, str]:
        """Check if feature can be used given the amount."""
        if self.is_period_expired():
            return False, "Usage period has expired"
        
        if self.is_unlimited():
            return True, "Feature has unlimited usage"
        
        if self.current_usage + amount > self.limit_value:
            remaining = self.get_remaining_usage()
            return False, f"Would exceed limit. Remaining: {remaining}, Requested: {amount}"
        
        return True, "Usage within limits"

    def get_usage_summary(self) -> Dict[str, Any]:
        """Get comprehensive usage summary."""
        return {
            "feature_name": self.feature_name,
            "current_usage": self.current_usage,
            "limit_value": self.limit_value,
            "is_unlimited": self.is_unlimited(),
            "usage_percentage": self.get_usage_percentage(),
            "remaining_usage": self.get_remaining_usage(),
            "is_limit_exceeded": self.is_limit_exceeded(),
            "is_limit_near": self.is_limit_near(),
            "period_start": self.period_start.isoformat(),
            "period_end": self.period_end.isoformat(),
            "days_until_reset": self.days_until_reset(),
            "is_current_period": self.is_current_period()
        }
from datetime import datetime, timedelta
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class SubscriptionStatus(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    SUSPENDED = "suspended"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class BillingCycle(str, Enum):
    MONTHLY = "monthly"
    YEARLY = "yearly"
    LIFETIME = "lifetime"


class OrganizationPlan(BaseModel):
    id: UUID
    organization_id: UUID
    plan_id: UUID
    status: SubscriptionStatus
    billing_cycle: BillingCycle
    feature_overrides: Dict[str, Any]  # Custom feature configurations
    limit_overrides: Dict[str, int]    # Custom limits
    started_at: datetime
    expires_at: Optional[datetime] = None
    cancelled_at: Optional[datetime] = None
    suspended_at: Optional[datetime] = None
    trial_ends_at: Optional[datetime] = None
    auto_renew: bool = True
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        organization_id: UUID,
        plan_id: UUID,
        billing_cycle: BillingCycle = BillingCycle.MONTHLY,
        trial_days: int = 0,
        feature_overrides: Optional[Dict[str, Any]] = None,
        limit_overrides: Optional[Dict[str, int]] = None
    ) -> "OrganizationPlan":
        now = datetime.utcnow()
        
        # Calculate expiration based on billing cycle
        if billing_cycle == BillingCycle.MONTHLY:
            expires_at = now + timedelta(days=30)
        elif billing_cycle == BillingCycle.YEARLY:
            expires_at = now + timedelta(days=365)
        else:  # LIFETIME
            expires_at = None
        
        # Set trial period if specified
        trial_ends_at = None
        if trial_days > 0:
            trial_ends_at = now + timedelta(days=trial_days)
        
        return cls(
            id=uuid4(),
            organization_id=organization_id,
            plan_id=plan_id,
            status=SubscriptionStatus.ACTIVE,
            billing_cycle=billing_cycle,
            feature_overrides=feature_overrides or {},
            limit_overrides=limit_overrides or {},
            started_at=now,
            expires_at=expires_at,
            trial_ends_at=trial_ends_at,
            auto_renew=True,
            created_at=now
        )

    def renew(self, periods: int = 1) -> "OrganizationPlan":
        """Renew subscription for specified periods."""
        if self.billing_cycle == BillingCycle.LIFETIME:
            return self  # Lifetime subscriptions don't need renewal
        
        if not self.expires_at:
            raise ValueError("Cannot renew subscription without expiration date")
        
        days_per_period = 30 if self.billing_cycle == BillingCycle.MONTHLY else 365
        new_expires_at = self.expires_at + timedelta(days=days_per_period * periods)
        
        return self.model_copy(update={
            "expires_at": new_expires_at,
            "status": SubscriptionStatus.ACTIVE,
            "cancelled_at": None,
            "suspended_at": None,
            "updated_at": datetime.utcnow()
        })

    def cancel(self, immediate: bool = False) -> "OrganizationPlan":
        """Cancel subscription."""
        now = datetime.utcnow()
        
        updates = {
            "cancelled_at": now,
            "auto_renew": False,
            "updated_at": now
        }
        
        if immediate:
            updates["status"] = SubscriptionStatus.CANCELLED
            updates["expires_at"] = now
        
        return self.model_copy(update=updates)

    def suspend(self, reason: str = "") -> "OrganizationPlan":
        """Suspend subscription."""
        return self.model_copy(update={
            "status": SubscriptionStatus.SUSPENDED,
            "suspended_at": datetime.utcnow(),
            "updated_at": datetime.utcnow()
        })

    def reactivate(self) -> "OrganizationPlan":
        """Reactivate suspended subscription."""
        if self.status != SubscriptionStatus.SUSPENDED:
            raise ValueError("Can only reactivate suspended subscriptions")
        
        return self.model_copy(update={
            "status": SubscriptionStatus.ACTIVE,
            "suspended_at": None,
            "updated_at": datetime.utcnow()
        })

    def set_feature_override(self, feature_name: str, value: Any) -> "OrganizationPlan":
        """Set custom feature configuration."""
        new_overrides = self.feature_overrides.copy()
        new_overrides[feature_name] = value
        
        return self.model_copy(update={
            "feature_overrides": new_overrides,
            "updated_at": datetime.utcnow()
        })

    def remove_feature_override(self, feature_name: str) -> "OrganizationPlan":
        """Remove custom feature configuration."""
        new_overrides = self.feature_overrides.copy()
        new_overrides.pop(feature_name, None)
        
        return self.model_copy(update={
            "feature_overrides": new_overrides,
            "updated_at": datetime.utcnow()
        })

    def set_limit_override(self, limit_name: str, value: int) -> "OrganizationPlan":
        """Set custom limit."""
        new_overrides = self.limit_overrides.copy()
        new_overrides[limit_name] = value
        
        return self.model_copy(update={
            "limit_overrides": new_overrides,
            "updated_at": datetime.utcnow()
        })

    def remove_limit_override(self, limit_name: str) -> "OrganizationPlan":
        """Remove custom limit."""
        new_overrides = self.limit_overrides.copy()
        new_overrides.pop(limit_name, None)
        
        return self.model_copy(update={
            "limit_overrides": new_overrides,
            "updated_at": datetime.utcnow()
        })

    def is_active(self) -> bool:
        """Check if subscription is currently active."""
        return self.status == SubscriptionStatus.ACTIVE

    def is_expired(self) -> bool:
        """Check if subscription has expired."""
        if not self.expires_at:
            return False  # Lifetime subscriptions don't expire
        
        return datetime.utcnow() > self.expires_at

    def is_in_trial(self) -> bool:
        """Check if subscription is in trial period."""
        if not self.trial_ends_at:
            return False
        
        return datetime.utcnow() <= self.trial_ends_at

    def is_cancelled(self) -> bool:
        """Check if subscription is cancelled."""
        return self.cancelled_at is not None

    def is_suspended(self) -> bool:
        """Check if subscription is suspended."""
        return self.status == SubscriptionStatus.SUSPENDED

    def days_until_expiry(self) -> Optional[int]:
        """Get days until subscription expires."""
        if not self.expires_at:
            return None
        
        delta = self.expires_at - datetime.utcnow()
        return max(0, delta.days)

    def days_in_trial_remaining(self) -> Optional[int]:
        """Get days remaining in trial period."""
        if not self.trial_ends_at:
            return None
        
        delta = self.trial_ends_at - datetime.utcnow()
        return max(0, delta.days)

    def needs_renewal(self, days_ahead: int = 7) -> bool:
        """Check if subscription needs renewal within specified days."""
        if not self.expires_at or not self.auto_renew:
            return False
        
        renewal_date = datetime.utcnow() + timedelta(days=days_ahead)
        return renewal_date >= self.expires_at

    def get_effective_feature_value(self, feature_name: str, plan_default: Any) -> Any:
        """Get effective feature value considering overrides."""
        return self.feature_overrides.get(feature_name, plan_default)

    def get_effective_limit_value(self, limit_name: str, plan_default: int) -> int:
        """Get effective limit value considering overrides."""
        return self.limit_overrides.get(limit_name, plan_default)
from .plan import Plan, PlanType
from .plan_feature import PlanFeature
from .plan_resource import PlanResource, PlanResourceType
from .plan_configuration import PlanConfiguration
from .organization_plan import OrganizationPlan
from .feature_usage import FeatureUsage

__all__ = [
    "Plan", "PlanType",
    "PlanFeature", 
    "PlanResource", "PlanResourceType",
    "PlanConfiguration",
    "OrganizationPlan", 
    "FeatureUsage"
]
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class FeatureType(str, Enum):
    BOOLEAN = "boolean"
    NUMERIC = "numeric"
    STRING = "string"
    OBJECT = "object"


class FeatureCategory(str, Enum):
    COMMUNICATION = "communication"
    INTEGRATION = "integration"
    ANALYTICS = "analytics"
    SECURITY = "security"
    CUSTOMIZATION = "customization"
    SUPPORT = "support"


class PlanFeature(BaseModel):
    id: UUID
    name: str
    display_name: str
    description: str
    feature_type: FeatureType
    category: FeatureCategory
    default_value: Any
    configuration_schema: Dict[str, Any]  # JSON schema for feature configuration
    is_system_feature: bool = False
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        name: str,
        display_name: str,
        description: str,
        feature_type: FeatureType,
        category: FeatureCategory,
        default_value: Any = None,
        configuration_schema: Optional[Dict[str, Any]] = None,
        is_system_feature: bool = False
    ) -> "PlanFeature":
        return cls(
            id=uuid4(),
            name=name,
            display_name=display_name,
            description=description,
            feature_type=feature_type,
            category=category,
            default_value=default_value,
            configuration_schema=configuration_schema or {},
            is_system_feature=is_system_feature,
            created_at=datetime.utcnow(),
            is_active=True
        )

    @classmethod
    def create_chat_whatsapp_feature(cls) -> "PlanFeature":
        """Create the chat_whatsapp feature."""
        return cls.create(
            name="chat_whatsapp",
            display_name="WhatsApp Chat Integration",
            description="Enable WhatsApp chat integration for customer communication",
            feature_type=FeatureType.OBJECT,
            category=FeatureCategory.COMMUNICATION,
            default_value=False,
            configuration_schema={
                "type": "object",
                "properties": {
                    "enabled": {"type": "boolean"},
                    "phone_number": {"type": "string"},
                    "webhook_url": {"type": "string"},
                    "auto_reply": {"type": "boolean"},
                    "business_hours": {
                        "type": "object",
                        "properties": {
                            "enabled": {"type": "boolean"},
                            "start_time": {"type": "string"},
                            "end_time": {"type": "string"},
                            "timezone": {"type": "string"}
                        }
                    }
                }
            },
            is_system_feature=True
        )

    @classmethod
    def create_chat_iframe_feature(cls) -> "PlanFeature":
        """Create the chat_iframe feature."""
        return cls.create(
            name="chat_iframe",
            display_name="Embeddable Chat Widget",
            description="Embed chat widget on websites using iframe",
            feature_type=FeatureType.OBJECT,
            category=FeatureCategory.COMMUNICATION,
            default_value=False,
            configuration_schema={
                "type": "object",
                "properties": {
                    "enabled": {"type": "boolean"},
                    "theme": {
                        "type": "object",
                        "properties": {
                            "primary_color": {"type": "string"},
                            "secondary_color": {"type": "string"},
                            "font_family": {"type": "string"},
                            "border_radius": {"type": "number"}
                        }
                    },
                    "position": {
                        "type": "string",
                        "enum": ["bottom-right", "bottom-left", "top-right", "top-left"]
                    },
                    "welcome_message": {"type": "string"},
                    "offline_message": {"type": "string"},
                    "allowed_domains": {
                        "type": "array",
                        "items": {"type": "string"}
                    }
                }
            },
            is_system_feature=True
        )

    def update_description(self, description: str) -> "PlanFeature":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def update_default_value(self, default_value: Any) -> "PlanFeature":
        return self.model_copy(update={
            "default_value": default_value,
            "updated_at": datetime.utcnow()
        })

    def update_configuration_schema(self, schema: Dict[str, Any]) -> "PlanFeature":
        return self.model_copy(update={
            "configuration_schema": schema,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "PlanFeature":
        if self.is_system_feature:
            raise ValueError("Cannot deactivate system features")
        
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "PlanFeature":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })

    def validate_configuration(self, config: Any) -> tuple[bool, str]:
        """Validate a configuration against the schema."""
        # Basic validation - in a real implementation, use jsonschema library
        if self.feature_type == FeatureType.BOOLEAN and not isinstance(config, bool):
            return False, "Configuration must be a boolean value"
        
        if self.feature_type == FeatureType.NUMERIC and not isinstance(config, (int, float)):
            return False, "Configuration must be a numeric value"
        
        if self.feature_type == FeatureType.STRING and not isinstance(config, str):
            return False, "Configuration must be a string value"
        
        if self.feature_type == FeatureType.OBJECT and not isinstance(config, dict):
            return False, "Configuration must be an object"
        
        return True, "Configuration is valid"

    def get_typed_default_value(self) -> Any:
        """Get default value with proper typing."""
        if self.feature_type == FeatureType.BOOLEAN:
            return bool(self.default_value) if self.default_value is not None else False
        elif self.feature_type == FeatureType.NUMERIC:
            return self.default_value if self.default_value is not None else 0
        elif self.feature_type == FeatureType.STRING:
            return str(self.default_value) if self.default_value is not None else ""
        elif self.feature_type == FeatureType.OBJECT:
            return self.default_value if self.default_value is not None else {}
        
        return self.default_value

    def is_chat_feature(self) -> bool:
        """Check if this is a chat-related feature."""
        return self.name in ["chat_whatsapp", "chat_iframe"] or self.category == FeatureCategory.COMMUNICATION
from datetime import datetime, timezone
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class PlanResourceType(str, Enum):
    CHAT_WHATSAPP = "chat_whatsapp"
    CHAT_IFRAME = "chat_iframe"
    CUSTOM = "custom"


class PlanResource(BaseModel):
    id: UUID
    plan_id: UUID
    resource_type: PlanResourceType
    configuration: Dict[str, Any]
    is_active: bool = True
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        plan_id: UUID,
        resource_type: PlanResourceType,
        configuration: Dict[str, Any]
    ) -> "PlanResource":
        return cls(
            id=uuid4(),
            plan_id=plan_id,
            resource_type=resource_type,
            configuration=configuration,
            is_active=True,
            created_at=datetime.now(timezone.utc)
        )

    @classmethod
    def create_whatsapp_resource(
        cls,
        plan_id: UUID,
        api_key: str,
        messages_per_day: int = 1000,
        webhook_url: Optional[str] = None,
        auto_reply: bool = True
    ) -> "PlanResource":
        """Create WhatsApp chat resource with standard configuration."""
        configuration = {
            "api_keys": {
                "whatsapp_api_key": api_key
            },
            "limits": {
                "messages_per_day": messages_per_day
            },
            "features": {
                "webhook_url": webhook_url,
                "auto_reply": auto_reply,
                "business_hours": True,
                "template_messages": True
            }
        }
        
        return cls.create(
            plan_id=plan_id,
            resource_type=PlanResourceType.CHAT_WHATSAPP,
            configuration=configuration
        )

    @classmethod
    def create_iframe_resource(
        cls,
        plan_id: UUID,
        api_key: str,
        concurrent_sessions: int = 50,
        custom_css: bool = False,
        custom_branding: bool = False
    ) -> "PlanResource":
        """Create iframe chat resource with standard configuration."""
        configuration = {
            "api_keys": {
                "iframe_api_key": api_key
            },
            "limits": {
                "concurrent_sessions": concurrent_sessions,
                "domains_allowed": 10
            },
            "enabled_features": [
                "basic_chat",
                "file_upload",
                "emoji_support"
            ]
        }
        
        if custom_css:
            configuration["enabled_features"].append("custom_css")
        
        if custom_branding:
            configuration["enabled_features"].extend(["custom_branding", "logo_upload"])
        
        return cls.create(
            plan_id=plan_id,
            resource_type=PlanResourceType.CHAT_IFRAME,
            configuration=configuration
        )

    def update_configuration(self, new_configuration: Dict[str, Any]) -> "PlanResource":
        """Update resource configuration."""
        merged_config = self.configuration.copy()
        merged_config.update(new_configuration)
        
        return self.model_copy(update={
            "configuration": merged_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_api_key(self, key_name: str, api_key: str) -> "PlanResource":
        """Update specific API key in configuration."""
        new_config = self.configuration.copy()
        if "api_keys" not in new_config:
            new_config["api_keys"] = {}
        
        new_config["api_keys"][key_name] = api_key
        
        return self.model_copy(update={
            "configuration": new_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_limit(self, limit_name: str, value: int) -> "PlanResource":
        """Update specific limit in configuration."""
        new_config = self.configuration.copy()
        if "limits" not in new_config:
            new_config["limits"] = {}
        
        new_config["limits"][limit_name] = value
        
        return self.model_copy(update={
            "configuration": new_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def add_enabled_feature(self, feature: str) -> "PlanResource":
        """Add feature to enabled features list."""
        new_config = self.configuration.copy()
        if "enabled_features" not in new_config:
            new_config["enabled_features"] = []
        
        if feature not in new_config["enabled_features"]:
            new_config["enabled_features"].append(feature)
        
        return self.model_copy(update={
            "configuration": new_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_enabled_feature(self, feature: str) -> "PlanResource":
        """Remove feature from enabled features list."""
        new_config = self.configuration.copy()
        if "enabled_features" in new_config and feature in new_config["enabled_features"]:
            new_config["enabled_features"].remove(feature)
        
        return self.model_copy(update={
            "configuration": new_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def activate(self) -> "PlanResource":
        """Activate resource."""
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.now(timezone.utc)
        })

    def deactivate(self) -> "PlanResource":
        """Deactivate resource."""
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.now(timezone.utc)
        })

    def get_api_key(self, key_name: str) -> Optional[str]:
        """Get specific API key from configuration."""
        api_keys = self.configuration.get("api_keys", {})
        return api_keys.get(key_name)

    def get_limit(self, limit_name: str) -> Optional[int]:
        """Get specific limit from configuration."""
        limits = self.configuration.get("limits", {})
        return limits.get(limit_name)

    def get_enabled_features(self) -> list[str]:
        """Get list of enabled features."""
        return self.configuration.get("enabled_features", [])

    def has_feature(self, feature: str) -> bool:
        """Check if specific feature is enabled."""
        return feature in self.get_enabled_features()

    def is_valid_configuration(self) -> tuple[bool, list[str]]:
        """Validate resource configuration."""
        errors = []
        
        # Validate based on resource type
        if self.resource_type == PlanResourceType.CHAT_WHATSAPP:
            if not self.get_api_key("whatsapp_api_key"):
                errors.append("WhatsApp API key is required")
            
            if not self.get_limit("messages_per_day"):
                errors.append("Messages per day limit is required")
        
        elif self.resource_type == PlanResourceType.CHAT_IFRAME:
            if not self.get_api_key("iframe_api_key"):
                errors.append("Iframe API key is required")
            
            if not self.get_limit("concurrent_sessions"):
                errors.append("Concurrent sessions limit is required")
        
        return len(errors) == 0, errors

    def get_resource_summary(self) -> Dict[str, Any]:
        """Get summary of resource configuration."""
        return {
            "id": str(self.id),
            "resource_type": self.resource_type.value,
            "is_active": self.is_active,
            "api_keys_count": len(self.configuration.get("api_keys", {})),
            "limits": self.configuration.get("limits", {}),
            "enabled_features": self.get_enabled_features(),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
from typing import Optional, Dict, Any, List, Tuple
from uuid import UUID

from ..entities.plan import Plan
from ..entities.plan_resource import PlanResource, PlanResourceType
from ..entities.plan_configuration import PlanConfiguration
from ..repositories.plan_repository import PlanRepository
from ..repositories.plan_resource_repository import PlanResourceRepository
from ..repositories.plan_configuration_repository import PlanConfigurationRepository
from ..repositories.organization_plan_repository import OrganizationPlanRepository


class PlanAuthorizationService:
    """Domain service for integrating plans with authorization system."""

    def __init__(
        self,
        plan_repository: PlanRepository,
        resource_repository: PlanResourceRepository,
        configuration_repository: PlanConfigurationRepository,
        org_plan_repository: OrganizationPlanRepository,
    ):
        self._plan_repository = plan_repository
        self._resource_repository = resource_repository
        self._configuration_repository = configuration_repository
        self._org_plan_repository = org_plan_repository

    def validate_organization_resource_access(
        self, organization_id: UUID, resource_type: str
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        """Validate if organization has access to a specific resource type."""

        # Get organization's current plan
        org_plan = self._org_plan_repository.get_by_organization_id(organization_id)
        if not org_plan or not org_plan.is_active():
            return False, "Organization has no active plan", None

        # Get plan details
        plan = self._plan_repository.get_by_id(org_plan.plan_id)
        if not plan or not plan.is_active:
            return False, "Plan is not active", None

        # Check if plan has the resource
        if not plan.has_resource(resource_type):
            return (
                False,
                f"Resource '{resource_type}' not available in current plan",
                None,
            )

        # Get resource configuration
        resource_config = plan.get_resource_config(resource_type)

        # Validate resource configuration
        is_valid, errors = plan.validate_resource_requirements(resource_type)
        if not is_valid:
            return False, f"Resource configuration invalid: {', '.join(errors)}", None

        # Apply organization-specific overrides
        effective_config = self._apply_organization_overrides(resource_config, org_plan)

        return True, "Access granted", effective_config

    def validate_api_key_requirements(
        self, organization_id: UUID, resource_type: str
    ) -> Tuple[bool, str, Optional[str]]:
        """Validate API key requirements for resource access."""

        has_access, message, config = self.validate_organization_resource_access(
            organization_id, resource_type
        )

        if not has_access:
            return False, message, None

        # Determine required API key based on resource type
        required_key = None
        if resource_type == "chat_whatsapp":
            required_key = "whatsapp_api_key"
        elif resource_type == "chat_iframe":
            required_key = "iframe_api_key"

        if not required_key:
            return True, "No API key required", None

        # Check if API key is configured
        api_keys = config.get("api_keys", {}) if config else {}
        api_key_value = api_keys.get(required_key)

        if not api_key_value:
            return False, f"Required API key '{required_key}' not configured", None

        return True, "API key validation passed", api_key_value

    def get_organization_resource_limits(
        self, organization_id: UUID, resource_type: str
    ) -> Optional[Dict[str, int]]:
        """Get effective resource limits for organization."""

        has_access, _, config = self.validate_organization_resource_access(
            organization_id, resource_type
        )

        if not has_access or not config:
            return None

        return config.get("limits", {})

    def get_organization_enabled_features(
        self, organization_id: UUID, resource_type: str
    ) -> List[str]:
        """Get enabled features for organization's resource."""

        has_access, _, config = self.validate_organization_resource_access(
            organization_id, resource_type
        )

        if not has_access or not config:
            return []

        return config.get("enabled_features", [])

    def can_organization_use_feature(
        self, organization_id: UUID, resource_type: str, feature_name: str
    ) -> bool:
        """Check if organization can use a specific feature."""

        enabled_features = self.get_organization_enabled_features(
            organization_id, resource_type
        )

        return feature_name in enabled_features

    def validate_resource_usage_limits(
        self,
        organization_id: UUID,
        resource_type: str,
        usage_type: str,
        requested_amount: int = 1,
    ) -> Tuple[bool, str, Optional[int]]:
        """Validate if organization can use resource within limits."""

        limits = self.get_organization_resource_limits(organization_id, resource_type)

        if not limits:
            return False, "No resource limits found", None

        limit_value = limits.get(usage_type)

        if limit_value is None:
            return True, "No limit set for usage type", None

        if limit_value == -1:  # Unlimited
            return True, "Unlimited usage allowed", -1

        # Here you would typically check current usage against the limit
        # For now, we'll assume the requested amount is within limits
        if requested_amount <= limit_value:
            return True, "Within usage limits", limit_value - requested_amount

        return False, f"Would exceed limit of {limit_value}", limit_value

    def get_organization_plan_summary(
        self, organization_id: UUID
    ) -> Optional[Dict[str, Any]]:
        """Get comprehensive plan summary for organization."""

        org_plan = self._org_plan_repository.get_by_organization_id(organization_id)
        if not org_plan:
            return None

        plan = self._plan_repository.get_by_id(org_plan.plan_id)
        if not plan:
            return None

        # Get all resources for the plan
        resources_summary = {}
        for resource_type in plan.resources.keys():
            has_access, message, config = self.validate_organization_resource_access(
                organization_id, resource_type
            )

            resources_summary[resource_type] = {
                "has_access": has_access,
                "message": message,
                "configuration": config,
                "enabled_features": config.get("enabled_features", [])
                if config
                else [],
                "limits": config.get("limits", {}) if config else {},
            }

        return {
            "organization_id": str(organization_id),
            "plan": {
                "id": str(plan.id),
                "name": plan.name.value,
                "type": plan.plan_type.value,
                "is_active": plan.is_active,
            },
            "subscription": {
                "id": str(org_plan.id),
                "status": org_plan.status.value,
                "is_active": org_plan.is_active(),
                "expires_at": org_plan.expires_at.isoformat()
                if org_plan.expires_at
                else None,
            },
            "resources": resources_summary,
        }

    def _apply_organization_overrides(
        self, base_config: Dict[str, Any], org_plan
    ) -> Dict[str, Any]:
        """Apply organization-specific configuration overrides."""

        effective_config = base_config.copy()

        # Apply feature overrides from organization plan
        if org_plan.feature_overrides:
            for key, value in org_plan.feature_overrides.items():
                if key in effective_config:
                    if isinstance(value, dict) and isinstance(
                        effective_config[key], dict
                    ):
                        effective_config[key].update(value)
                    else:
                        effective_config[key] = value

        # Apply limit overrides from organization plan
        if org_plan.limit_overrides:
            if "limits" not in effective_config:
                effective_config["limits"] = {}
            effective_config["limits"].update(org_plan.limit_overrides)

        return effective_config

    def create_plan_with_resources(
        self, plan_name: str, plan_type: str, resources_config: List[Dict[str, Any]]
    ) -> Plan:
        """Create a new plan with associated resources."""
        from ..entities.plan import PlanType
        from ..value_objects.pricing import Pricing, Currency
        from decimal import Decimal

        # Create plan
        plan = Plan.create(
            name=plan_name,
            description=f"{plan_type.title()} plan with resources",
            plan_type=PlanType(plan_type),
            pricing=Pricing.create_fixed(Decimal("99.00"), Currency.USD),
            resources={},
        )

        saved_plan = self._plan_repository.save(plan)

        # Create resources
        for resource_config in resources_config:
            resource_type = PlanResourceType(resource_config["resource_type"])
            configuration = resource_config["configuration"]

            resource = PlanResource.create(
                plan_id=saved_plan.id,
                resource_type=resource_type,
                configuration=configuration,
            )

            self._resource_repository.save(resource)

        # Create configuration
        api_keys = {}
        limits = {}
        enabled_features = []

        for resource_config in resources_config:
            config = resource_config["configuration"]
            if "api_keys" in config:
                api_keys.update(config["api_keys"])
            if "limits" in config:
                limits.update(config["limits"])
            if "enabled_features" in config:
                enabled_features.extend(config["enabled_features"])

        plan_configuration = PlanConfiguration.create(
            plan_id=saved_plan.id,
            api_keys=api_keys,
            limits=limits,
            enabled_features=list(set(enabled_features)),  # Remove duplicates
        )

        self._configuration_repository.save(plan_configuration)

        return saved_plan
from typing import Optional, Dict, Any, List
from uuid import UUID

from ..entities.organization_plan import (
    OrganizationPlan,
    BillingCycle,
)
from ..entities.plan import Plan
from ..repositories.organization_plan_repository import OrganizationPlanRepository
from ..repositories.plan_repository import PlanRepository


class SubscriptionService:
    """Domain service for managing organization plan subscriptions."""

    def __init__(
        self,
        org_plan_repository: OrganizationPlanRepository,
        plan_repository: PlanRepository,
    ):
        self._org_plan_repository = org_plan_repository
        self._plan_repository = plan_repository

    def subscribe_organization_to_plan(
        self,
        organization_id: UUID,
        plan_id: UUID,
        billing_cycle: BillingCycle = BillingCycle.MONTHLY,
        trial_days: int = 0,
        feature_overrides: Optional[Dict[str, Any]] = None,
        limit_overrides: Optional[Dict[str, int]] = None,
    ) -> OrganizationPlan:
        """Subscribe organization to a plan."""

        # Validate plan exists and is available
        plan = self._plan_repository.get_by_id(plan_id)
        if not plan:
            raise ValueError("Plan not found")

        if not plan.is_available_for_signup():
            raise ValueError("Plan is not available for signup")

        # Check if organization already has an active subscription
        existing_subscription = self._org_plan_repository.get_by_organization_id(
            organization_id
        )

        if existing_subscription and existing_subscription.is_active():
            raise ValueError("Organization already has an active subscription")

        # Create new subscription
        org_plan = OrganizationPlan.create(
            organization_id=organization_id,
            plan_id=plan_id,
            billing_cycle=billing_cycle,
            trial_days=trial_days,
            feature_overrides=feature_overrides,
            limit_overrides=limit_overrides,
        )

        return self._org_plan_repository.save(org_plan)

    def upgrade_organization_plan(
        self,
        organization_id: UUID,
        new_plan_id: UUID,
        effective_immediately: bool = True,
    ) -> OrganizationPlan:
        """Upgrade organization to a different plan."""

        current_subscription = self._org_plan_repository.get_by_organization_id(
            organization_id
        )
        if not current_subscription:
            raise ValueError("Organization has no active subscription")

        if not current_subscription.is_active():
            raise ValueError("Current subscription is not active")

        new_plan = self._plan_repository.get_by_id(new_plan_id)
        if not new_plan:
            raise ValueError("New plan not found")

        if not new_plan.is_available_for_signup():
            raise ValueError("New plan is not available")

        # Cancel current subscription
        cancelled_subscription = current_subscription.cancel(
            immediate=effective_immediately
        )
        self._org_plan_repository.save(cancelled_subscription)

        # Create new subscription with same billing cycle
        new_subscription = OrganizationPlan.create(
            organization_id=organization_id,
            plan_id=new_plan_id,
            billing_cycle=current_subscription.billing_cycle,
            feature_overrides=current_subscription.feature_overrides,
            limit_overrides=current_subscription.limit_overrides,
        )

        return self._org_plan_repository.save(new_subscription)

    def cancel_subscription(
        self, organization_id: UUID, immediate: bool = False, reason: str = ""
    ) -> OrganizationPlan:
        """Cancel organization subscription."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        if subscription.is_cancelled():
            raise ValueError("Subscription is already cancelled")

        cancelled_subscription = subscription.cancel(immediate=immediate)
        return self._org_plan_repository.save(cancelled_subscription)

    def renew_subscription(
        self, organization_id: UUID, periods: int = 1
    ) -> OrganizationPlan:
        """Renew organization subscription."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        renewed_subscription = subscription.renew(periods)
        return self._org_plan_repository.save(renewed_subscription)

    def suspend_subscription(
        self, organization_id: UUID, reason: str = ""
    ) -> OrganizationPlan:
        """Suspend organization subscription."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        if not subscription.is_active():
            raise ValueError("Can only suspend active subscriptions")

        suspended_subscription = subscription.suspend(reason)
        return self._org_plan_repository.save(suspended_subscription)

    def reactivate_subscription(self, organization_id: UUID) -> OrganizationPlan:
        """Reactivate suspended subscription."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        reactivated_subscription = subscription.reactivate()
        return self._org_plan_repository.save(reactivated_subscription)

    def apply_feature_override(
        self, organization_id: UUID, feature_name: str, value: Any
    ) -> OrganizationPlan:
        """Apply custom feature configuration to organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        updated_subscription = subscription.set_feature_override(feature_name, value)
        return self._org_plan_repository.save(updated_subscription)

    def apply_limit_override(
        self, organization_id: UUID, limit_name: str, value: int
    ) -> OrganizationPlan:
        """Apply custom limit to organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        updated_subscription = subscription.set_limit_override(limit_name, value)
        return self._org_plan_repository.save(updated_subscription)

    def get_organization_plan_details(
        self, organization_id: UUID
    ) -> Optional[Dict[str, Any]]:
        """Get comprehensive plan details for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            return None

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return None

        return {
            "subscription_id": str(subscription.id),
            "plan": {
                "id": str(plan.id),
                "name": plan.name.value,
                "type": plan.plan_type.value,
                "description": plan.description,
            },
            "status": subscription.status.value,
            "billing_cycle": subscription.billing_cycle.value,
            "started_at": subscription.started_at.isoformat(),
            "expires_at": subscription.expires_at.isoformat()
            if subscription.expires_at
            else None,
            "trial_ends_at": subscription.trial_ends_at.isoformat()
            if subscription.trial_ends_at
            else None,
            "auto_renew": subscription.auto_renew,
            "is_active": subscription.is_active(),
            "is_expired": subscription.is_expired(),
            "is_in_trial": subscription.is_in_trial(),
            "is_cancelled": subscription.is_cancelled(),
            "days_until_expiry": subscription.days_until_expiry(),
            "days_in_trial_remaining": subscription.days_in_trial_remaining(),
            "needs_renewal": subscription.needs_renewal(),
            "feature_overrides": subscription.feature_overrides,
            "limit_overrides": subscription.limit_overrides,
            "effective_features": self._get_effective_features(plan, subscription),
            "effective_limits": self._get_effective_limits(plan, subscription),
        }

    def _get_effective_features(
        self, plan: Plan, subscription: OrganizationPlan
    ) -> Dict[str, Any]:
        """Get effective feature configuration considering overrides."""
        effective_features = plan.features.copy()
        effective_features.update(subscription.feature_overrides)
        return effective_features

    def _get_effective_limits(
        self, plan: Plan, subscription: OrganizationPlan
    ) -> Dict[str, int]:
        """Get effective limits considering overrides."""
        effective_limits = plan.limits.copy()
        effective_limits.update(subscription.limit_overrides)
        return effective_limits

    def get_subscriptions_requiring_renewal(
        self, days_ahead: int = 7
    ) -> List[Dict[str, Any]]:
        """Get subscriptions that need renewal soon."""
        expiring_plans = self._org_plan_repository.get_expiring_plans(days_ahead)

        renewal_list = []
        for subscription in expiring_plans:
            if subscription.auto_renew and subscription.is_active():
                plan = self._plan_repository.get_by_id(subscription.plan_id)

                renewal_list.append(
                    {
                        "organization_id": str(subscription.organization_id),
                        "subscription_id": str(subscription.id),
                        "plan_name": plan.name.value if plan else "Unknown",
                        "expires_at": subscription.expires_at.isoformat()
                        if subscription.expires_at
                        else None,
                        "days_until_expiry": subscription.days_until_expiry(),
                        "billing_cycle": subscription.billing_cycle.value,
                    }
                )

        return renewal_list

    def get_trial_ending_soon(self, days_ahead: int = 3) -> List[Dict[str, Any]]:
        """Get subscriptions with trials ending soon."""
        trial_ending = self._org_plan_repository.get_trial_ending_plans(days_ahead)

        ending_list = []
        for subscription in trial_ending:
            if subscription.is_in_trial() and subscription.is_active():
                plan = self._plan_repository.get_by_id(subscription.plan_id)

                ending_list.append(
                    {
                        "organization_id": str(subscription.organization_id),
                        "subscription_id": str(subscription.id),
                        "plan_name": plan.name.value if plan else "Unknown",
                        "trial_ends_at": subscription.trial_ends_at.isoformat()
                        if subscription.trial_ends_at
                        else None,
                        "days_in_trial_remaining": subscription.days_in_trial_remaining(),
                    }
                )

        return ending_list
from typing import Dict, Any, List, Optional
from uuid import UUID

from ..entities.feature_usage import FeatureUsage, UsagePeriod
from ..repositories.feature_usage_repository import FeatureUsageRepository
from ..repositories.organization_plan_repository import OrganizationPlanRepository
from ..repositories.plan_repository import PlanRepository


class UsageTrackingService:
    """Domain service for tracking and managing feature usage."""

    def __init__(
        self,
        usage_repository: FeatureUsageRepository,
        org_plan_repository: OrganizationPlanRepository,
        plan_repository: PlanRepository,
    ):
        self._usage_repository = usage_repository
        self._org_plan_repository = org_plan_repository
        self._plan_repository = plan_repository

    def track_feature_usage(
        self,
        organization_id: UUID,
        feature_name: str,
        amount: int = 1,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> tuple[bool, str, Optional[FeatureUsage]]:
        """Track feature usage and validate against limits."""

        # Get organization subscription and plan
        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return False, "Organization has no active subscription", None

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return False, "Plan not found", None

        # Check if feature is enabled
        effective_feature_value = subscription.get_effective_feature_value(
            feature_name, plan.get_feature_config(feature_name)
        )

        if not effective_feature_value:
            return False, f"Feature '{feature_name}' is not enabled for this plan", None

        # Get current usage
        current_usage = self._usage_repository.get_current_usage(
            organization_id, feature_name, UsagePeriod.MONTHLY
        )

        # Create usage record if doesn't exist
        if not current_usage:
            limit_value = subscription.get_effective_limit_value(
                f"monthly_{feature_name}", plan.get_limit(f"monthly_{feature_name}")
            )

            current_usage = FeatureUsage.create(
                organization_id=organization_id,
                feature_name=feature_name,
                usage_period=UsagePeriod.MONTHLY,
                limit_value=limit_value,
            )
            current_usage = self._usage_repository.save(current_usage)

        # Check if usage would exceed limit
        can_use, reason = current_usage.can_use_feature(amount)
        if not can_use:
            return False, reason, current_usage

        # Increment usage
        updated_usage = self._usage_repository.increment_usage(
            organization_id, feature_name, amount, metadata
        )

        return True, "Usage tracked successfully", updated_usage

    def get_organization_usage_summary(self, organization_id: UUID) -> Dict[str, Any]:
        """Get comprehensive usage summary for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            return {"error": "No active subscription found"}

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return {"error": "Plan not found"}

        # Get current usage for all features
        usage_records = self._usage_repository.get_organization_usage(organization_id)

        summary = {
            "organization_id": str(organization_id),
            "plan": {"name": plan.name.value, "type": plan.plan_type.value},
            "billing_period": {
                "cycle": subscription.billing_cycle.value,
                "started_at": subscription.started_at.isoformat(),
                "expires_at": subscription.expires_at.isoformat()
                if subscription.expires_at
                else None,
            },
            "features": {},
            "overall_status": "healthy",
        }

        # Process each usage record
        for usage in usage_records:
            if usage.is_current_period():
                feature_summary = usage.get_usage_summary()
                summary["features"][usage.feature_name] = feature_summary

                # Update overall status based on usage
                if usage.is_limit_exceeded():
                    summary["overall_status"] = "over_limit"
                elif usage.is_limit_near() and summary["overall_status"] == "healthy":
                    summary["overall_status"] = "approaching_limit"

        return summary

    def check_feature_access(
        self, organization_id: UUID, feature_name: str, requested_amount: int = 1
    ) -> tuple[bool, str, Dict[str, Any]]:
        """Check if organization can use a feature."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return False, "No active subscription", {}

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return False, "Plan not found", {}

        # Check if feature is enabled in plan
        effective_feature_value = subscription.get_effective_feature_value(
            feature_name, plan.get_feature_config(feature_name)
        )

        if not effective_feature_value:
            return (
                False,
                f"Feature '{feature_name}' not available in current plan",
                {"upgrade_required": True, "current_plan": plan.name.value},
            )

        # Check usage limits
        current_usage = self._usage_repository.get_current_usage(
            organization_id, feature_name, UsagePeriod.MONTHLY
        )

        if current_usage:
            can_use, reason = current_usage.can_use_feature(requested_amount)

            if not can_use:
                return (
                    False,
                    reason,
                    {
                        "current_usage": current_usage.current_usage,
                        "limit": current_usage.limit_value,
                        "usage_percentage": current_usage.get_usage_percentage(),
                        "days_until_reset": current_usage.days_until_reset(),
                        "upgrade_recommended": current_usage.is_limit_near(0.9),
                    },
                )

        return (
            True,
            "Feature access granted",
            {
                "remaining_usage": current_usage.get_remaining_usage()
                if current_usage
                else -1
            },
        )

    def get_usage_analytics(
        self, organization_id: UUID, feature_name: str, periods: int = 12
    ) -> Dict[str, Any]:
        """Get usage analytics and trends."""

        trends = self._usage_repository.get_usage_trends(
            organization_id, feature_name, periods
        )

        current_usage = self._usage_repository.get_current_usage(
            organization_id, feature_name, UsagePeriod.MONTHLY
        )

        analytics = {
            "feature_name": feature_name,
            "trends": trends,
            "current_period": current_usage.get_usage_summary()
            if current_usage
            else None,
            "insights": [],
        }

        # Generate insights
        if trends and len(trends) > 1:
            # Calculate growth trend
            recent_usage = [t["usage"] for t in trends[-3:]]
            if len(recent_usage) >= 2:
                growth_rate = (
                    (recent_usage[-1] - recent_usage[0]) / max(recent_usage[0], 1) * 100
                )

                if growth_rate > 50:
                    analytics["insights"].append(
                        {
                            "type": "high_growth",
                            "message": f"Usage has grown by {growth_rate:.1f}% in recent periods",
                        }
                    )
                elif growth_rate < -20:
                    analytics["insights"].append(
                        {
                            "type": "declining_usage",
                            "message": f"Usage has declined by {abs(growth_rate):.1f}% in recent periods",
                        }
                    )

        # Add limit warnings
        if current_usage and current_usage.is_limit_near(0.8):
            analytics["insights"].append(
                {
                    "type": "approaching_limit",
                    "message": f"Currently at {current_usage.get_usage_percentage():.1f}% of monthly limit",
                }
            )

        return analytics

    def reset_monthly_usage(self, organization_id: UUID) -> Dict[str, int]:
        """Reset monthly usage for organization (typically called by scheduler)."""

        usage_records = self._usage_repository.get_organization_usage(organization_id)
        reset_counts = {}

        for usage in usage_records:
            if usage.usage_period == UsagePeriod.MONTHLY and usage.is_period_expired():
                reset_usage = self._usage_repository.reset_usage_for_period(
                    organization_id, usage.feature_name, UsagePeriod.MONTHLY
                )

                if reset_usage:
                    reset_counts[usage.feature_name] = usage.current_usage

        return reset_counts

    def get_organizations_near_limits(
        self, threshold_percent: float = 0.8
    ) -> List[Dict[str, Any]]:
        """Get organizations approaching their usage limits."""

        near_limit_orgs = []

        # Get organizations exceeding threshold for various features
        feature_names = ["monthly_messages", "monthly_api_calls", "storage_mb"]

        for feature_name in feature_names:
            org_ids = self._usage_repository.get_organizations_exceeding_limit(
                feature_name, threshold_percent
            )

            for org_id in org_ids:
                usage = self._usage_repository.get_current_usage(
                    org_id, feature_name, UsagePeriod.MONTHLY
                )

                if usage:
                    near_limit_orgs.append(
                        {
                            "organization_id": str(org_id),
                            "feature_name": feature_name,
                            "usage_percentage": usage.get_usage_percentage(),
                            "current_usage": usage.current_usage,
                            "limit": usage.limit_value,
                            "days_until_reset": usage.days_until_reset(),
                        }
                    )

        return near_limit_orgs
from typing import List, Dict, Any, Optional
from uuid import UUID
from decimal import Decimal

from ..entities.plan import Plan, PlanType
from ..entities.plan_feature import PlanFeature
from ..repositories.plan_repository import PlanRepository
from ..repositories.plan_feature_repository import PlanFeatureRepository
from ..repositories.organization_plan_repository import OrganizationPlanRepository
from ..value_objects.pricing import Pricing


class PlanManagementService:
    """Domain service for managing plans and features."""

    def __init__(
        self,
        plan_repository: PlanRepository,
        feature_repository: PlanFeatureRepository,
        org_plan_repository: OrganizationPlanRepository,
    ):
        self._plan_repository = plan_repository
        self._feature_repository = feature_repository
        self._org_plan_repository = org_plan_repository

    def create_standard_plans(self) -> List[Plan]:
        """Create standard system plans (Free, Basic, Premium, Enterprise)."""
        plans = []

        # Free Plan
        free_plan = Plan.create(
            name="Free",
            description="Basic features for getting started",
            plan_type=PlanType.FREE,
            pricing=Pricing.create_free(),
            max_users=5,
            max_organizations=1,
        )
        plans.append(self._plan_repository.save(free_plan))

        # Basic Plan
        basic_plan = Plan.create(
            name="Basic",
            description="Essential features for small teams",
            plan_type=PlanType.BASIC,
            pricing=Pricing.create_per_user(
                base_amount=Decimal("29.00"),
                per_user_amount=Decimal("5.00"),
                free_user_count=2,
            ),
            max_users=25,
            max_organizations=3,
        )
        plans.append(self._plan_repository.save(basic_plan))

        # Premium Plan
        premium_plan = Plan.create(
            name="Premium",
            description="Advanced features for growing businesses",
            plan_type=PlanType.PREMIUM,
            pricing=Pricing.create_per_user(
                base_amount=Decimal("79.00"),
                per_user_amount=Decimal("8.00"),
                free_user_count=5,
            ),
            max_users=100,
            max_organizations=10,
        )
        plans.append(self._plan_repository.save(premium_plan))

        # Enterprise Plan
        enterprise_plan = Plan.create(
            name="Enterprise",
            description="Full features for large organizations",
            plan_type=PlanType.ENTERPRISE,
            pricing=Pricing.create_per_user(
                base_amount=Decimal("199.00"),
                per_user_amount=Decimal("12.00"),
                free_user_count=10,
            ),
            max_users=1000,
            max_organizations=50,
        )
        plans.append(self._plan_repository.save(enterprise_plan))

        return plans

    def create_system_features(self) -> List[PlanFeature]:
        """Create standard system features."""
        features = []

        # Create WhatsApp chat feature
        whatsapp_feature = PlanFeature.create_chat_whatsapp_feature()
        features.append(self._feature_repository.save(whatsapp_feature))

        # Create iframe chat feature
        iframe_feature = PlanFeature.create_chat_iframe_feature()
        features.append(self._feature_repository.save(iframe_feature))

        return features

    def can_plan_be_deleted(self, plan_id: UUID) -> tuple[bool, str]:
        """Check if plan can be safely deleted."""
        plan = self._plan_repository.get_by_id(plan_id)

        if not plan:
            return False, "Plan not found"

        # Check if plan has active subscriptions
        active_subscriptions = self._org_plan_repository.count_active_subscriptions(
            plan_id
        )

        if active_subscriptions > 0:
            return (
                False,
                f"Plan has {active_subscriptions} active subscriptions and cannot be deleted",
            )

        return True, "Plan can be deleted"

    def validate_plan_upgrade(
        self, current_plan_id: UUID, target_plan_id: UUID, organization_users: int
    ) -> tuple[bool, str]:
        """Validate if organization can upgrade to target plan."""
        current_plan = self._plan_repository.get_by_id(current_plan_id)
        target_plan = self._plan_repository.get_by_id(target_plan_id)

        if not current_plan:
            return False, "Current plan not found"

        if not target_plan:
            return False, "Target plan not found"

        if not target_plan.is_available_for_signup():
            return False, "Target plan is not available for signup"

        # Check if target plan can support current user count
        if not target_plan.can_support_users(organization_users):
            return (
                False,
                f"Target plan supports max {target_plan.max_users} users, but organization has {organization_users}",
            )

        # Prevent downgrade (optional business rule)
        plan_hierarchy = {
            PlanType.FREE: 0,
            PlanType.BASIC: 1,
            PlanType.PREMIUM: 2,
            PlanType.ENTERPRISE: 3,
        }

        current_level = plan_hierarchy.get(current_plan.plan_type, 0)
        target_level = plan_hierarchy.get(target_plan.plan_type, 0)

        if target_level < current_level:
            return False, "Downgrading plans is not allowed. Please contact support."

        return True, "Plan upgrade is valid"

    def calculate_plan_cost_comparison(
        self, plan_ids: List[UUID], user_count: int = 1
    ) -> Dict[str, Dict[str, Any]]:
        """Calculate and compare costs for multiple plans."""
        comparison = {}

        for plan_id in plan_ids:
            plan = self._plan_repository.get_by_id(plan_id)

            if plan:
                monthly_cost = plan.pricing.calculate_monthly_cost(user_count)
                yearly_cost = plan.pricing.calculate_yearly_cost(user_count)
                setup_cost = plan.pricing.calculate_setup_cost()

                comparison[str(plan_id)] = {
                    "plan_name": plan.name.value,
                    "plan_type": plan.plan_type.value,
                    "monthly_cost": float(monthly_cost),
                    "yearly_cost": float(yearly_cost),
                    "setup_cost": float(setup_cost),
                    "yearly_savings": float(monthly_cost * 12 - yearly_cost),
                    "cost_per_user": float(plan.pricing.per_user_amount or 0),
                    "pricing_description": plan.pricing.get_pricing_description(),
                    "features": plan.features,
                    "limits": plan.limits,
                }

        return comparison

    def get_plan_feature_matrix(self) -> Dict[str, Dict[str, Any]]:
        """Get feature comparison matrix for all public plans."""
        public_plans = self._plan_repository.get_public_plans()
        features = self._feature_repository.get_active_features()

        matrix = {}

        for plan in public_plans:
            plan_features = {}

            for feature in features:
                feature_value = plan.get_feature_config(feature.name)
                plan_features[feature.name] = {
                    "enabled": bool(feature_value),
                    "config": feature_value,
                    "display_name": feature.display_name,
                    "description": feature.description,
                }

            matrix[plan.name.value] = {
                "plan_id": str(plan.id),
                "plan_type": plan.plan_type.value,
                "pricing": plan.pricing.get_pricing_description(),
                "max_users": plan.max_users,
                "features": plan_features,
                "limits": plan.limits,
            }

        return matrix

    def recommend_plan_for_organization(
        self,
        user_count: int,
        required_features: List[str],
        budget_monthly: Optional[Decimal] = None,
    ) -> List[Dict[str, Any]]:
        """Recommend plans based on requirements."""
        public_plans = self._plan_repository.get_public_plans()
        recommendations = []

        for plan in public_plans:
            # Check user capacity
            if not plan.can_support_users(user_count):
                continue

            # Check required features
            missing_features = []
            for feature in required_features:
                if not plan.is_feature_enabled(feature):
                    missing_features.append(feature)

            # Calculate cost
            monthly_cost = plan.pricing.calculate_monthly_cost(user_count)

            # Check budget constraint
            within_budget = budget_monthly is None or monthly_cost <= budget_monthly

            score = 0
            # Higher score for plans that meet all requirements
            if not missing_features:
                score += 50

            # Higher score for plans within budget
            if within_budget:
                score += 30

            # Lower score for more expensive plans (prefer cheaper when possible)
            if budget_monthly and monthly_cost <= budget_monthly * Decimal("0.8"):
                score += 20

            recommendations.append(
                {
                    "plan_id": str(plan.id),
                    "plan_name": plan.name.value,
                    "plan_type": plan.plan_type.value,
                    "monthly_cost": float(monthly_cost),
                    "missing_features": missing_features,
                    "within_budget": within_budget,
                    "score": score,
                    "reason": self._get_recommendation_reason(
                        plan, missing_features, within_budget
                    ),
                }
            )

        # Sort by score (highest first)
        recommendations.sort(key=lambda x: x["score"], reverse=True)

        return recommendations[:3]  # Return top 3 recommendations

    def _get_recommendation_reason(
        self, plan: Plan, missing_features: List[str], within_budget: bool
    ) -> str:
        """Generate recommendation reason text."""
        if not missing_features and within_budget:
            return f"Perfect match! {plan.name.value} includes all required features within budget."

        if not missing_features:
            return f"{plan.name.value} includes all required features but may be over budget."

        if within_budget:
            feature_text = "features" if len(missing_features) > 1 else "feature"
            return f"{plan.name.value} is within budget but missing {len(missing_features)} {feature_text}."

        return f"{plan.name.value} is missing features and over budget."
from .plan_management_service import PlanManagementService
from .subscription_service import SubscriptionService
from .usage_tracking_service import UsageTrackingService
from .feature_access_service import FeatureAccessService
from .plan_authorization_service import PlanAuthorizationService

__all__ = [
    "PlanManagementService",
    "SubscriptionService", 
    "UsageTrackingService",
    "FeatureAccessService",
    "PlanAuthorizationService"
]
from typing import Dict, Any, Optional, List
from uuid import UUID

from ..entities.organization_plan import OrganizationPlan
from ..repositories.organization_plan_repository import OrganizationPlanRepository
from ..repositories.plan_repository import PlanRepository
from ..value_objects.chat_configuration import (
    ChatWhatsAppConfiguration,
    ChatIframeConfiguration,
)


class FeatureAccessService:
    """Domain service for managing feature access and configurations."""

    def __init__(
        self,
        org_plan_repository: OrganizationPlanRepository,
        plan_repository: PlanRepository,
    ):
        self._org_plan_repository = org_plan_repository
        self._plan_repository = plan_repository

    def has_feature_access(
        self, organization_id: UUID, feature_name: str
    ) -> tuple[bool, str]:
        """Check if organization has access to a specific feature."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return False, "No active subscription"

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return False, "Plan not found"

        # Check effective feature value (plan + overrides)
        effective_value = subscription.get_effective_feature_value(
            feature_name, plan.get_feature_config(feature_name)
        )

        if not effective_value:
            return False, f"Feature '{feature_name}' not available in current plan"

        return True, "Feature access granted"

    def get_chat_whatsapp_config(
        self, organization_id: UUID
    ) -> Optional[ChatWhatsAppConfiguration]:
        """Get WhatsApp chat configuration for organization."""

        has_access, _ = self.has_feature_access(organization_id, "chat_whatsapp")
        if not has_access:
            return None

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            return None

        # Get configuration from feature overrides or default
        config_data = subscription.feature_overrides.get("chat_whatsapp")

        if isinstance(config_data, dict):
            try:
                return ChatWhatsAppConfiguration(**config_data)
            except Exception:
                # Return default config if custom config is invalid
                return ChatWhatsAppConfiguration.create_default()

        return ChatWhatsAppConfiguration.create_default()

    def update_chat_whatsapp_config(
        self, organization_id: UUID, config: ChatWhatsAppConfiguration
    ) -> OrganizationPlan:
        """Update WhatsApp chat configuration for organization."""

        has_access, reason = self.has_feature_access(organization_id, "chat_whatsapp")
        if not has_access:
            raise ValueError(f"Cannot update WhatsApp config: {reason}")

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("No active subscription found")

        # Validate configuration
        is_valid, issues = config.is_properly_configured()
        if not is_valid:
            raise ValueError(f"Invalid WhatsApp configuration: {', '.join(issues)}")

        # Update feature override
        updated_subscription = subscription.set_feature_override(
            "chat_whatsapp", config.model_dump()
        )

        return self._org_plan_repository.save(updated_subscription)

    def get_chat_iframe_config(
        self, organization_id: UUID
    ) -> Optional[ChatIframeConfiguration]:
        """Get iframe chat configuration for organization."""

        has_access, _ = self.has_feature_access(organization_id, "chat_iframe")
        if not has_access:
            return None

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            return None

        # Get configuration from feature overrides or default
        config_data = subscription.feature_overrides.get("chat_iframe")

        if isinstance(config_data, dict):
            try:
                return ChatIframeConfiguration(**config_data)
            except Exception:
                # Return default config if custom config is invalid
                return ChatIframeConfiguration.create_default()

        return ChatIframeConfiguration.create_default()

    def update_chat_iframe_config(
        self, organization_id: UUID, config: ChatIframeConfiguration
    ) -> OrganizationPlan:
        """Update iframe chat configuration for organization."""

        has_access, reason = self.has_feature_access(organization_id, "chat_iframe")
        if not has_access:
            raise ValueError(f"Cannot update iframe chat config: {reason}")

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("No active subscription found")

        # Update feature override
        updated_subscription = subscription.set_feature_override(
            "chat_iframe", config.model_dump()
        )

        return self._org_plan_repository.save(updated_subscription)

    def get_feature_configurations(self, organization_id: UUID) -> Dict[str, Any]:
        """Get all feature configurations for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return {}

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return {}

        configurations = {}

        # Chat WhatsApp
        if subscription.get_effective_feature_value(
            "chat_whatsapp", plan.get_feature_config("chat_whatsapp")
        ):
            whatsapp_config = self.get_chat_whatsapp_config(organization_id)
            if whatsapp_config:
                configurations["chat_whatsapp"] = whatsapp_config.model_dump()

        # Chat Iframe
        if subscription.get_effective_feature_value(
            "chat_iframe", plan.get_feature_config("chat_iframe")
        ):
            iframe_config = self.get_chat_iframe_config(organization_id)
            if iframe_config:
                configurations["chat_iframe"] = iframe_config.model_dump()

        return configurations

    def get_available_features(self, organization_id: UUID) -> List[Dict[str, Any]]:
        """Get list of available features for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return []

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return []

        available_features = []

        # Process each feature
        for feature_name, plan_config in plan.features.items():
            effective_config = subscription.get_effective_feature_value(
                feature_name, plan_config
            )

            if effective_config:
                feature_info = {
                    "name": feature_name,
                    "enabled": bool(effective_config),
                    "config": effective_config,
                    "overridden": feature_name in subscription.feature_overrides,
                }

                # Add specific information for chat features
                if feature_name == "chat_whatsapp":
                    config = self.get_chat_whatsapp_config(organization_id)
                    feature_info["configuration_status"] = (
                        "configured" if config and config.enabled else "not_configured"
                    )

                elif feature_name == "chat_iframe":
                    config = self.get_chat_iframe_config(organization_id)
                    feature_info["configuration_status"] = (
                        "configured" if config and config.enabled else "not_configured"
                    )

                available_features.append(feature_info)

        return available_features

    def validate_feature_requirements(
        self, organization_id: UUID, required_features: List[str]
    ) -> Dict[str, Any]:
        """Validate if organization has access to all required features."""

        validation_result = {
            "all_requirements_met": True,
            "available_features": [],
            "missing_features": [],
            "upgrade_required": False,
        }

        for feature_name in required_features:
            has_access, reason = self.has_feature_access(organization_id, feature_name)

            if has_access:
                validation_result["available_features"].append(feature_name)
            else:
                validation_result["missing_features"].append(
                    {"feature": feature_name, "reason": reason}
                )
                validation_result["all_requirements_met"] = False
                validation_result["upgrade_required"] = True

        return validation_result

    def get_iframe_embed_code(
        self, organization_id: UUID, chat_endpoint: str
    ) -> Optional[str]:
        """Generate iframe embed code for organization."""

        config = self.get_chat_iframe_config(organization_id)
        if not config or not config.enabled:
            return None

        return config.get_embed_code(str(organization_id), chat_endpoint)

    def is_domain_allowed_for_iframe(self, organization_id: UUID, domain: str) -> bool:
        """Check if domain is allowed to embed iframe chat."""

        config = self.get_chat_iframe_config(organization_id)
        if not config or not config.enabled:
            return False

        return config.is_domain_allowed(domain)

    def enable_feature_for_organization(
        self, organization_id: UUID, feature_name: str, config: Optional[Any] = None
    ) -> OrganizationPlan:
        """Enable a feature for organization with custom configuration."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("No active subscription found")

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            raise ValueError("Plan not found")

        # Check if feature exists in plan (even if disabled)
        if feature_name not in plan.features:
            raise ValueError(f"Feature '{feature_name}' not available in current plan")

        # Set feature override to enable it
        feature_config = config if config is not None else True
        updated_subscription = subscription.set_feature_override(
            feature_name, feature_config
        )

        return self._org_plan_repository.save(updated_subscription)

    def disable_feature_for_organization(
        self, organization_id: UUID, feature_name: str
    ) -> OrganizationPlan:
        """Disable a feature for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("No active subscription found")

        # Set feature override to disable it
        updated_subscription = subscription.set_feature_override(feature_name, False)

        return self._org_plan_repository.save(updated_subscription)
from pydantic import BaseModel, field_validator
from typing import Any
import re


class PlanName(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Plan name cannot be empty")
        
        cleaned_name = v.strip()
        
        if len(cleaned_name) < 2:
            raise ValueError("Plan name must be at least 2 characters long")
        
        if len(cleaned_name) > 50:
            raise ValueError("Plan name cannot exceed 50 characters")
        
        # Allow letters, numbers, spaces, hyphens, and underscores
        if not re.match(r'^[a-zA-Z0-9\s\-_]+$', cleaned_name):
            raise ValueError("Plan name can only contain letters, numbers, spaces, hyphens, and underscores")
        
        return cleaned_name

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, PlanName):
            return self.value == other.value
        return False

    def to_slug(self) -> str:
        """Convert name to URL-friendly slug."""
        return re.sub(r'[^a-zA-Z0-9\-_]', '-', self.value.lower()).strip('-')

    def to_identifier(self) -> str:
        """Convert name to programming identifier format."""
        return re.sub(r'[^a-zA-Z0-9_]', '_', self.value.lower()).strip('_')

    def is_system_plan(self) -> bool:
        """Check if this is a system plan name."""
        system_plans = ["free", "basic", "premium", "enterprise"]
        return self.to_identifier() in system_plans
from decimal import Decimal
from pydantic import BaseModel, field_validator
from typing import Optional
from enum import Enum


class Currency(str, Enum):
    USD = "USD"
    EUR = "EUR"
    BRL = "BRL"
    GBP = "GBP"


class PricingModel(str, Enum):
    FIXED = "fixed"
    PER_USER = "per_user"
    USAGE_BASED = "usage_based"
    TIERED = "tiered"


class Pricing(BaseModel):
    amount: Decimal
    currency: Currency
    model: PricingModel
    setup_fee: Decimal = Decimal("0.00")
    per_user_amount: Optional[Decimal] = None
    free_user_count: int = 0

    model_config = {"frozen": True}

    @field_validator('amount', 'setup_fee', 'per_user_amount')
    @classmethod
    def validate_amounts(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        if v is None:
            return v
        
        if v < 0:
            raise ValueError("Amount cannot be negative")
        
        if v > Decimal("999999.99"):
            raise ValueError("Amount cannot exceed 999,999.99")
        
        # Ensure proper decimal precision (2 decimal places)
        return v.quantize(Decimal("0.01"))

    @field_validator('free_user_count')
    @classmethod
    def validate_free_user_count(cls, v: int) -> int:
        if v < 0:
            raise ValueError("Free user count cannot be negative")
        
        if v > 1000:
            raise ValueError("Free user count cannot exceed 1000")
        
        return v

    @classmethod
    def create_fixed(
        cls, 
        amount: Decimal, 
        currency: Currency = Currency.USD,
        setup_fee: Decimal = Decimal("0.00")
    ) -> "Pricing":
        return cls(
            amount=amount,
            currency=currency,
            model=PricingModel.FIXED,
            setup_fee=setup_fee
        )

    @classmethod
    def create_per_user(
        cls,
        base_amount: Decimal,
        per_user_amount: Decimal,
        currency: Currency = Currency.USD,
        free_user_count: int = 0,
        setup_fee: Decimal = Decimal("0.00")
    ) -> "Pricing":
        return cls(
            amount=base_amount,
            currency=currency,
            model=PricingModel.PER_USER,
            per_user_amount=per_user_amount,
            free_user_count=free_user_count,
            setup_fee=setup_fee
        )

    @classmethod
    def create_free(cls) -> "Pricing":
        return cls(
            amount=Decimal("0.00"),
            currency=Currency.USD,
            model=PricingModel.FIXED,
            setup_fee=Decimal("0.00")
        )

    def calculate_total_cost(self, user_count: int = 1) -> Decimal:
        """Calculate total cost based on pricing model and user count."""
        total = self.amount
        
        if self.model == PricingModel.PER_USER and self.per_user_amount:
            # Calculate billable users (subtract free users)
            billable_users = max(0, user_count - self.free_user_count)
            total += self.per_user_amount * billable_users
        
        return total

    def calculate_setup_cost(self) -> Decimal:
        """Get setup cost."""
        return self.setup_fee

    def calculate_monthly_cost(self, user_count: int = 1) -> Decimal:
        """Calculate monthly cost (alias for total cost)."""
        return self.calculate_total_cost(user_count)

    def calculate_yearly_cost(self, user_count: int = 1) -> Decimal:
        """Calculate yearly cost with potential discount."""
        monthly_cost = self.calculate_total_cost(user_count)
        # Apply 10% discount for yearly billing
        yearly_cost = monthly_cost * 12 * Decimal("0.9")
        return yearly_cost.quantize(Decimal("0.01"))

    def is_free(self) -> bool:
        """Check if pricing is free."""
        return self.amount == Decimal("0.00") and self.setup_fee == Decimal("0.00")

    def has_setup_fee(self) -> bool:
        """Check if pricing has setup fee."""
        return self.setup_fee > Decimal("0.00")

    def is_per_user_pricing(self) -> bool:
        """Check if pricing is per-user based."""
        return self.model == PricingModel.PER_USER

    def format_amount(self, amount: Decimal) -> str:
        """Format amount with currency."""
        symbol_map = {
            Currency.USD: "$",
            Currency.EUR: "€",
            Currency.BRL: "R$",
            Currency.GBP: "£"
        }
        
        symbol = symbol_map.get(self.currency, self.currency.value)
        return f"{symbol}{amount:,.2f}"

    def format_price(self, user_count: int = 1) -> str:
        """Format complete price string."""
        total = self.calculate_total_cost(user_count)
        formatted = self.format_amount(total)
        
        if self.model == PricingModel.PER_USER and user_count > 1:
            formatted += f" ({user_count} users)"
        
        return formatted

    def get_pricing_description(self) -> str:
        """Get human-readable pricing description."""
        if self.is_free():
            return "Free"
        
        base_price = self.format_amount(self.amount)
        
        if self.model == PricingModel.FIXED:
            return f"{base_price}/month"
        
        elif self.model == PricingModel.PER_USER:
            if self.amount > 0:
                desc = f"{base_price} base"
            else:
                desc = ""
            
            if self.per_user_amount:
                user_price = self.format_amount(self.per_user_amount)
                if desc:
                    desc += f" + {user_price}/user/month"
                else:
                    desc = f"{user_price}/user/month"
            
            if self.free_user_count > 0:
                desc += f" (first {self.free_user_count} users free)"
            
            return desc
        
        return f"{base_price}/month"

    def to_dict(self) -> dict:
        """Convert to dictionary representation."""
        return {
            "amount": float(self.amount),
            "currency": self.currency.value,
            "model": self.model.value,
            "setup_fee": float(self.setup_fee),
            "per_user_amount": float(self.per_user_amount) if self.per_user_amount else None,
            "free_user_count": self.free_user_count
        }
from .plan_name import PlanName
from .pricing import Pricing
from .chat_configuration import ChatWhatsAppConfiguration, ChatIframeConfiguration

__all__ = ["PlanName", "Pricing", "ChatWhatsAppConfiguration", "ChatIframeConfiguration"]
from pydantic import BaseModel, field_validator
from typing import Optional, List, Dict, Any
import re


class BusinessHours(BaseModel):
    enabled: bool = False
    start_time: str = "09:00"
    end_time: str = "17:00"
    timezone: str = "UTC"

    model_config = {"frozen": True}

    @field_validator('start_time', 'end_time')
    @classmethod
    def validate_time_format(cls, v: str) -> str:
        if not re.match(r'^([01]?[0-9]|2[0-3]):[0-5][0-9]$', v):
            raise ValueError("Time must be in HH:MM format")
        return v

    @field_validator('timezone')
    @classmethod
    def validate_timezone(cls, v: str) -> str:
        # Basic timezone validation - in production, use pytz or zoneinfo
        if not v or len(v) > 50:
            raise ValueError("Invalid timezone")
        return v


class ChatWhatsAppConfiguration(BaseModel):
    enabled: bool = False
    phone_number: Optional[str] = None
    webhook_url: Optional[str] = None
    auto_reply: bool = True
    business_hours: BusinessHours = BusinessHours()
    welcome_message: str = "Hello! How can we help you today?"
    away_message: str = "We're currently away. Please leave a message and we'll get back to you soon."

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @field_validator('phone_number')
    @classmethod
    def validate_phone_number(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        
        # Remove common phone number formatting
        cleaned = re.sub(r'[^\d+]', '', v)
        
        if not re.match(r'^\+?[1-9]\d{1,14}$', cleaned):
            raise ValueError("Invalid phone number format")
        
        return cleaned

    @field_validator('webhook_url')
    @classmethod
    def validate_webhook_url(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        
        if not re.match(r'^https?://.+', v):
            raise ValueError("Webhook URL must be a valid HTTP/HTTPS URL")
        
        return v

    @field_validator('welcome_message', 'away_message')
    @classmethod
    def validate_messages(cls, v: str) -> str:
        if len(v) > 500:
            raise ValueError("Message cannot exceed 500 characters")
        return v.strip()

    @classmethod
    def create_default(cls) -> "ChatWhatsAppConfiguration":
        return cls()

    def enable(self, phone_number: str, webhook_url: Optional[str] = None) -> "ChatWhatsAppConfiguration":
        return self.model_copy(update={
            "enabled": True,
            "phone_number": phone_number,
            "webhook_url": webhook_url
        })

    def disable(self) -> "ChatWhatsAppConfiguration":
        return self.model_copy(update={"enabled": False})

    def update_business_hours(self, business_hours: BusinessHours) -> "ChatWhatsAppConfiguration":
        return self.model_copy(update={"business_hours": business_hours})

    def update_messages(self, welcome: Optional[str] = None, away: Optional[str] = None) -> "ChatWhatsAppConfiguration":
        updates = {}
        if welcome is not None:
            updates["welcome_message"] = welcome
        if away is not None:
            updates["away_message"] = away
        
        return self.model_copy(update=updates)

    def is_properly_configured(self) -> tuple[bool, List[str]]:
        """Check if configuration is valid and complete."""
        issues = []
        
        if self.enabled:
            if not self.phone_number:
                issues.append("Phone number is required when WhatsApp chat is enabled")
            
            if self.business_hours.enabled:
                try:
                    start_hour, start_min = map(int, self.business_hours.start_time.split(':'))
                    end_hour, end_min = map(int, self.business_hours.end_time.split(':'))
                    
                    start_minutes = start_hour * 60 + start_min
                    end_minutes = end_hour * 60 + end_min
                    
                    if start_minutes >= end_minutes:
                        issues.append("Business hours start time must be before end time")
                
                except ValueError:
                    issues.append("Invalid business hours time format")
        
        return len(issues) == 0, issues


class ChatTheme(BaseModel):
    primary_color: str = "#007bff"
    secondary_color: str = "#6c757d"
    font_family: str = "Arial, sans-serif"
    border_radius: int = 8

    model_config = {"frozen": True}

    @field_validator('primary_color', 'secondary_color')
    @classmethod
    def validate_color(cls, v: str) -> str:
        if not re.match(r'^#[0-9a-fA-F]{6}$', v):
            raise ValueError("Color must be a valid hex color (e.g., #007bff)")
        return v.lower()

    @field_validator('border_radius')
    @classmethod
    def validate_border_radius(cls, v: int) -> int:
        if not 0 <= v <= 50:
            raise ValueError("Border radius must be between 0 and 50 pixels")
        return v


class ChatIframeConfiguration(BaseModel):
    enabled: bool = False
    theme: ChatTheme = ChatTheme()
    position: str = "bottom-right"
    welcome_message: str = "Hi there! How can we help you?"
    offline_message: str = "We're currently offline. Please leave a message."
    allowed_domains: List[str] = []
    show_agent_avatar: bool = True
    show_timestamps: bool = True
    enable_file_upload: bool = False
    enable_emoji: bool = True

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @field_validator('position')
    @classmethod
    def validate_position(cls, v: str) -> str:
        valid_positions = ["bottom-right", "bottom-left", "top-right", "top-left"]
        if v not in valid_positions:
            raise ValueError(f"Position must be one of: {', '.join(valid_positions)}")
        return v

    @field_validator('welcome_message', 'offline_message')
    @classmethod
    def validate_messages(cls, v: str) -> str:
        if len(v) > 200:
            raise ValueError("Message cannot exceed 200 characters")
        return v.strip()

    @field_validator('allowed_domains')
    @classmethod
    def validate_domains(cls, v: List[str]) -> List[str]:
        validated_domains = []
        
        for domain in v:
            # Basic domain validation
            if not re.match(r'^[a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?)*$', domain):
                raise ValueError(f"Invalid domain format: {domain}")
            validated_domains.append(domain.lower())
        
        return validated_domains

    @classmethod
    def create_default(cls) -> "ChatIframeConfiguration":
        return cls()

    def enable(self, allowed_domains: Optional[List[str]] = None) -> "ChatIframeConfiguration":
        return self.model_copy(update={
            "enabled": True,
            "allowed_domains": allowed_domains or []
        })

    def disable(self) -> "ChatIframeConfiguration":
        return self.model_copy(update={"enabled": False})

    def update_theme(self, theme: ChatTheme) -> "ChatIframeConfiguration":
        return self.model_copy(update={"theme": theme})

    def add_allowed_domain(self, domain: str) -> "ChatIframeConfiguration":
        if domain.lower() not in [d.lower() for d in self.allowed_domains]:
            new_domains = self.allowed_domains + [domain.lower()]
            return self.model_copy(update={"allowed_domains": new_domains})
        return self

    def remove_allowed_domain(self, domain: str) -> "ChatIframeConfiguration":
        new_domains = [d for d in self.allowed_domains if d.lower() != domain.lower()]
        return self.model_copy(update={"allowed_domains": new_domains})

    def update_position(self, position: str) -> "ChatIframeConfiguration":
        return self.model_copy(update={"position": position})

    def update_messages(self, welcome: Optional[str] = None, offline: Optional[str] = None) -> "ChatIframeConfiguration":
        updates = {}
        if welcome is not None:
            updates["welcome_message"] = welcome
        if offline is not None:
            updates["offline_message"] = offline
        
        return self.model_copy(update=updates)

    def is_domain_allowed(self, domain: str) -> bool:
        """Check if a domain is allowed to embed the chat."""
        if not self.allowed_domains:  # Empty list means all domains allowed
            return True
        
        return domain.lower() in [d.lower() for d in self.allowed_domains]

    def get_embed_code(self, organization_id: str, chat_endpoint: str) -> str:
        """Generate iframe embed code."""
        params = {
            "org": organization_id,
            "theme": self.theme.primary_color.replace("#", ""),
            "position": self.position
        }
        
        param_string = "&".join([f"{k}={v}" for k, v in params.items()])
        
        return f'''<iframe 
    src="{chat_endpoint}?{param_string}" 
    width="350" 
    height="500" 
    frameborder="0"
    style="position: fixed; {self._get_position_style()}; z-index: 9999;">
</iframe>'''

    def _get_position_style(self) -> str:
        """Get CSS positioning style based on position setting."""
        positions = {
            "bottom-right": "bottom: 20px; right: 20px;",
            "bottom-left": "bottom: 20px; left: 20px;",
            "top-right": "top: 20px; right: 20px;",
            "top-left": "top: 20px; left: 20px;"
        }
        return positions.get(self.position, positions["bottom-right"])

    def to_client_config(self) -> Dict[str, Any]:
        """Get configuration safe for client-side use."""
        return {
            "theme": {
                "primaryColor": self.theme.primary_color,
                "secondaryColor": self.theme.secondary_color,
                "fontFamily": self.theme.font_family,
                "borderRadius": self.theme.border_radius
            },
            "position": self.position,
            "welcomeMessage": self.welcome_message,
            "offlineMessage": self.offline_message,
            "showAgentAvatar": self.show_agent_avatar,
            "showTimestamps": self.show_timestamps,
            "enableFileUpload": self.enable_file_upload,
            "enableEmoji": self.enable_emoji
        }
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.plan import Plan, PlanType, PlanStatus
from ..value_objects.plan_name import PlanName


class PlanRepository(ABC):
    """Plan repository interface for the Plans bounded context."""
    
    @abstractmethod
     def save(self, plan: Plan) -> Plan:
        """Save or update a plan."""
        pass
    
    @abstractmethod
     def get_by_id(self, plan_id: UUID) -> Optional[Plan]:
        """Get plan by ID."""
        pass
    
    @abstractmethod
     def get_by_name(self, name: PlanName) -> Optional[Plan]:
        """Get plan by name."""
        pass
    
    @abstractmethod
     def get_by_type(self, plan_type: PlanType) -> List[Plan]:
        """Get plans by type."""
        pass
    
    @abstractmethod
     def get_public_plans(self) -> List[Plan]:
        """Get all public plans available for signup."""
        pass
    
    @abstractmethod
     def get_active_plans(self) -> List[Plan]:
        """Get all active plans."""
        pass
    
    @abstractmethod
     def exists_by_name(self, name: PlanName) -> bool:
        """Check if plan exists by name."""
        pass
    
    @abstractmethod
     def delete(self, plan_id: UUID) -> bool:
        """Delete plan by ID."""
        pass
    
    @abstractmethod
     def list_plans(
        self, 
        status: Optional[PlanStatus] = None,
        is_public: Optional[bool] = None,
        limit: int = 100, 
        offset: int = 0
    ) -> List[Plan]:
        """List plans with filtering and pagination."""
        pass
    
    @abstractmethod
     def count_plans(self, status: Optional[PlanStatus] = None) -> int:
        """Count plans by status."""
        pass
    
    @abstractmethod
     def get_plans_with_resource(self, resource_type: str) -> List[Plan]:
        """Get plans that have a specific resource enabled."""
        pass
    
    @abstractmethod
     def assign_to_organization(self, plan_id: UUID, organization_id: UUID) -> bool:
        """Assign plan to organization."""
        pass
    
    @abstractmethod
     def validate_plan_resources(self, plan_id: UUID) -> tuple[bool, List[str]]:
        """Validate that plan resources have required configurations."""
        pass
    
    @abstractmethod
     def get_plans_requiring_api_key(self, api_key_name: str) -> List[Plan]:
        """Get plans that require a specific API key."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
from uuid import UUID
from datetime import datetime

from ..entities.feature_usage import FeatureUsage, UsagePeriod


class FeatureUsageRepository(ABC):
    """Feature usage repository interface for the Plans bounded context."""
    
    @abstractmethod
     def save(self, feature_usage: FeatureUsage) -> FeatureUsage:
        """Save or update feature usage."""
        pass
    
    @abstractmethod
     def get_by_id(self, usage_id: UUID) -> Optional[FeatureUsage]:
        """Get feature usage by ID."""
        pass
    
    @abstractmethod
     def get_current_usage(
        self, 
        organization_id: UUID, 
        feature_name: str,
        period: UsagePeriod
    ) -> Optional[FeatureUsage]:
        """Get current usage for organization and feature."""
        pass
    
    @abstractmethod
     def get_organization_usage(
        self, 
        organization_id: UUID,
        period_start: Optional[datetime] = None,
        period_end: Optional[datetime] = None
    ) -> List[FeatureUsage]:
        """Get all usage records for an organization."""
        pass
    
    @abstractmethod
     def get_feature_usage_across_organizations(
        self, 
        feature_name: str,
        period: UsagePeriod,
        period_start: Optional[datetime] = None
    ) -> List[FeatureUsage]:
        """Get usage for a specific feature across all organizations."""
        pass
    
    @abstractmethod
     def get_organizations_exceeding_limit(
        self, 
        feature_name: str,
        threshold_percent: float = 0.8
    ) -> List[UUID]:
        """Get organizations exceeding usage threshold for a feature."""
        pass
    
    @abstractmethod
     def increment_usage(
        self, 
        organization_id: UUID, 
        feature_name: str,
        amount: int = 1,
        metadata: Optional[Dict[str, Any]] = None
    ) -> FeatureUsage:
        """Increment usage for organization and feature."""
        pass
    
    @abstractmethod
     def reset_usage_for_period(
        self, 
        organization_id: UUID, 
        feature_name: str,
        period: UsagePeriod
    ) -> bool:
        """Reset usage for new billing period."""
        pass
    
    @abstractmethod
     def delete(self, usage_id: UUID) -> bool:
        """Delete usage record by ID."""
        pass
    
    @abstractmethod
     def delete_old_records(self, older_than_days: int = 365) -> int:
        """Delete usage records older than specified days."""
        pass
    
    @abstractmethod
     def get_usage_summary(
        self, 
        organization_id: UUID,
        period_start: datetime,
        period_end: datetime
    ) -> Dict[str, Dict[str, Any]]:
        """Get usage summary for organization within period."""
        pass
    
    @abstractmethod
     def get_usage_trends(
        self, 
        organization_id: UUID,
        feature_name: str,
        periods: int = 12
    ) -> List[Dict[str, Any]]:
        """Get usage trends for feature over specified periods."""
        pass
    
    @abstractmethod
     def bulk_reset_monthly_usage(self) -> int:
        """Reset monthly usage for all organizations at month end."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID
from datetime import datetime

from ..entities.organization_plan import OrganizationPlan, SubscriptionStatus


class OrganizationPlanRepository(ABC):
    """Organization plan repository interface for the Plans bounded context."""
    
    @abstractmethod
     def save(self, organization_plan: OrganizationPlan) -> OrganizationPlan:
        """Save or update an organization plan."""
        pass
    
    @abstractmethod
     def get_by_id(self, organization_plan_id: UUID) -> Optional[OrganizationPlan]:
        """Get organization plan by ID."""
        pass
    
    @abstractmethod
     def get_by_organization_id(self, organization_id: UUID) -> Optional[OrganizationPlan]:
        """Get current plan for an organization."""
        pass
    
    @abstractmethod
     def get_organization_plan_history(self, organization_id: UUID) -> List[OrganizationPlan]:
        """Get plan history for an organization."""
        pass
    
    @abstractmethod
     def get_by_plan_id(self, plan_id: UUID) -> List[OrganizationPlan]:
        """Get all organizations using a specific plan."""
        pass
    
    @abstractmethod
     def get_expiring_plans(self, days_ahead: int = 7) -> List[OrganizationPlan]:
        """Get plans expiring within specified days."""
        pass
    
    @abstractmethod
     def get_trial_ending_plans(self, days_ahead: int = 3) -> List[OrganizationPlan]:
        """Get plans with trials ending within specified days."""
        pass
    
    @abstractmethod
     def get_by_status(self, status: SubscriptionStatus) -> List[OrganizationPlan]:
        """Get organization plans by status."""
        pass
    
    @abstractmethod
     def delete(self, organization_plan_id: UUID) -> bool:
        """Delete organization plan by ID."""
        pass
    
    @abstractmethod
     def count_active_subscriptions(self, plan_id: Optional[UUID] = None) -> int:
        """Count active subscriptions, optionally filtered by plan."""
        pass
    
    @abstractmethod
     def get_organizations_with_feature(
        self, 
        feature_name: str, 
        enabled: bool = True
    ) -> List[UUID]:
        """Get organization IDs that have a specific feature enabled/disabled."""
        pass
    
    @abstractmethod
     def cleanup_expired_plans(self) -> int:
        """Update status of expired plans. Returns count of updated plans."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.plan_feature import PlanFeature, FeatureCategory, FeatureType


class PlanFeatureRepository(ABC):
    """Plan feature repository interface for the Plans bounded context."""
    
    @abstractmethod
     def save(self, feature: PlanFeature) -> PlanFeature:
        """Save or update a plan feature."""
        pass
    
    @abstractmethod
     def get_by_id(self, feature_id: UUID) -> Optional[PlanFeature]:
        """Get feature by ID."""
        pass
    
    @abstractmethod
     def get_by_name(self, name: str) -> Optional[PlanFeature]:
        """Get feature by name."""
        pass
    
    @abstractmethod
     def get_by_category(self, category: FeatureCategory) -> List[PlanFeature]:
        """Get features by category."""
        pass
    
    @abstractmethod
     def get_by_type(self, feature_type: FeatureType) -> List[PlanFeature]:
        """Get features by type."""
        pass
    
    @abstractmethod
     def get_active_features(self) -> List[PlanFeature]:
        """Get all active features."""
        pass
    
    @abstractmethod
     def get_system_features(self) -> List[PlanFeature]:
        """Get all system features."""
        pass
    
    @abstractmethod
     def exists_by_name(self, name: str) -> bool:
        """Check if feature exists by name."""
        pass
    
    @abstractmethod
     def delete(self, feature_id: UUID) -> bool:
        """Delete feature by ID."""
        pass
    
    @abstractmethod
     def list_features(
        self, 
        category: Optional[FeatureCategory] = None,
        is_active: Optional[bool] = None,
        limit: int = 100, 
        offset: int = 0
    ) -> List[PlanFeature]:
        """List features with filtering and pagination."""
        pass
    
    @abstractmethod
     def search_features(self, query: str, limit: int = 100) -> List[PlanFeature]:
        """Search features by name or description."""
        pass
    
    @abstractmethod
     def count_features(
        self, 
        category: Optional[FeatureCategory] = None,
        is_active: Optional[bool] = None
    ) -> int:
        """Count features with optional filtering."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
from uuid import UUID

from ..entities.plan_resource import PlanResource, PlanResourceType


class PlanResourceRepository(ABC):
    """Plan resource repository interface for the Plans bounded context."""
    
    @abstractmethod
     def save(self, plan_resource: PlanResource) -> PlanResource:
        """Save or update a plan resource."""
        pass
    
    @abstractmethod
     def get_by_id(self, resource_id: UUID) -> Optional[PlanResource]:
        """Get plan resource by ID."""
        pass
    
    @abstractmethod
     def get_by_plan_id(self, plan_id: UUID) -> List[PlanResource]:
        """Get all resources for a plan."""
        pass
    
    @abstractmethod
     def get_by_plan_and_type(
        self, 
        plan_id: UUID, 
        resource_type: PlanResourceType
    ) -> Optional[PlanResource]:
        """Get specific resource type for a plan."""
        pass
    
    @abstractmethod
     def get_by_resource_type(self, resource_type: PlanResourceType) -> List[PlanResource]:
        """Get all resources of a specific type."""
        pass
    
    @abstractmethod
     def get_active_resources(self, plan_id: UUID) -> List[PlanResource]:
        """Get all active resources for a plan."""
        pass
    
    @abstractmethod
     def delete(self, resource_id: UUID) -> bool:
        """Delete plan resource by ID."""
        pass
    
    @abstractmethod
     def delete_by_plan_id(self, plan_id: UUID) -> int:
        """Delete all resources for a plan. Returns count of deleted resources."""
        pass
    
    @abstractmethod
     def exists_by_plan_and_type(
        self, 
        plan_id: UUID, 
        resource_type: PlanResourceType
    ) -> bool:
        """Check if plan has specific resource type."""
        pass
    
    @abstractmethod
     def update_configuration(
        self, 
        resource_id: UUID, 
        configuration: Dict[str, Any]
    ) -> Optional[PlanResource]:
        """Update resource configuration."""
        pass
    
    @abstractmethod
     def activate_resource(self, resource_id: UUID) -> bool:
        """Activate a resource."""
        pass
    
    @abstractmethod
     def deactivate_resource(self, resource_id: UUID) -> bool:
        """Deactivate a resource."""
        pass
    
    @abstractmethod
     def list_resources(
        self, 
        resource_type: Optional[PlanResourceType] = None,
        is_active: Optional[bool] = None,
        limit: int = 100, 
        offset: int = 0
    ) -> List[PlanResource]:
        """List plan resources with filtering and pagination."""
        pass
    
    @abstractmethod
     def count_resources(
        self, 
        resource_type: Optional[PlanResourceType] = None,
        is_active: Optional[bool] = None
    ) -> int:
        """Count plan resources with optional filtering."""
        pass
    
    @abstractmethod
     def get_resources_with_api_key(self, api_key_name: str) -> List[PlanResource]:
        """Get resources that have a specific API key configured."""
        pass
    
    @abstractmethod
     def validate_api_key_uniqueness(
        self, 
        api_key_name: str, 
        api_key_value: str,
        excluding_resource_id: Optional[UUID] = None
    ) -> bool:
        """Check if API key value is unique across resources."""
        pass
from .plan_repository import PlanRepository
from .plan_resource_repository import PlanResourceRepository
from .plan_configuration_repository import PlanConfigurationRepository
from .organization_plan_repository import OrganizationPlanRepository
from .feature_usage_repository import FeatureUsageRepository
from .plan_feature_repository import PlanFeatureRepository

__all__ = [
    "PlanRepository", 
    "PlanResourceRepository",
    "PlanConfigurationRepository",
    "OrganizationPlanRepository", 
    "FeatureUsageRepository",
    "PlanFeatureRepository"
]
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
from uuid import UUID

from ..entities.plan_configuration import PlanConfiguration


class PlanConfigurationRepository(ABC):
    """Plan configuration repository interface for the Plans bounded context."""

    @abstractmethod
    def save(self, plan_configuration: PlanConfiguration) -> PlanConfiguration:
        """Save or update a plan configuration."""
        pass

    @abstractmethod
    def get_by_id(self, configuration_id: UUID) -> Optional[PlanConfiguration]:
        """Get plan configuration by ID."""
        pass

    @abstractmethod
    def get_by_plan_id(self, plan_id: UUID) -> Optional[PlanConfiguration]:
        """Get configuration for a plan."""
        pass

    @abstractmethod
    def get_active_configurations(self) -> List[PlanConfiguration]:
        """Get all active plan configurations."""
        pass

    @abstractmethod
    def delete(self, configuration_id: UUID) -> bool:
        """Delete plan configuration by ID."""
        pass

    @abstractmethod
    def delete_by_plan_id(self, plan_id: UUID) -> bool:
        """Delete configuration for a plan."""
        pass

    @abstractmethod
    def exists_by_plan_id(self, plan_id: UUID) -> bool:
        """Check if plan has configuration."""
        pass

    @abstractmethod
    def update_api_keys(
        self, configuration_id: UUID, api_keys: Dict[str, str]
    ) -> Optional[PlanConfiguration]:
        """Update API keys in configuration."""
        pass

    @abstractmethod
    def update_limits(
        self, configuration_id: UUID, limits: Dict[str, int]
    ) -> Optional[PlanConfiguration]:
        """Update limits in configuration."""
        pass

    @abstractmethod
    def update_enabled_features(
        self, configuration_id: UUID, enabled_features: List[str]
    ) -> Optional[PlanConfiguration]:
        """Update enabled features in configuration."""
        pass

    @abstractmethod
    def activate_configuration(self, configuration_id: UUID) -> bool:
        """Activate a configuration."""
        pass

    @abstractmethod
    def deactivate_configuration(self, configuration_id: UUID) -> bool:
        """Deactivate a configuration."""
        pass

    @abstractmethod
    def list_configurations(
        self, is_active: Optional[bool] = None, limit: int = 100, offset: int = 0
    ) -> List[PlanConfiguration]:
        """List plan configurations with filtering and pagination."""
        pass

    @abstractmethod
    def count_configurations(self, is_active: Optional[bool] = None) -> int:
        """Count plan configurations with optional filtering."""
        pass

    @abstractmethod
    def get_configurations_with_feature(
        self, feature_name: str
    ) -> List[PlanConfiguration]:
        """Get configurations that have a specific feature enabled."""
        pass

    @abstractmethod
    def get_configurations_with_api_key(
        self, api_key_name: str
    ) -> List[PlanConfiguration]:
        """Get configurations that have a specific API key."""
        pass

    @abstractmethod
    def validate_api_key_uniqueness(
        self,
        api_key_name: str,
        api_key_value: str,
        excluding_configuration_id: Optional[UUID] = None,
    ) -> bool:
        """Check if API key value is unique across configurations."""
        pass

    @abstractmethod
    def bulk_update_configurations(
        self, updates: List[Dict[str, Any]]
    ) -> List[PlanConfiguration]:
        """Bulk update multiple configurations."""
        pass
from .entities import (
    Plan, PlanType, PlanFeature, PlanResource, PlanResourceType, 
    PlanConfiguration, OrganizationPlan, FeatureUsage
)
from .value_objects import (
    PlanName, Pricing, ChatWhatsAppConfiguration, ChatIframeConfiguration
)
from .repositories import (
    PlanRepository, PlanResourceRepository, PlanConfigurationRepository,
    OrganizationPlanRepository, FeatureUsageRepository, PlanFeatureRepository
)
from .services import (
    PlanManagementService, SubscriptionService, UsageTrackingService, 
    FeatureAccessService, PlanAuthorizationService
)

__all__ = [
    # Entities
    "Plan", "PlanType", "PlanFeature", "PlanResource", "PlanResourceType",
    "PlanConfiguration", "OrganizationPlan", "FeatureUsage",
    
    # Value Objects
    "PlanName", "Pricing", "ChatWhatsAppConfiguration", "ChatIframeConfiguration",
    
    # Repositories
    "PlanRepository", "PlanResourceRepository", "PlanConfigurationRepository",
    "OrganizationPlanRepository", "FeatureUsageRepository", "PlanFeatureRepository",
    
    # Services
    "PlanManagementService", "SubscriptionService", "UsageTrackingService", 
    "FeatureAccessService", "PlanAuthorizationService"
]
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, field_validator

from ...domain.entities.plan_resource import PlanResourceType


class PlanResourceCreateDTO(BaseModel):
    """DTO for creating a new plan resource."""
    plan_id: UUID = Field(..., description="Plan ID")
    resource_type: PlanResourceType = Field(..., description="Resource type")
    configuration: Dict[str, Any] = Field(..., description="Resource configuration")
    is_enabled: bool = Field(True, description="Whether resource is enabled")
    
    @field_validator('configuration')
    @classmethod
    def validate_configuration(cls, v: Dict[str, Any], info) -> Dict[str, Any]:
        resource_type = info.data.get('resource_type')
        
        if resource_type == PlanResourceType.CHAT_WHATSAPP:
            required_fields = ['api_key', 'webhook_url', 'phone_number']
            for field in required_fields:
                if field not in v:
                    raise ValueError(f"WhatsApp configuration missing required field: {field}")
        
        elif resource_type == PlanResourceType.CHAT_IFRAME:
            required_fields = ['iframe_url', 'allowed_domains']
            for field in required_fields:
                if field not in v:
                    raise ValueError(f"Iframe configuration missing required field: {field}")
        
        return v


class PlanResourceUpdateDTO(BaseModel):
    """DTO for updating an existing plan resource."""
    configuration: Optional[Dict[str, Any]] = Field(None, description="Resource configuration")
    is_enabled: Optional[bool] = Field(None, description="Whether resource is enabled")
    
    @field_validator('configuration')
    @classmethod
    def validate_configuration(cls, v: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        if v is None:
            return v
        
        # Basic validation - specific validation will be done in use case
        if not isinstance(v, dict):
            raise ValueError("Configuration must be a dictionary")
        
        return v


class PlanResourceResponseDTO(BaseModel):
    """DTO for plan resource response data."""
    id: UUID
    plan_id: UUID
    plan_name: str
    resource_type: str
    configuration: Dict[str, Any]
    is_enabled: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    usage_count: int  # Number of times this resource has been used
    
    model_config = {"from_attributes": True}


class PlanResourceListResponseDTO(BaseModel):
    """DTO for paginated plan resource list response."""
    resources: List[PlanResourceResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class PlanResourceTestDTO(BaseModel):
    """DTO for testing plan resource configuration."""
    plan_id: UUID = Field(..., description="Plan ID")
    resource_type: PlanResourceType = Field(..., description="Resource type")
    test_configuration: Dict[str, Any] = Field(..., description="Configuration to test")
    test_parameters: Dict[str, Any] = Field(default_factory=dict, description="Test parameters")


class PlanResourceTestResponseDTO(BaseModel):
    """DTO for plan resource test response."""
    success: bool
    resource_type: str
    test_results: Dict[str, Any]
    error_message: Optional[str] = None
    performance_metrics: Dict[str, float] = Field(default_factory=dict)
    recommendations: List[str] = Field(default_factory=list)


class PlanResourceUsageDTO(BaseModel):
    """DTO for plan resource usage data."""
    resource_id: UUID
    organization_id: UUID
    resource_type: str
    usage_date: datetime
    usage_count: int
    usage_details: Dict[str, Any] = Field(default_factory=dict)
    cost: Optional[float] = None


class PlanResourceUsageResponseDTO(BaseModel):
    """DTO for plan resource usage response."""
    resource_id: UUID
    resource_type: str
    total_usage: int
    usage_period: str
    usage_breakdown: Dict[str, Any]
    cost_breakdown: Dict[str, float]
    usage_trends: List[Dict[str, Any]] = Field(default_factory=list)
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from enum import Enum

from ...domain.entities.plan import PlanType


class PlanCreateDTO(BaseModel):
    """DTO for creating a new plan."""
    name: str = Field(..., min_length=2, max_length=100, description="Plan name")
    description: str = Field(..., max_length=500, description="Plan description")
    plan_type: PlanType = Field(..., description="Plan type")
    resources: Dict[str, Any] = Field(default_factory=dict, description="Plan resources configuration")
    price_monthly: Optional[float] = Field(None, ge=0, description="Monthly price")
    price_yearly: Optional[float] = Field(None, ge=0, description="Yearly price")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Plan name cannot be empty')
        return v.strip()
    
    @field_validator('resources')
    @classmethod
    def validate_resources(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        # Validate resource structure for known resource types
        for resource_type, config in v.items():
            if resource_type in ['chat_whatsapp', 'chat_iframe']:
                if not isinstance(config, dict):
                    raise ValueError(f"Resource {resource_type} must be a dictionary")
                if 'enabled' not in config:
                    raise ValueError(f"Resource {resource_type} must have 'enabled' field")
        return v


class PlanUpdateDTO(BaseModel):
    """DTO for updating an existing plan."""
    description: Optional[str] = Field(None, max_length=500, description="Plan description")
    resources: Optional[Dict[str, Any]] = Field(None, description="Plan resources configuration")
    price_monthly: Optional[float] = Field(None, ge=0, description="Monthly price")
    price_yearly: Optional[float] = Field(None, ge=0, description="Yearly price")
    
    @field_validator('resources')
    @classmethod
    def validate_resources(cls, v: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        if v is None:
            return v
        
        # Validate resource structure for known resource types
        for resource_type, config in v.items():
            if resource_type in ['chat_whatsapp', 'chat_iframe']:
                if not isinstance(config, dict):
                    raise ValueError(f"Resource {resource_type} must be a dictionary")
                if 'enabled' not in config:
                    raise ValueError(f"Resource {resource_type} must have 'enabled' field")
        return v


class PlanResponseDTO(BaseModel):
    """DTO for plan response data."""
    id: UUID
    name: str
    description: str
    plan_type: str
    resources: Dict[str, Any]
    price_monthly: Optional[float] = None
    price_yearly: Optional[float] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool
    subscription_count: int  # Number of active subscriptions
    
    model_config = {"from_attributes": True}


class PlanListResponseDTO(BaseModel):
    """DTO for paginated plan list response."""
    plans: List[PlanResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class PlanResourceConfigDTO(BaseModel):
    """DTO for plan resource configuration."""
    resource_type: str = Field(..., description="Resource type (e.g., chat_whatsapp, chat_iframe)")
    enabled: bool = Field(..., description="Whether resource is enabled")
    configuration: Dict[str, Any] = Field(default_factory=dict, description="Resource-specific configuration")
    limits: Dict[str, Any] = Field(default_factory=dict, description="Resource limits")


class PlanValidationRequestDTO(BaseModel):
    """DTO for plan validation request."""
    organization_id: UUID = Field(..., description="Organization ID")
    plan_id: UUID = Field(..., description="Plan ID")
    resource_type: str = Field(..., description="Resource type to validate")
    action: str = Field(..., description="Action to validate")
    context: Dict[str, Any] = Field(default_factory=dict, description="Additional context")


class PlanValidationResponseDTO(BaseModel):
    """DTO for plan validation response."""
    is_allowed: bool
    plan_name: str
    resource_type: str
    action: str
    reason: str
    current_usage: Optional[Dict[str, Any]] = None
    limits: Optional[Dict[str, Any]] = None
    suggestions: List[str] = Field(default_factory=list)
from datetime import datetime
from typing import Optional, List
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from enum import Enum


class SubscriptionStatusEnum(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class BillingCycleEnum(str, Enum):
    MONTHLY = "monthly"
    YEARLY = "yearly"


class SubscriptionCreateDTO(BaseModel):
    """DTO for creating a new subscription."""
    organization_id: UUID = Field(..., description="Organization ID")
    plan_id: UUID = Field(..., description="Plan ID")
    billing_cycle: BillingCycleEnum = Field(..., description="Billing cycle")
    starts_at: Optional[datetime] = Field(None, description="Subscription start date")
    metadata: dict = Field(default_factory=dict, description="Additional metadata")
    
    @field_validator('starts_at')
    @classmethod
    def validate_starts_at(cls, v: Optional[datetime]) -> Optional[datetime]:
        if v and v < datetime.now():
            raise ValueError('Subscription start date cannot be in the past')
        return v


class SubscriptionUpdateDTO(BaseModel):
    """DTO for updating an existing subscription."""
    billing_cycle: Optional[BillingCycleEnum] = Field(None, description="Billing cycle")
    ends_at: Optional[datetime] = Field(None, description="Subscription end date")
    metadata: Optional[dict] = Field(None, description="Additional metadata")


class SubscriptionResponseDTO(BaseModel):
    """DTO for subscription response data."""
    id: UUID
    organization_id: UUID
    plan_id: UUID
    plan_name: str
    plan_type: str
    status: str
    billing_cycle: str
    starts_at: datetime
    ends_at: Optional[datetime] = None
    next_billing_date: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    metadata: dict
    is_trial: bool = False
    
    model_config = {"from_attributes": True}


class SubscriptionListResponseDTO(BaseModel):
    """DTO for paginated subscription list response."""
    subscriptions: List[SubscriptionResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class SubscriptionUpgradeDTO(BaseModel):
    """DTO for subscription upgrade request."""
    new_plan_id: UUID = Field(..., description="New plan ID")
    billing_cycle: Optional[BillingCycleEnum] = Field(None, description="Billing cycle for new plan")
    upgrade_immediately: bool = Field(True, description="Whether to upgrade immediately")
    prorate: bool = Field(True, description="Whether to prorate the charges")


class SubscriptionDowngradeDTO(BaseModel):
    """DTO for subscription downgrade request."""
    new_plan_id: UUID = Field(..., description="New plan ID")
    billing_cycle: Optional[BillingCycleEnum] = Field(None, description="Billing cycle for new plan")
    downgrade_at_period_end: bool = Field(True, description="Whether to downgrade at the end of current period")


class SubscriptionCancellationDTO(BaseModel):
    """DTO for subscription cancellation request."""
    cancel_immediately: bool = Field(False, description="Whether to cancel immediately")
    cancellation_reason: Optional[str] = Field(None, max_length=500, description="Reason for cancellation")
    feedback: Optional[str] = Field(None, max_length=1000, description="User feedback")
from .plan_dto import (
    PlanCreateDTO, PlanUpdateDTO, PlanResponseDTO, PlanListResponseDTO,
    PlanResourceConfigDTO, PlanValidationRequestDTO, PlanValidationResponseDTO
)
from .subscription_dto import (
    SubscriptionCreateDTO, SubscriptionUpdateDTO, SubscriptionResponseDTO,
    SubscriptionListResponseDTO, SubscriptionUpgradeDTO, SubscriptionDowngradeDTO,
    SubscriptionCancellationDTO
)
from .plan_resource_dto import (
    PlanResourceCreateDTO, PlanResourceUpdateDTO, PlanResourceResponseDTO,
    PlanResourceListResponseDTO, PlanResourceTestDTO, PlanResourceTestResponseDTO,
    PlanResourceUsageDTO, PlanResourceUsageResponseDTO
)

__all__ = [
    # Plan DTOs
    "PlanCreateDTO", "PlanUpdateDTO", "PlanResponseDTO", "PlanListResponseDTO",
    "PlanResourceConfigDTO", "PlanValidationRequestDTO", "PlanValidationResponseDTO",
    
    # Subscription DTOs
    "SubscriptionCreateDTO", "SubscriptionUpdateDTO", "SubscriptionResponseDTO",
    "SubscriptionListResponseDTO", "SubscriptionUpgradeDTO", "SubscriptionDowngradeDTO",
    "SubscriptionCancellationDTO",
    
    # Plan Resource DTOs
    "PlanResourceCreateDTO", "PlanResourceUpdateDTO", "PlanResourceResponseDTO",
    "PlanResourceListResponseDTO", "PlanResourceTestDTO", "PlanResourceTestResponseDTO",
    "PlanResourceUsageDTO", "PlanResourceUsageResponseDTO"
]
from .dtos import (
    # Plan DTOs
    PlanCreateDTO, PlanUpdateDTO, PlanResponseDTO, PlanListResponseDTO,
    PlanResourceConfigDTO, PlanValidationRequestDTO, PlanValidationResponseDTO,
    
    # Subscription DTOs
    SubscriptionCreateDTO, SubscriptionUpdateDTO, SubscriptionResponseDTO,
    SubscriptionListResponseDTO, SubscriptionUpgradeDTO, SubscriptionDowngradeDTO,
    SubscriptionCancellationDTO,
    
    # Plan Resource DTOs
    PlanResourceCreateDTO, PlanResourceUpdateDTO, PlanResourceResponseDTO,
    PlanResourceListResponseDTO, PlanResourceTestDTO, PlanResourceTestResponseDTO,
    PlanResourceUsageDTO, PlanResourceUsageResponseDTO
)
from .use_cases import PlanUseCase, SubscriptionUseCase, PlanResourceUseCase

__all__ = [
    # DTOs
    "PlanCreateDTO", "PlanUpdateDTO", "PlanResponseDTO", "PlanListResponseDTO",
    "PlanResourceConfigDTO", "PlanValidationRequestDTO", "PlanValidationResponseDTO",
    "SubscriptionCreateDTO", "SubscriptionUpdateDTO", "SubscriptionResponseDTO",
    "SubscriptionListResponseDTO", "SubscriptionUpgradeDTO", "SubscriptionDowngradeDTO",
    "SubscriptionCancellationDTO",
    "PlanResourceCreateDTO", "PlanResourceUpdateDTO", "PlanResourceResponseDTO",
    "PlanResourceListResponseDTO", "PlanResourceTestDTO", "PlanResourceTestResponseDTO",
    "PlanResourceUsageDTO", "PlanResourceUsageResponseDTO",
    
    # Use Cases
    "PlanUseCase", "SubscriptionUseCase", "PlanResourceUseCase"
]
from datetime import datetime, timezone, timedelta
from typing import List, Optional
from uuid import UUID

from ...domain.entities.subscription import Subscription
from ...domain.repositories.subscription_repository import SubscriptionRepository
from ...domain.repositories.plan_repository import PlanRepository
from ...domain.services.subscription_service import SubscriptionService
from ..dtos.subscription_dto import (
    SubscriptionCreateDTO, SubscriptionUpdateDTO, SubscriptionResponseDTO,
    SubscriptionListResponseDTO, SubscriptionUpgradeDTO, SubscriptionDowngradeDTO,
    SubscriptionCancellationDTO
)


class SubscriptionUseCase:
    """Use case for subscription management operations."""
    
    def __init__(
        self,
        subscription_repository: SubscriptionRepository,
        plan_repository: PlanRepository,
        subscription_service: SubscriptionService
    ):
        self.subscription_repository = subscription_repository
        self.plan_repository = plan_repository
        self.subscription_service = subscription_service
    
     def create_subscription(self, dto: SubscriptionCreateDTO) -> SubscriptionResponseDTO:
        """Create a new subscription."""
        # Validate plan exists
        plan =  self.plan_repository.find_by_id(dto.plan_id)
        if not plan:
            raise ValueError("Plan not found")
        
        if not plan.is_active:
            raise ValueError("Plan is not active")
        
        # Check if organization already has an active subscription
        existing_subscription =  self.subscription_repository.find_active_by_organization(
            dto.organization_id
        )
        if existing_subscription:
            raise ValueError("Organization already has an active subscription")
        
        # Create subscription
        subscription =  self.subscription_service.create_subscription(
            organization_id=dto.organization_id,
            plan_id=dto.plan_id,
            billing_cycle=dto.billing_cycle,
            starts_at=dto.starts_at or datetime.now(timezone.utc),
            metadata=dto.metadata
        )
        
        return  self._build_subscription_response(subscription)
    
     def get_subscription_by_id(self, subscription_id: UUID) -> Optional[SubscriptionResponseDTO]:
        """Get subscription by ID."""
        subscription =  self.subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None
        
        return  self._build_subscription_response(subscription)
    
     def update_subscription(
        self,
        subscription_id: UUID,
        dto: SubscriptionUpdateDTO
    ) -> Optional[SubscriptionResponseDTO]:
        """Update an existing subscription."""
        subscription =  self.subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None
        
        # Update fields
        if dto.billing_cycle is not None:
            subscription.billing_cycle = dto.billing_cycle
        if dto.ends_at is not None:
            subscription.ends_at = dto.ends_at
        if dto.metadata is not None:
            subscription.metadata.update(dto.metadata)
        
        subscription.updated_at = datetime.now(timezone.utc)
        
        # Recalculate next billing date if billing cycle changed
        if dto.billing_cycle is not None:
            subscription.next_billing_date = self.subscription_service.calculate_next_billing_date(
                subscription.starts_at, subscription.billing_cycle
            )
        
        updated_subscription =  self.subscription_repository.save(subscription)
        return  self._build_subscription_response(updated_subscription)
    
     def cancel_subscription(
        self,
        subscription_id: UUID,
        dto: SubscriptionCancellationDTO
    ) -> Optional[SubscriptionResponseDTO]:
        """Cancel a subscription."""
        subscription =  self.subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None
        
        if subscription.status == "cancelled":
            raise ValueError("Subscription is already cancelled")
        
        # Cancel subscription
        cancelled_subscription =  self.subscription_service.cancel_subscription(
            subscription_id=subscription_id,
            cancel_immediately=dto.cancel_immediately,
            cancellation_reason=dto.cancellation_reason
        )
        
        # Store feedback if provided
        if dto.feedback:
            cancelled_subscription.metadata["cancellation_feedback"] = dto.feedback
             self.subscription_repository.save(cancelled_subscription)
        
        return  self._build_subscription_response(cancelled_subscription)
    
     def upgrade_subscription(
        self,
        subscription_id: UUID,
        dto: SubscriptionUpgradeDTO
    ) -> Optional[SubscriptionResponseDTO]:
        """Upgrade a subscription to a higher plan."""
        subscription =  self.subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None
        
        # Validate new plan
        new_plan =  self.plan_repository.find_by_id(dto.new_plan_id)
        if not new_plan:
            raise ValueError("New plan not found")
        
        # Perform upgrade
        upgraded_subscription =  self.subscription_service.upgrade_subscription(
            subscription_id=subscription_id,
            new_plan_id=dto.new_plan_id,
            billing_cycle=dto.billing_cycle or subscription.billing_cycle,
            upgrade_immediately=dto.upgrade_immediately,
            prorate=dto.prorate
        )
        
        return  self._build_subscription_response(upgraded_subscription)
    
     def downgrade_subscription(
        self,
        subscription_id: UUID,
        dto: SubscriptionDowngradeDTO
    ) -> Optional[SubscriptionResponseDTO]:
        """Downgrade a subscription to a lower plan."""
        subscription =  self.subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None
        
        # Validate new plan
        new_plan =  self.plan_repository.find_by_id(dto.new_plan_id)
        if not new_plan:
            raise ValueError("New plan not found")
        
        # Perform downgrade
        downgraded_subscription =  self.subscription_service.downgrade_subscription(
            subscription_id=subscription_id,
            new_plan_id=dto.new_plan_id,
            billing_cycle=dto.billing_cycle or subscription.billing_cycle,
            downgrade_at_period_end=dto.downgrade_at_period_end
        )
        
        return  self._build_subscription_response(downgraded_subscription)
    
     def list_subscriptions(
        self,
        organization_id: Optional[UUID] = None,
        status: Optional[str] = None,
        plan_id: Optional[UUID] = None,
        page: int = 1,
        page_size: int = 20
    ) -> SubscriptionListResponseDTO:
        """List subscriptions with pagination and filters."""
        offset = (page - 1) * page_size
        
        subscriptions, total =  self.subscription_repository.find_paginated(
            organization_id=organization_id,
            status=status,
            plan_id=plan_id,
            offset=offset,
            limit=page_size
        )
        
        subscription_responses = []
        for subscription in subscriptions:
            subscription_responses.append( self._build_subscription_response(subscription))
        
        total_pages = (total + page_size - 1) // page_size
        
        return SubscriptionListResponseDTO(
            subscriptions=subscription_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages
        )
    
     def get_organization_subscription(
        self,
        organization_id: UUID
    ) -> Optional[SubscriptionResponseDTO]:
        """Get the active subscription for an organization."""
        subscription =  self.subscription_repository.find_active_by_organization(
            organization_id
        )
        if not subscription:
            return None
        
        return  self._build_subscription_response(subscription)
    
     def get_expiring_subscriptions(
        self,
        days_ahead: int = 7
    ) -> List[SubscriptionResponseDTO]:
        """Get subscriptions expiring within specified days."""
        cutoff_date = datetime.now(timezone.utc) + timedelta(days=days_ahead)
        
        subscriptions =  self.subscription_repository.find_expiring_before(cutoff_date)
        
        subscription_responses = []
        for subscription in subscriptions:
            subscription_responses.append( self._build_subscription_response(subscription))
        
        return subscription_responses
    
     def renew_subscription(self, subscription_id: UUID) -> Optional[SubscriptionResponseDTO]:
        """Renew a subscription."""
        subscription =  self.subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None
        
        # Renew subscription
        renewed_subscription =  self.subscription_service.renew_subscription(subscription_id)
        
        return  self._build_subscription_response(renewed_subscription)
    
     def pause_subscription(self, subscription_id: UUID) -> Optional[SubscriptionResponseDTO]:
        """Pause a subscription."""
        subscription =  self.subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None
        
        if subscription.status != "active":
            raise ValueError("Can only pause active subscriptions")
        
        subscription.status = "paused"
        subscription.metadata["paused_at"] = datetime.now(timezone.utc).isoformat()
        subscription.updated_at = datetime.now(timezone.utc)
        
        updated_subscription =  self.subscription_repository.save(subscription)
        return  self._build_subscription_response(updated_subscription)
    
     def resume_subscription(self, subscription_id: UUID) -> Optional[SubscriptionResponseDTO]:
        """Resume a paused subscription."""
        subscription =  self.subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None
        
        if subscription.status != "paused":
            raise ValueError("Can only resume paused subscriptions")
        
        subscription.status = "active"
        subscription.metadata["resumed_at"] = datetime.now(timezone.utc).isoformat()
        subscription.updated_at = datetime.now(timezone.utc)
        
        updated_subscription =  self.subscription_repository.save(subscription)
        return  self._build_subscription_response(updated_subscription)
    
     def _build_subscription_response(self, subscription: Subscription) -> SubscriptionResponseDTO:
        """Build subscription response DTO."""
        # Get plan details
        plan =  self.plan_repository.find_by_id(subscription.plan_id)
        plan_name = plan.name if plan else "Unknown Plan"
        plan_type = plan.plan_type if plan else "Unknown"
        
        return SubscriptionResponseDTO(
            id=subscription.id,
            organization_id=subscription.organization_id,
            plan_id=subscription.plan_id,
            plan_name=plan_name,
            plan_type=plan_type,
            status=subscription.status,
            billing_cycle=subscription.billing_cycle,
            starts_at=subscription.starts_at,
            ends_at=subscription.ends_at,
            next_billing_date=subscription.next_billing_date,
            created_at=subscription.created_at,
            updated_at=subscription.updated_at,
            metadata=subscription.metadata,
            is_trial=subscription.metadata.get("is_trial", False)
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID

from ...domain.entities.plan import Plan
from ...domain.repositories.plan_repository import PlanRepository
from ...domain.services.plan_authorization_service import PlanAuthorizationService
from ..dtos.plan_dto import (
    PlanCreateDTO, PlanUpdateDTO, PlanResponseDTO, PlanListResponseDTO,
    PlanValidationRequestDTO, PlanValidationResponseDTO
)


class PlanUseCase:
    """Use case for plan management operations."""
    
    def __init__(
        self,
        plan_repository: PlanRepository,
        plan_authorization_service: PlanAuthorizationService
    ):
        self.plan_repository = plan_repository
        self.plan_authorization_service = plan_authorization_service
    
     def create_plan(self, dto: PlanCreateDTO) -> PlanResponseDTO:
        """Create a new plan."""
        # Create plan entity
        plan = Plan(
            name=dto.name,
            description=dto.description,
            plan_type=dto.plan_type,
            resources=dto.resources,
            price_monthly=dto.price_monthly,
            price_yearly=dto.price_yearly,
            created_at=datetime.now(timezone.utc)
        )
        
        # Save plan
        saved_plan =  self.plan_repository.save(plan)
        
        return  self._build_plan_response(saved_plan)
    
     def get_plan_by_id(self, plan_id: UUID) -> Optional[PlanResponseDTO]:
        """Get plan by ID."""
        plan =  self.plan_repository.find_by_id(plan_id)
        if not plan:
            return None
        
        return  self._build_plan_response(plan)
    
     def update_plan(self, plan_id: UUID, dto: PlanUpdateDTO) -> Optional[PlanResponseDTO]:
        """Update an existing plan."""
        plan =  self.plan_repository.find_by_id(plan_id)
        if not plan:
            return None
        
        # Update fields
        if dto.description is not None:
            plan.description = dto.description
        if dto.resources is not None:
            plan.resources = dto.resources
        if dto.price_monthly is not None:
            plan.price_monthly = dto.price_monthly
        if dto.price_yearly is not None:
            plan.price_yearly = dto.price_yearly
        
        plan.updated_at = datetime.now(timezone.utc)
        
        # Save plan
        updated_plan =  self.plan_repository.save(plan)
        
        return  self._build_plan_response(updated_plan)
    
     def delete_plan(self, plan_id: UUID) -> bool:
        """Delete a plan (soft delete)."""
        plan =  self.plan_repository.find_by_id(plan_id)
        if not plan:
            return False
        
        # Check if plan has active subscriptions
        subscription_count =  self.plan_repository.get_active_subscription_count(plan_id)
        if subscription_count > 0:
            raise ValueError("Cannot delete plan with active subscriptions")
        
        plan.is_active = False
        plan.updated_at = datetime.now(timezone.utc)
         self.plan_repository.save(plan)
        
        return True
    
     def list_plans(
        self,
        plan_type: Optional[str] = None,
        is_active: Optional[bool] = None,
        page: int = 1,
        page_size: int = 20
    ) -> PlanListResponseDTO:
        """List plans with pagination and filters."""
        offset = (page - 1) * page_size
        
        plans, total =  self.plan_repository.find_paginated(
            plan_type=plan_type,
            is_active=is_active,
            offset=offset,
            limit=page_size
        )
        
        plan_responses = []
        for plan in plans:
            plan_responses.append( self._build_plan_response(plan))
        
        total_pages = (total + page_size - 1) // page_size
        
        return PlanListResponseDTO(
            plans=plan_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages
        )
    
     def get_active_plans(self) -> List[PlanResponseDTO]:
        """Get all active plans."""
        plans =  self.plan_repository.find_active_plans()
        
        plan_responses = []
        for plan in plans:
            plan_responses.append( self._build_plan_response(plan))
        
        return plan_responses
    
     def get_plans_by_type(self, plan_type: str) -> List[PlanResponseDTO]:
        """Get plans by type."""
        plans =  self.plan_repository.find_by_type(plan_type)
        
        plan_responses = []
        for plan in plans:
            plan_responses.append( self._build_plan_response(plan))
        
        return plan_responses
    
     def validate_plan_access(
        self,
        request_dto: PlanValidationRequestDTO
    ) -> PlanValidationResponseDTO:
        """Validate if an organization can access a plan resource."""
        plan =  self.plan_repository.find_by_id(request_dto.plan_id)
        if not plan:
            return PlanValidationResponseDTO(
                is_allowed=False,
                plan_name="Unknown",
                resource_type=request_dto.resource_type,
                action=request_dto.action,
                reason="Plan not found"
            )
        
        # Use authorization service to check access
        is_allowed, reason, usage_info =  self.plan_authorization_service.can_access_resource(
            organization_id=request_dto.organization_id,
            plan_id=request_dto.plan_id,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            context=request_dto.context
        )
        
        suggestions = []
        if not is_allowed:
            if "limit" in reason.lower():
                suggestions.append("Consider upgrading your plan for higher limits")
            if "not enabled" in reason.lower():
                suggestions.append("This feature is not included in your current plan")
        
        return PlanValidationResponseDTO(
            is_allowed=is_allowed,
            plan_name=plan.name,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            reason=reason,
            current_usage=usage_info.get("current_usage") if usage_info else None,
            limits=usage_info.get("limits") if usage_info else None,
            suggestions=suggestions
        )
    
     def get_plan_features(self, plan_id: UUID) -> Optional[Dict[str, Any]]:
        """Get detailed plan features and capabilities."""
        plan =  self.plan_repository.find_by_id(plan_id)
        if not plan:
            return None
        
        # Build comprehensive feature list
        features = {
            "plan_info": {
                "id": str(plan.id),
                "name": plan.name,
                "type": plan.plan_type,
                "description": plan.description
            },
            "resources": plan.resources,
            "pricing": {
                "monthly": plan.price_monthly,
                "yearly": plan.price_yearly
            },
            "capabilities": []
        }
        
        # Add resource capabilities
        for resource_type, config in plan.resources.items():
            if isinstance(config, dict) and config.get("enabled", False):
                features["capabilities"].append({
                    "type": resource_type,
                    "enabled": True,
                    "limits": config.get("limits", {}),
                    "features": config.get("features", [])
                })
        
        return features
    
     def compare_plans(self, plan_ids: List[UUID]) -> Dict[str, Any]:
        """Compare multiple plans side by side."""
        plans = []
        for plan_id in plan_ids:
            plan =  self.plan_repository.find_by_id(plan_id)
            if plan:
                plans.append(plan)
        
        if not plans:
            return {"error": "No valid plans found"}
        
        comparison = {
            "plans": [],
            "feature_matrix": {},
            "pricing_comparison": {}
        }
        
        # Build plan summaries
        for plan in plans:
            comparison["plans"].append({
                "id": str(plan.id),
                "name": plan.name,
                "type": plan.plan_type,
                "monthly_price": plan.price_monthly,
                "yearly_price": plan.price_yearly
            })
        
        # Build feature matrix
        all_features = set()
        for plan in plans:
            all_features.update(plan.resources.keys())
        
        for feature in all_features:
            comparison["feature_matrix"][feature] = []
            for plan in plans:
                resource_config = plan.resources.get(feature, {})
                comparison["feature_matrix"][feature].append({
                    "plan_id": str(plan.id),
                    "enabled": resource_config.get("enabled", False),
                    "limits": resource_config.get("limits", {})
                })
        
        # Pricing comparison
        comparison["pricing_comparison"] = {
            "monthly": [p.price_monthly for p in plans],
            "yearly": [p.price_yearly for p in plans],
            "best_value_monthly": min((p for p in plans if p.price_monthly), key=lambda x: x.price_monthly or float('inf'), default=None),
            "best_value_yearly": min((p for p in plans if p.price_yearly), key=lambda x: x.price_yearly or float('inf'), default=None)
        }
        
        return comparison
    
     def _build_plan_response(self, plan: Plan) -> PlanResponseDTO:
        """Build plan response DTO."""
        subscription_count =  self.plan_repository.get_active_subscription_count(plan.id)
        
        return PlanResponseDTO(
            id=plan.id,
            name=plan.name,
            description=plan.description,
            plan_type=plan.plan_type,
            resources=plan.resources,
            price_monthly=plan.price_monthly,
            price_yearly=plan.price_yearly,
            created_at=plan.created_at,
            updated_at=plan.updated_at,
            is_active=plan.is_active,
            subscription_count=subscription_count
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID

from ...domain.entities.plan_resource import PlanResource
from ...domain.repositories.plan_resource_repository import PlanResourceRepository
from ...domain.repositories.plan_repository import PlanRepository
from ...domain.services.plan_resource_service import PlanResourceService
from ..dtos.plan_resource_dto import (
    PlanResourceCreateDTO,
    PlanResourceUpdateDTO,
    PlanResourceResponseDTO,
    PlanResourceListResponseDTO,
    PlanResourceTestDTO,
    PlanResourceTestResponseDTO,
    PlanResourceUsageDTO,
    PlanResourceUsageResponseDTO,
)


class PlanResourceUseCase:
    """Use case for plan resource management operations."""

    def __init__(
        self,
        plan_resource_repository: PlanResourceRepository,
        plan_repository: PlanRepository,
        plan_resource_service: PlanResourceService,
    ):
        self.plan_resource_repository = plan_resource_repository
        self.plan_repository = plan_repository
        self.plan_resource_service = plan_resource_service

    def create_plan_resource(
        self, dto: PlanResourceCreateDTO
    ) -> PlanResourceResponseDTO:
        """Create a new plan resource."""
        # Validate plan exists
        plan = self.plan_repository.find_by_id(dto.plan_id)
        if not plan:
            raise ValueError("Plan not found")

        # Check if resource already exists for this plan
        existing = self.plan_resource_repository.find_by_plan_and_type(
            dto.plan_id, dto.resource_type
        )
        if existing:
            raise ValueError(
                f"Resource {dto.resource_type} already exists for this plan"
            )

        # Create resource using factory method
        resource = PlanResource.create_resource(
            plan_id=dto.plan_id,
            resource_type=dto.resource_type,
            configuration=dto.configuration,
            is_enabled=dto.is_enabled,
        )

        # Save resource
        saved_resource = self.plan_resource_repository.save(resource)

        return self._build_resource_response(saved_resource)

    def get_resource_by_id(
        self, resource_id: UUID
    ) -> Optional[PlanResourceResponseDTO]:
        """Get plan resource by ID."""
        resource = self.plan_resource_repository.find_by_id(resource_id)
        if not resource:
            return None

        return self._build_resource_response(resource)

    def update_plan_resource(
        self, resource_id: UUID, dto: PlanResourceUpdateDTO
    ) -> Optional[PlanResourceResponseDTO]:
        """Update an existing plan resource."""
        resource = self.plan_resource_repository.find_by_id(resource_id)
        if not resource:
            return None

        # Update fields
        if dto.configuration is not None:
            # Validate configuration based on resource type
            validated_config = self.plan_resource_service.validate_configuration(
                resource.resource_type, dto.configuration
            )
            resource.configuration = validated_config

        if dto.is_enabled is not None:
            resource.is_enabled = dto.is_enabled

        resource.updated_at = datetime.now(timezone.utc)

        # Save resource
        updated_resource = self.plan_resource_repository.save(resource)

        return self._build_resource_response(updated_resource)

    def delete_plan_resource(self, resource_id: UUID) -> bool:
        """Delete a plan resource."""
        resource = self.plan_resource_repository.find_by_id(resource_id)
        if not resource:
            return False

        # Check if resource is being used
        usage_count = self.plan_resource_repository.get_usage_count(resource_id)
        if usage_count > 0:
            # Soft delete if in use
            resource.is_enabled = False
            resource.updated_at = datetime.now(timezone.utc)
            self.plan_resource_repository.save(resource)
        else:
            # Hard delete if not in use
            self.plan_resource_repository.delete(resource_id)

        return True

    def list_plan_resources(
        self,
        plan_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
        is_enabled: Optional[bool] = None,
        page: int = 1,
        page_size: int = 20,
    ) -> PlanResourceListResponseDTO:
        """List plan resources with pagination and filters."""
        offset = (page - 1) * page_size

        resources, total = self.plan_resource_repository.find_paginated(
            plan_id=plan_id,
            resource_type=resource_type,
            is_enabled=is_enabled,
            offset=offset,
            limit=page_size,
        )

        resource_responses = []
        for resource in resources:
            resource_responses.append(self._build_resource_response(resource))

        total_pages = (total + page_size - 1) // page_size

        return PlanResourceListResponseDTO(
            resources=resource_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_plan_resources(self, plan_id: UUID) -> List[PlanResourceResponseDTO]:
        """Get all resources for a specific plan."""
        resources = self.plan_resource_repository.find_by_plan(plan_id)

        resource_responses = []
        for resource in resources:
            resource_responses.append(self._build_resource_response(resource))

        return resource_responses

    def test_resource_configuration(
        self, dto: PlanResourceTestDTO
    ) -> PlanResourceTestResponseDTO:
        """Test a plan resource configuration."""
        start_time = datetime.now(timezone.utc)

        try:
            # Test the configuration
            test_results = self.plan_resource_service.test_configuration(
                resource_type=dto.resource_type,
                configuration=dto.test_configuration,
                test_parameters=dto.test_parameters,
            )

            end_time = datetime.now(timezone.utc)
            test_duration = (end_time - start_time).total_seconds() * 1000

            # Generate recommendations based on test results
            recommendations = self._generate_configuration_recommendations(
                dto.resource_type, dto.test_configuration, test_results
            )

            return PlanResourceTestResponseDTO(
                success=test_results.get("success", False),
                resource_type=dto.resource_type,
                test_results=test_results,
                performance_metrics={"test_duration_ms": test_duration},
                recommendations=recommendations,
            )

        except Exception as e:
            end_time = datetime.now(timezone.utc)
            test_duration = (end_time - start_time).total_seconds() * 1000

            return PlanResourceTestResponseDTO(
                success=False,
                resource_type=dto.resource_type,
                test_results={},
                error_message=str(e),
                performance_metrics={"test_duration_ms": test_duration},
            )

    def record_resource_usage(self, dto: PlanResourceUsageDTO) -> bool:
        """Record usage of a plan resource."""
        return self.plan_resource_repository.record_usage(
            resource_id=dto.resource_id,
            organization_id=dto.organization_id,
            usage_date=dto.usage_date,
            usage_count=dto.usage_count,
            usage_details=dto.usage_details,
            cost=dto.cost,
        )

    def get_resource_usage(
        self, resource_id: UUID, start_date: datetime, end_date: datetime
    ) -> PlanResourceUsageResponseDTO:
        """Get usage statistics for a plan resource."""
        usage_data = self.plan_resource_repository.get_usage_statistics(
            resource_id=resource_id, start_date=start_date, end_date=end_date
        )

        resource = self.plan_resource_repository.find_by_id(resource_id)
        resource_type = resource.resource_type if resource else "Unknown"

        return PlanResourceUsageResponseDTO(
            resource_id=resource_id,
            resource_type=resource_type,
            total_usage=usage_data.get("total_usage", 0),
            usage_period=f"{start_date.date()} to {end_date.date()}",
            usage_breakdown=usage_data.get("breakdown", {}),
            cost_breakdown=usage_data.get("costs", {}),
            usage_trends=usage_data.get("trends", []),
        )

    def enable_resource(self, resource_id: UUID) -> Optional[PlanResourceResponseDTO]:
        """Enable a plan resource."""
        resource = self.plan_resource_repository.find_by_id(resource_id)
        if not resource:
            return None

        resource.is_enabled = True
        resource.updated_at = datetime.now(timezone.utc)

        updated_resource = self.plan_resource_repository.save(resource)
        return self._build_resource_response(updated_resource)

    def disable_resource(self, resource_id: UUID) -> Optional[PlanResourceResponseDTO]:
        """Disable a plan resource."""
        resource = self.plan_resource_repository.find_by_id(resource_id)
        if not resource:
            return None

        resource.is_enabled = False
        resource.updated_at = datetime.now(timezone.utc)

        updated_resource = self.plan_resource_repository.save(resource)
        return self._build_resource_response(updated_resource)

    def duplicate_resource(
        self, resource_id: UUID, target_plan_id: UUID
    ) -> Optional[PlanResourceResponseDTO]:
        """Duplicate a resource to another plan."""
        source_resource = self.plan_resource_repository.find_by_id(resource_id)
        if not source_resource:
            return None

        # Validate target plan exists
        target_plan = self.plan_repository.find_by_id(target_plan_id)
        if not target_plan:
            raise ValueError("Target plan not found")

        # Check if resource already exists in target plan
        existing = self.plan_resource_repository.find_by_plan_and_type(
            target_plan_id, source_resource.resource_type
        )
        if existing:
            raise ValueError("Resource already exists in target plan")

        # Create duplicate
        duplicate_resource = PlanResource.create_resource(
            plan_id=target_plan_id,
            resource_type=source_resource.resource_type,
            configuration=source_resource.configuration.copy(),
            is_enabled=source_resource.is_enabled,
        )

        saved_duplicate = self.plan_resource_repository.save(duplicate_resource)
        return self._build_resource_response(saved_duplicate)

    def _generate_configuration_recommendations(
        self,
        resource_type: str,
        configuration: Dict[str, Any],
        test_results: Dict[str, Any],
    ) -> List[str]:
        """Generate configuration recommendations based on test results."""
        recommendations = []

        if resource_type == "chat_whatsapp":
            if not test_results.get("webhook_reachable", True):
                recommendations.append(
                    "Ensure webhook URL is accessible from external networks"
                )
            if test_results.get("response_time_ms", 0) > 2000:
                recommendations.append(
                    "Consider optimizing webhook response time (currently > 2s)"
                )

        elif resource_type == "chat_iframe":
            if not test_results.get("domains_valid", True):
                recommendations.append(
                    "Verify all allowed domains are correctly formatted"
                )
            if test_results.get("load_time_ms", 0) > 3000:
                recommendations.append("Consider optimizing iframe content load time")

        # General recommendations
        if not test_results.get("success", False):
            recommendations.append(
                "Review configuration parameters and ensure all required fields are provided"
            )

        return recommendations

    def _build_resource_response(
        self, resource: PlanResource
    ) -> PlanResourceResponseDTO:
        """Build plan resource response DTO."""
        # Get plan name
        plan = self.plan_repository.find_by_id(resource.plan_id)
        plan_name = plan.name if plan else "Unknown Plan"

        # Get usage count
        usage_count = self.plan_resource_repository.get_usage_count(resource.id)

        return PlanResourceResponseDTO(
            id=resource.id,
            plan_id=resource.plan_id,
            plan_name=plan_name,
            resource_type=resource.resource_type,
            configuration=resource.configuration,
            is_enabled=resource.is_enabled,
            created_at=resource.created_at,
            updated_at=resource.updated_at,
            usage_count=usage_count,
        )
from .plan_use_cases import PlanUseCase
from .subscription_use_cases import SubscriptionUseCase
from .plan_resource_use_cases import PlanResourceUseCase

__all__ = [
    "PlanUseCase",
    "SubscriptionUseCase", 
    "PlanResourceUseCase"
]
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete, and_
from sqlalchemy.exc import IntegrityError

from ...domain.entities.subscription import Subscription
from ...domain.repositories.subscription_repository import SubscriptionRepository
from ....infrastructure.database.models.plans_models import (
    SubscriptionModel,
    SubscriptionStatusEnum,
    BillingCycleEnum,
)


class SqlAlchemySubscriptionRepository(SubscriptionRepository):
    """SQLAlchemy implementation of SubscriptionRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, subscription: Subscription) -> Subscription:
        """Save a subscription entity."""
        try:
            # Check if subscription exists
            existing = self.session.get(SubscriptionModel, subscription.id)

            if existing:
                # Update existing subscription
                existing.organization_id = subscription.organization_id
                existing.plan_id = subscription.plan_id
                existing.status = SubscriptionStatusEnum(subscription.status)
                existing.billing_cycle = BillingCycleEnum(subscription.billing_cycle)
                existing.starts_at = subscription.starts_at
                existing.ends_at = subscription.ends_at
                existing.next_billing_date = subscription.next_billing_date
                existing.cancelled_at = subscription.cancelled_at
                existing.metadata = subscription.metadata
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new subscription
                subscription_model = SubscriptionModel(
                    id=subscription.id,
                    organization_id=subscription.organization_id,
                    plan_id=subscription.plan_id,
                    status=SubscriptionStatusEnum(subscription.status),
                    billing_cycle=BillingCycleEnum(subscription.billing_cycle),
                    starts_at=subscription.starts_at,
                    ends_at=subscription.ends_at,
                    next_billing_date=subscription.next_billing_date,
                    cancelled_at=subscription.cancelled_at,
                    metadata=subscription.metadata,
                    created_at=subscription.created_at,
                    updated_at=subscription.updated_at,
                )

                self.session.add(subscription_model)
                self.session.flush()
                return self._to_domain_entity(subscription_model)

        except IntegrityError as e:
            self.session.rollback()
            raise e

    def find_by_id(self, subscription_id: UUID) -> Optional[Subscription]:
        """Find a subscription by ID."""
        result = self.session.execute(
            select(SubscriptionModel).where(SubscriptionModel.id == subscription_id)
        )
        subscription_model = result.scalar_one_or_none()

        if subscription_model:
            return self._to_domain_entity(subscription_model)
        return None

    def find_by_organization(self, organization_id: UUID) -> List[Subscription]:
        """Find all subscriptions for an organization."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                SubscriptionModel.organization_id == organization_id
            )
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_active_by_organization(
        self, organization_id: UUID
    ) -> Optional[Subscription]:
        """Find active subscription for an organization."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                and_(
                    SubscriptionModel.organization_id == organization_id,
                    SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE,
                )
            )
        )
        subscription_model = result.scalar_one_or_none()

        if subscription_model:
            return self._to_domain_entity(subscription_model)
        return None

    def find_by_plan(self, plan_id: UUID) -> List[Subscription]:
        """Find all subscriptions for a plan."""
        result = self.session.execute(
            select(SubscriptionModel).where(SubscriptionModel.plan_id == plan_id)
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_by_status(self, status: str) -> List[Subscription]:
        """Find subscriptions by status."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                SubscriptionModel.status == SubscriptionStatusEnum(status)
            )
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_expiring_before(self, date: datetime) -> List[Subscription]:
        """Find subscriptions expiring before a date."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                and_(
                    SubscriptionModel.ends_at <= date,
                    SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE,
                )
            )
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_due_for_billing(self, date: datetime) -> List[Subscription]:
        """Find subscriptions due for billing."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                and_(
                    SubscriptionModel.next_billing_date <= date,
                    SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE,
                )
            )
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        plan_id: Optional[UUID] = None,
        status: Optional[str] = None,
        billing_cycle: Optional[str] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Subscription], int]:
        """Find subscriptions with pagination and filters."""
        query = select(SubscriptionModel)
        count_query = select(SubscriptionModel)

        # Apply filters
        if organization_id:
            query = query.where(SubscriptionModel.organization_id == organization_id)
            count_query = count_query.where(
                SubscriptionModel.organization_id == organization_id
            )

        if plan_id:
            query = query.where(SubscriptionModel.plan_id == plan_id)
            count_query = count_query.where(SubscriptionModel.plan_id == plan_id)

        if status:
            query = query.where(
                SubscriptionModel.status == SubscriptionStatusEnum(status)
            )
            count_query = count_query.where(
                SubscriptionModel.status == SubscriptionStatusEnum(status)
            )

        if billing_cycle:
            query = query.where(
                SubscriptionModel.billing_cycle == BillingCycleEnum(billing_cycle)
            )
            count_query = count_query.where(
                SubscriptionModel.billing_cycle == BillingCycleEnum(billing_cycle)
            )

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(SubscriptionModel.created_at.desc())
        )
        result = self.session.execute(query)
        subscription_models = result.scalars().all()

        subscriptions = [self._to_domain_entity(model) for model in subscription_models]
        return subscriptions, total

    def delete(self, subscription_id: UUID) -> bool:
        """Delete a subscription (hard delete)."""
        result = self.session.execute(
            delete(SubscriptionModel).where(SubscriptionModel.id == subscription_id)
        )
        return result.rowcount > 0

    def update_status(self, subscription_id: UUID, status: str) -> bool:
        """Update subscription status."""
        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(
                status=SubscriptionStatusEnum(status),
                updated_at=datetime.now(timezone.utc),
            )
        )
        return result.rowcount > 0

    def cancel_subscription(
        self,
        subscription_id: UUID,
        cancelled_at: datetime,
        cancellation_reason: Optional[str] = None,
    ) -> bool:
        """Cancel a subscription."""
        update_values = {
            "status": SubscriptionStatusEnum.CANCELLED,
            "cancelled_at": cancelled_at,
            "updated_at": datetime.now(timezone.utc),
        }

        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(**update_values)
        )

        # Update metadata with cancellation reason if provided
        if cancellation_reason and result.rowcount > 0:
            subscription = self.find_by_id(subscription_id)
            if subscription:
                subscription.metadata["cancellation_reason"] = cancellation_reason
                self.save(subscription)

        return result.rowcount > 0

    def update_billing_date(
        self, subscription_id: UUID, next_billing_date: datetime
    ) -> bool:
        """Update subscription billing date."""
        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(
                next_billing_date=next_billing_date,
                updated_at=datetime.now(timezone.utc),
            )
        )
        return result.rowcount > 0

    def extend_subscription(
        self, subscription_id: UUID, new_end_date: datetime
    ) -> bool:
        """Extend subscription end date."""
        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(ends_at=new_end_date, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def change_plan(self, subscription_id: UUID, new_plan_id: UUID) -> bool:
        """Change subscription plan."""
        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(plan_id=new_plan_id, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def get_active_subscriptions_count(self) -> int:
        """Get count of active subscriptions."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE
            )
        )
        return len(result.scalars().all())

    def get_revenue_by_period(self, start_date: datetime, end_date: datetime) -> dict:
        """Get revenue data for a period."""
        # This would typically involve joining with billing/payment tables
        # For now, return a placeholder implementation
        result = self.session.execute(
            select(SubscriptionModel).where(
                and_(
                    SubscriptionModel.created_at >= start_date,
                    SubscriptionModel.created_at <= end_date,
                    SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE,
                )
            )
        )
        subscriptions = result.scalars().all()

        return {
            "subscription_count": len(subscriptions),
            "period_start": start_date,
            "period_end": end_date,
        }

    def _to_domain_entity(self, subscription_model: SubscriptionModel) -> Subscription:
        """Convert SQLAlchemy model to domain entity."""
        return Subscription(
            id=subscription_model.id,
            organization_id=subscription_model.organization_id,
            plan_id=subscription_model.plan_id,
            status=subscription_model.status.value,
            billing_cycle=subscription_model.billing_cycle.value,
            starts_at=subscription_model.starts_at,
            ends_at=subscription_model.ends_at,
            next_billing_date=subscription_model.next_billing_date,
            cancelled_at=subscription_model.cancelled_at,
            metadata=subscription_model.metadata,
            created_at=subscription_model.created_at,
            updated_at=subscription_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete, and_, text
from sqlalchemy.exc import IntegrityError

from ...domain.entities.plan import Plan
from ...domain.repositories.plan_repository import PlanRepository
from ...domain.value_objects.plan_name import PlanName
from ....infrastructure.database.models.plans_models import PlanModel, PlanTypeEnum


class SqlAlchemyPlanRepository(PlanRepository):
    """SQLAlchemy implementation of PlanRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, plan: Plan) -> Plan:
        """Save a plan entity."""
        try:
            # Check if plan exists
            existing = self.session.get(PlanModel, plan.id)

            if existing:
                # Update existing plan
                existing.name = plan.name.value
                existing.description = plan.description
                existing.plan_type = PlanTypeEnum(plan.plan_type)
                existing.resources = plan.resources
                existing.price_monthly = plan.price_monthly
                existing.price_yearly = plan.price_yearly
                existing.is_active = plan.is_active
                existing.features = plan.features if hasattr(plan, "features") else []
                existing.limits = plan.limits if hasattr(plan, "limits") else {}
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new plan
                plan_model = PlanModel(
                    id=plan.id,
                    name=plan.name.value,
                    description=plan.description,
                    plan_type=PlanTypeEnum(plan.plan_type),
                    resources=plan.resources,
                    price_monthly=plan.price_monthly,
                    price_yearly=plan.price_yearly,
                    is_active=plan.is_active,
                    features=plan.features if hasattr(plan, "features") else [],
                    limits=plan.limits if hasattr(plan, "limits") else {},
                    created_at=plan.created_at,
                    updated_at=plan.updated_at,
                )

                self.session.add(plan_model)
                self.session.flush()
                return self._to_domain_entity(plan_model)

        except IntegrityError as e:
            self.session.rollback()
            if "name" in str(e):
                raise ValueError(f"Plan with name '{plan.name.value}' already exists")
            raise e

    def find_by_id(self, plan_id: UUID) -> Optional[Plan]:
        """Find a plan by ID."""
        result = self.session.execute(select(PlanModel).where(PlanModel.id == plan_id))
        plan_model = result.scalar_one_or_none()

        if plan_model:
            return self._to_domain_entity(plan_model)
        return None

    def find_by_name(self, name: PlanName) -> Optional[Plan]:
        """Find a plan by name."""
        result = self.session.execute(
            select(PlanModel).where(PlanModel.name == name.value)
        )
        plan_model = result.scalar_one_or_none()

        if plan_model:
            return self._to_domain_entity(plan_model)
        return None

    def find_by_type(self, plan_type: str) -> List[Plan]:
        """Find plans by type."""
        result = self.session.execute(
            select(PlanModel).where(
                and_(
                    PlanModel.plan_type == PlanTypeEnum(plan_type),
                    PlanModel.is_active,
                )
            )
        )
        plan_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in plan_models]

    def find_active_plans(self) -> List[Plan]:
        """Find all active plans."""
        result = self.session.execute(select(PlanModel).where(PlanModel.is_active))
        plan_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in plan_models]

    def find_paginated(
        self,
        plan_type: Optional[str] = None,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Plan], int]:
        """Find plans with pagination and filters."""
        query = select(PlanModel)
        count_query = select(PlanModel)

        # Apply filters
        if plan_type:
            query = query.where(PlanModel.plan_type == PlanTypeEnum(plan_type))
            count_query = count_query.where(
                PlanModel.plan_type == PlanTypeEnum(plan_type)
            )

        if is_active is not None:
            query = query.where(PlanModel.is_active == is_active)
            count_query = count_query.where(PlanModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(PlanModel.created_at.desc())
        result = self.session.execute(query)
        plan_models = result.scalars().all()

        plans = [self._to_domain_entity(model) for model in plan_models]
        return plans, total

    def delete(self, plan_id: UUID) -> bool:
        """Delete a plan (hard delete)."""
        result = self.session.execute(delete(PlanModel).where(PlanModel.id == plan_id))
        return result.rowcount > 0

    def get_active_subscription_count(self, plan_id: UUID) -> int:
        """Get the number of active subscriptions for a plan."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM subscriptions WHERE plan_id = :plan_id AND status = 'active'"
            ).bindparam(plan_id=plan_id)
        )
        return result.scalar() or 0

    def get_plan_pricing(
        self, plan_id: UUID
    ) -> tuple[Optional[float], Optional[float]]:
        """Get plan pricing (monthly, yearly)."""
        result = self.session.execute(
            select(PlanModel.price_monthly, PlanModel.price_yearly).where(
                PlanModel.id == plan_id
            )
        )
        pricing = result.first()

        if pricing:
            return pricing[0], pricing[1]
        return None, None

    def update_pricing(
        self,
        plan_id: UUID,
        price_monthly: Optional[float] = None,
        price_yearly: Optional[float] = None,
    ) -> bool:
        """Update plan pricing."""
        update_values = {"updated_at": datetime.now(timezone.utc)}

        if price_monthly is not None:
            update_values["price_monthly"] = price_monthly

        if price_yearly is not None:
            update_values["price_yearly"] = price_yearly

        result = self.session.execute(
            update(PlanModel).where(PlanModel.id == plan_id).values(**update_values)
        )
        return result.rowcount > 0

    def search_plans(
        self,
        query: Optional[str] = None,
        min_price: Optional[float] = None,
        max_price: Optional[float] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Plan], int]:
        """Search plans with filters."""
        db_query = select(PlanModel)
        count_query = select(PlanModel)

        # Apply text search
        if query:
            search_filter = PlanModel.name.ilike(
                f"%{query}%"
            ) | PlanModel.description.ilike(f"%{query}%")
            db_query = db_query.where(search_filter)
            count_query = count_query.where(search_filter)

        # Apply price filters
        if min_price is not None:
            price_filter = (PlanModel.price_monthly >= min_price) | (
                PlanModel.price_yearly >= min_price * 10
            )
            db_query = db_query.where(price_filter)
            count_query = count_query.where(price_filter)

        if max_price is not None:
            price_filter = (PlanModel.price_monthly <= max_price) | (
                PlanModel.price_yearly <= max_price * 10
            )
            db_query = db_query.where(price_filter)
            count_query = count_query.where(price_filter)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        db_query = (
            db_query.offset(offset).limit(limit).order_by(PlanModel.created_at.desc())
        )
        result = self.session.execute(db_query)
        plan_models = result.scalars().all()

        plans = [self._to_domain_entity(model) for model in plan_models]
        return plans, total

    def _to_domain_entity(self, plan_model: PlanModel) -> Plan:
        """Convert SQLAlchemy model to domain entity."""
        return Plan(
            id=plan_model.id,
            name=PlanName(plan_model.name),
            description=plan_model.description,
            plan_type=plan_model.plan_type.value,
            resources=plan_model.resources,
            price_monthly=plan_model.price_monthly,
            price_yearly=plan_model.price_yearly,
            is_active=plan_model.is_active,
            features=plan_model.features,
            limits=plan_model.limits,
            created_at=plan_model.created_at,
            updated_at=plan_model.updated_at,
        )
from .sqlalchemy_plan_repository import SqlAlchemyPlanRepository
from .sqlalchemy_plan_resource_repository import SqlAlchemyPlanResourceRepository
from .sqlalchemy_subscription_repository import SqlAlchemySubscriptionRepository

__all__ = [
    "SqlAlchemyPlanRepository",
    "SqlAlchemyPlanResourceRepository",
    "SqlAlchemySubscriptionRepository"
]
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete, and_, text
from sqlalchemy.exc import IntegrityError

from ...domain.entities.plan_resource import PlanResource
from ...domain.repositories.plan_resource_repository import PlanResourceRepository
from ....infrastructure.database.models.plans_models import (
    PlanResourceModel,
    PlanResourceTypeEnum,
    FeatureUsageModel,
)


class SqlAlchemyPlanResourceRepository(PlanResourceRepository):
    """SQLAlchemy implementation of PlanResourceRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, resource: PlanResource) -> PlanResource:
        """Save a plan resource entity."""
        try:
            # Check if resource exists
            existing = self.session.get(PlanResourceModel, resource.id)

            if existing:
                # Update existing resource
                existing.plan_id = resource.plan_id
                existing.resource_type = PlanResourceTypeEnum(resource.resource_type)
                existing.configuration = resource.configuration
                existing.is_enabled = resource.is_enabled
                existing.limits = resource.limits if hasattr(resource, "limits") else {}
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new resource
                resource_model = PlanResourceModel(
                    id=resource.id,
                    plan_id=resource.plan_id,
                    resource_type=PlanResourceTypeEnum(resource.resource_type),
                    configuration=resource.configuration,
                    is_enabled=resource.is_enabled,
                    limits=resource.limits if hasattr(resource, "limits") else {},
                    created_at=resource.created_at,
                    updated_at=resource.updated_at,
                )

                self.session.add(resource_model)
                self.session.flush()
                return self._to_domain_entity(resource_model)

        except IntegrityError as e:
            self.session.rollback()
            if "plan_id" in str(e) and "resource_type" in str(e):
                raise ValueError(
                    f"Resource {resource.resource_type} already exists for this plan"
                )
            raise e

    def find_by_id(self, resource_id: UUID) -> Optional[PlanResource]:
        """Find a plan resource by ID."""
        result = self.session.execute(
            select(PlanResourceModel).where(PlanResourceModel.id == resource_id)
        )
        resource_model = result.scalar_one_or_none()

        if resource_model:
            return self._to_domain_entity(resource_model)
        return None

    def find_by_plan(self, plan_id: UUID) -> List[PlanResource]:
        """Find all resources for a plan."""
        result = self.session.execute(
            select(PlanResourceModel).where(PlanResourceModel.plan_id == plan_id)
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def find_by_plan_and_type(
        self, plan_id: UUID, resource_type: str
    ) -> Optional[PlanResource]:
        """Find a specific resource for a plan."""
        result = self.session.execute(
            select(PlanResourceModel).where(
                and_(
                    PlanResourceModel.plan_id == plan_id,
                    PlanResourceModel.resource_type
                    == PlanResourceTypeEnum(resource_type),
                )
            )
        )
        resource_model = result.scalar_one_or_none()

        if resource_model:
            return self._to_domain_entity(resource_model)
        return None

    def find_by_type(self, resource_type: str) -> List[PlanResource]:
        """Find all resources of a specific type."""
        result = self.session.execute(
            select(PlanResourceModel).where(
                and_(
                    PlanResourceModel.resource_type
                    == PlanResourceTypeEnum(resource_type),
                    PlanResourceModel.is_enabled,
                )
            )
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def find_enabled_resources(self, plan_id: UUID) -> List[PlanResource]:
        """Find enabled resources for a plan."""
        result = self.session.execute(
            select(PlanResourceModel).where(
                and_(
                    PlanResourceModel.plan_id == plan_id,
                    PlanResourceModel.is_enabled,
                )
            )
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def find_paginated(
        self,
        plan_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
        is_enabled: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[PlanResource], int]:
        """Find plan resources with pagination and filters."""
        query = select(PlanResourceModel)
        count_query = select(PlanResourceModel)

        # Apply filters
        if plan_id:
            query = query.where(PlanResourceModel.plan_id == plan_id)
            count_query = count_query.where(PlanResourceModel.plan_id == plan_id)

        if resource_type:
            query = query.where(
                PlanResourceModel.resource_type == PlanResourceTypeEnum(resource_type)
            )
            count_query = count_query.where(
                PlanResourceModel.resource_type == PlanResourceTypeEnum(resource_type)
            )

        if is_enabled is not None:
            query = query.where(PlanResourceModel.is_enabled == is_enabled)
            count_query = count_query.where(PlanResourceModel.is_enabled == is_enabled)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(PlanResourceModel.created_at.desc())
        )
        result = self.session.execute(query)
        resource_models = result.scalars().all()

        resources = [self._to_domain_entity(model) for model in resource_models]
        return resources, total

    def delete(self, resource_id: UUID) -> bool:
        """Delete a plan resource (hard delete)."""
        result = self.session.execute(
            delete(PlanResourceModel).where(PlanResourceModel.id == resource_id)
        )
        return result.rowcount > 0

    def update_configuration(
        self, resource_id: UUID, configuration: Dict[str, Any]
    ) -> bool:
        """Update resource configuration."""
        result = self.session.execute(
            update(PlanResourceModel)
            .where(PlanResourceModel.id == resource_id)
            .values(configuration=configuration, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def enable_resource(self, resource_id: UUID) -> bool:
        """Enable a plan resource."""
        result = self.session.execute(
            update(PlanResourceModel)
            .where(PlanResourceModel.id == resource_id)
            .values(is_enabled=True, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def disable_resource(self, resource_id: UUID) -> bool:
        """Disable a plan resource."""
        result = self.session.execute(
            update(PlanResourceModel)
            .where(PlanResourceModel.id == resource_id)
            .values(is_enabled=False, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def get_usage_count(self, resource_id: UUID) -> int:
        """Get usage count for a resource."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM feature_usage WHERE resource_type = (SELECT resource_type FROM plan_resources WHERE id = :resource_id)"
            ).bindparam(resource_id=resource_id)
        )
        return result.scalar() or 0

    def record_usage(
        self,
        resource_id: UUID,
        organization_id: UUID,
        usage_date: datetime,
        usage_count: int = 1,
        usage_details: Optional[Dict[str, Any]] = None,
        cost: Optional[float] = None,
    ) -> bool:
        """Record usage of a plan resource."""
        # Get resource type first
        resource_result = self.session.execute(
            select(PlanResourceModel.resource_type).where(
                PlanResourceModel.id == resource_id
            )
        )
        resource_type_enum = resource_result.scalar_one_or_none()

        if not resource_type_enum:
            return False

        usage_model = FeatureUsageModel(
            organization_id=organization_id,
            resource_type=resource_type_enum.value,
            feature_name="general_usage",
            usage_count=usage_count,
            usage_date=usage_date,
            usage_details=usage_details or {},
            cost=cost,
        )

        self.session.add(usage_model)
        self.session.flush()
        return True

    def get_usage_statistics(
        self, resource_id: UUID, start_date: datetime, end_date: datetime
    ) -> Dict[str, Any]:
        """Get usage statistics for a resource."""
        # Get resource type
        resource_result = self.session.execute(
            select(PlanResourceModel.resource_type).where(
                PlanResourceModel.id == resource_id
            )
        )
        resource_type_enum = resource_result.scalar_one_or_none()

        if not resource_type_enum:
            return {}

        # Get usage data
        usage_result = self.session.execute(
            select(FeatureUsageModel).where(
                and_(
                    FeatureUsageModel.resource_type == resource_type_enum.value,
                    FeatureUsageModel.usage_date >= start_date,
                    FeatureUsageModel.usage_date <= end_date,
                )
            )
        )
        usage_records = usage_result.scalars().all()

        # Calculate statistics
        total_usage = sum(record.usage_count for record in usage_records)
        total_cost = sum(record.cost or 0 for record in usage_records)

        # Group by date for trends
        daily_usage = {}
        for record in usage_records:
            date_key = record.usage_date.date().isoformat()
            if date_key not in daily_usage:
                daily_usage[date_key] = {"usage": 0, "cost": 0}
            daily_usage[date_key]["usage"] += record.usage_count
            daily_usage[date_key]["cost"] += record.cost or 0

        return {
            "total_usage": total_usage,
            "breakdown": {"by_date": daily_usage},
            "costs": {"total": total_cost},
            "trends": [
                {"date": date, "usage": data["usage"], "cost": data["cost"]}
                for date, data in daily_usage.items()
            ],
        }

    def bulk_update_limits(self, resource_updates: Dict[UUID, Dict[str, Any]]) -> int:
        """Update limits for multiple resources."""
        updated_count = 0

        for resource_id, limits in resource_updates.items():
            result = self.session.execute(
                update(PlanResourceModel)
                .where(PlanResourceModel.id == resource_id)
                .values(limits=limits, updated_at=datetime.now(timezone.utc))
            )
            if result.rowcount > 0:
                updated_count += 1

        return updated_count

    def _to_domain_entity(self, resource_model: PlanResourceModel) -> PlanResource:
        """Convert SQLAlchemy model to domain entity."""
        return PlanResource(
            id=resource_model.id,
            plan_id=resource_model.plan_id,
            resource_type=resource_model.resource_type.value,
            configuration=resource_model.configuration,
            is_enabled=resource_model.is_enabled,
            limits=resource_model.limits,
            created_at=resource_model.created_at,
            updated_at=resource_model.updated_at,
        )
from .repositories import (
    SqlAlchemyPlanRepository, SqlAlchemyPlanResourceRepository, SqlAlchemySubscriptionRepository
)

__all__ = [
    "SqlAlchemyPlanRepository",
    "SqlAlchemyPlanResourceRepository",
    "SqlAlchemySubscriptionRepository"
]
