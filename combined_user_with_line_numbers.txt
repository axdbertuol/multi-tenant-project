from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel, Field

from ..value_objects.email import Email
from ..value_objects.password import Password


class User(BaseModel):
    id: UUID
    email: Email
    name: str
    password: Password
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"arbitrary_types_allowed": True}

    @classmethod
    def create(cls, email: str, name: str, password: str) -> "User":
        return cls(
            id=uuid4(),
            email=Email(value=email),
            name=name,
            password=Password.create(password),
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "User":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "User":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "User":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
    
    def change_password(self, new_password: str) -> "User":
        return self.model_copy(update={
            "password": Password.create(new_password),
            "updated_at": datetime.utcnow()
        })
    
    def verify_password(self, plain_password: str) -> bool:
        return self.password.verify(plain_password)

    def can_access_organization(self, organization_id: UUID) -> bool:
        """Domain rule: User can access organization they belong to"""
        return self.is_active
from datetime import datetime, timedelta
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel


class UserSession(BaseModel):
    id: UUID
    user_id: UUID
    token: str
    expires_at: datetime
    created_at: datetime
    is_active: bool = True
    user_agent: Optional[str] = None
    ip_address: Optional[str] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls, 
        user_id: UUID, 
        token: str, 
        duration_hours: int = 24,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None
    ) -> "UserSession":
        return cls(
            id=uuid4(),
            user_id=user_id,
            token=token,
            expires_at=datetime.utcnow() + timedelta(hours=duration_hours),
            created_at=datetime.utcnow(),
            is_active=True,
            user_agent=user_agent,
            ip_address=ip_address
        )

    def is_expired(self) -> bool:
        return datetime.utcnow() > self.expires_at

    def is_valid(self) -> bool:
        return self.is_active and not self.is_expired()

    def revoke(self) -> "UserSession":
        return self.model_copy(update={"is_active": False})

    def extend(self, hours: int = 24) -> "UserSession":
        return self.model_copy(update={
            "expires_at": self.expires_at + timedelta(hours=hours)
        })
from .user import User
from .user_session import UserSession

__all__ = ["User", "UserSession"]
from typing import Optional
from uuid import UUID

from ..entities.user import User
from ..value_objects.email import Email
from ..repositories.user_repository import UserRepository


class UserDomainService:
    """Domain service for user-specific business logic."""

    def __init__(self, user_repository: UserRepository):
        self._user_repository = user_repository

    def is_email_available(
        self, email: Email, excluding_user_id: Optional[UUID] = None
    ) -> bool:
        """Check if email is available for registration or update."""
        existing_user = self._user_repository.get_by_email(email)

        if not existing_user:
            return True

        # If excluding a specific user (for updates), check if it's the same user
        if excluding_user_id and existing_user.id == excluding_user_id:
            return True

        return False

    def can_user_be_deleted(self, user_id: UUID) -> tuple[bool, str]:
        """Check if user can be safely deleted and return reason if not."""
        user = self._user_repository.get_by_id(user_id)

        if not user:
            return False, "User not found"

        # Add business rules for user deletion
        # For example: check if user is the only admin of an organization

        return True, "Can be deleted"


def validate_user_activation(self, user: User) -> tuple[bool, str]:
    """Validate if user can be activated."""
    if user.is_active:
        return False, "User is already active"

    # Add more business rules as needed
    return True, "Can be activated"


def validate_user_deactivation(self, user: User) -> tuple[bool, str]:
    """Validate if user can be deactivated."""
    if not user.is_active:
        return False, "User is already inactive"

    # Add business rules (e.g., check if user is sole admin of organizations)
    return True, "Can be deactivated"
from typing import Optional

from ..entities.user import User
from ..entities.user_session import UserSession
from ..repositories.user_repository import UserRepository
from ..repositories.user_session_repository import UserSessionRepository
from ..value_objects.email import Email


class AuthenticationService:
    """Domain service for authentication logic."""

    def __init__(
        self, user_repository: UserRepository, session_repository: UserSessionRepository
    ):
        self._user_repository = user_repository
        self._session_repository = session_repository

    def authenticate(self, email: str, password: str) -> Optional[User]:
        """Authenticate user with email and password."""
        try:
            email_vo = Email(value=email)
            user = self._user_repository.get_by_email(email_vo)

            if not user:
                return None

            if not user.is_active:
                return None

            if not user.verify_password(password):
                return None

            return user

        except ValueError:
            # Invalid email format
            return None

    def create_session(
        self,
        user: User,
        token: str,
        duration_hours: int = 24,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None,
    ) -> UserSession:
        """Create a new user session."""
        session = UserSession.create(
            user_id=user.id,
            token=token,
            duration_hours=duration_hours,
            user_agent=user_agent,
            ip_address=ip_address,
        )

        return self._session_repository.save(session)

    def validate_session(self, token: str) -> Optional[User]:
        """Validate session token and return user if valid."""
        session = self._session_repository.get_by_token(token)

        if not session or not session.is_valid():
            return None

        user = self._user_repository.get_by_id(session.user_id)

        if not user or not user.is_active:
            return None

        return user

    def revoke_session(self, token: str) -> bool:
        """Revoke a specific session."""
        session = self._session_repository.get_by_token(token)

        if not session:
            return False

        revoked_session = session.revoke()
        self._session_repository.save(revoked_session)

        return True

    def revoke_all_user_sessions(self, user_id) -> int:
        """Revoke all sessions for a user."""
        return self._session_repository.revoke_all_user_sessions(user_id)
from .user_domain_service import UserDomainService
from .authentication_service import AuthenticationService

__all__ = ["UserDomainService", "AuthenticationService"]
import re
from pydantic import BaseModel, field_validator
from typing import Any


class Email(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if not cls._is_valid_email(v):
            raise ValueError(f"Invalid email format: {v}")
        return v.lower().strip()

    @staticmethod
    def _is_valid_email(email: str) -> bool:
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None

    def domain(self) -> str:
        return self.value.split('@')[1]

    def local_part(self) -> str:
        return self.value.split('@')[0]

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, Email):
            return self.value == other.value
        return False
from pydantic import BaseModel
from typing import Any
import bcrypt
import re


class Password(BaseModel, frozen=True):
    """Password value object with bcrypt encryption and validation rules."""
    
    hashed_value: str
    
    @classmethod
    def create(cls, plain_password: str) -> "Password":
        """Create a new password by hashing the plain text."""
        cls._validate_password_strength(plain_password)
        
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(plain_password.encode('utf-8'), salt)
        return cls(hashed_value=hashed.decode('utf-8'))
    
    @classmethod
    def from_hash(cls, hashed_password: str) -> "Password":
        """Create password object from existing hash."""
        return cls(hashed_value=hashed_password)
    
    @staticmethod
    def _validate_password_strength(password: str) -> None:
        """Validate password strength according to business rules."""
        if not password or len(password.strip()) == 0:
            raise ValueError("Password cannot be empty")
        
        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters long")
        
        if len(password) > 128:
            raise ValueError("Password cannot exceed 128 characters")
        
        if not re.search(r'[A-Z]', password):
            raise ValueError("Password must contain at least one uppercase letter")
        
        if not re.search(r'[a-z]', password):
            raise ValueError("Password must contain at least one lowercase letter")
        
        if not re.search(r'\d', password):
            raise ValueError("Password must contain at least one digit")
    
    def verify(self, plain_password: str) -> bool:
        """Verify a plain password against this hashed password."""
        return bcrypt.checkpw(
            plain_password.encode('utf-8'), 
            self.hashed_value.encode('utf-8')
        )
    
    def __str__(self) -> str:
        return "[PROTECTED]"
    
    def __repr__(self) -> str:
        return "Password([PROTECTED])"
    
    def __hash__(self) -> int:
        return hash(self.hashed_value)
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Password):
            return False
        return self.hashed_value == other.hashed_value
from .email import Email
from .password import Password

__all__ = ["Email", "Password"]
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.user_session import UserSession


class UserSessionRepository(ABC):
    """User session repository interface for the User bounded context."""

    @abstractmethod
    def save(self, session: UserSession) -> UserSession:
        """Save or update a user session."""
        pass

    @abstractmethod
    def get_by_id(self, session_id: UUID) -> Optional[UserSession]:
        """Get session by ID."""
        pass

    @abstractmethod
    def get_by_token(self, token: str) -> Optional[UserSession]:
        """Get session by token."""
        pass

    @abstractmethod
    def get_active_by_user_id(self, user_id: UUID) -> List[UserSession]:
        """Get all active sessions for a user."""
        pass

    @abstractmethod
    def revoke_all_user_sessions(self, user_id: UUID) -> int:
        """Revoke all sessions for a user. Returns count of revoked sessions."""
        pass

    @abstractmethod
    def cleanup_expired_sessions(self) -> int:
        """Cleanup expired sessions. Returns count of cleaned sessions."""
        pass

    @abstractmethod
    def delete(self, session_id: UUID) -> bool:
        """Delete session by ID."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.user import User
from ..value_objects.email import Email


class UserRepository(ABC):
    """User repository interface for the User bounded context."""

    @abstractmethod
    def save(self, user: User) -> User:
        """Save or update a user."""
        pass

    @abstractmethod
    def get_by_id(self, user_id: UUID) -> Optional[User]:
        """Get user by ID."""
        pass

    @abstractmethod
    def get_by_email(self, email: Email) -> Optional[User]:
        """Get user by email."""
        pass

    @abstractmethod
    def exists_by_email(self, email: Email) -> bool:
        """Check if user exists by email."""
        pass

    @abstractmethod
    def delete(self, user_id: UUID) -> bool:
        """Delete user by ID."""
        pass

    @abstractmethod
    def list_active_users(self, limit: int = 100, offset: int = 0) -> List[User]:
        """List active users with pagination."""
        pass

    @abstractmethod
    def count_active_users(self) -> int:
        """Count total active users."""
        pass
from .user_repository import UserRepository
from .user_session_repository import UserSessionRepository

__all__ = ["UserRepository", "UserSessionRepository"]
from .entities import User, UserSession
from .value_objects import Email, Password
from .repositories import UserRepository, UserSessionRepository
from .services import UserDomainService, AuthenticationService

__all__ = [
    "User", 
    "UserSession",
    "Email", 
    "Password",
    "UserRepository", 
    "UserSessionRepository",
    "UserDomainService",
    "AuthenticationService"
]
from typing import Optional
from pydantic import BaseModel, Field
from .user_dto import UserResponseDTO
from .session_dto import SessionResponseDTO


class LoginDTO(BaseModel):
    """DTO for user login."""
    email: str = Field(..., description="User email address")
    password: str = Field(..., description="User password")
    remember_me: bool = Field(False, description="Extended session duration")
    user_agent: Optional[str] = Field(None, max_length=500, description="User agent string")
    ip_address: Optional[str] = Field(None, max_length=45, description="IP address")


class AuthResponseDTO(BaseModel):
    """DTO for authentication response."""
    user: UserResponseDTO
    session: SessionResponseDTO
    access_token: str
    token_type: str = "bearer"
    expires_in: int  # seconds


class LogoutDTO(BaseModel):
    """DTO for user logout."""
    revoke_all_sessions: bool = Field(False, description="Revoke all user sessions")


class RefreshTokenDTO(BaseModel):
    """DTO for token refresh."""
    refresh_token: str = Field(..., description="Refresh token")


class PasswordResetRequestDTO(BaseModel):
    """DTO for password reset request."""
    email: str = Field(..., description="User email address")


class PasswordResetConfirmDTO(BaseModel):
    """DTO for password reset confirmation."""
    token: str = Field(..., description="Password reset token")
    new_password: str = Field(..., min_length=8, description="New password")
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field, field_validator


class UserCreateDTO(BaseModel):
    """DTO for creating a new user."""
    email: str = Field(..., description="User email address")
    name: str = Field(..., min_length=2, max_length=100, description="User full name")
    password: str = Field(..., min_length=8, description="User password")
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if '@' not in v or '.' not in v.split('@')[-1]:
            raise ValueError('Invalid email format')
        return v.lower().strip()
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip()


class UserUpdateDTO(BaseModel):
    """DTO for updating an existing user."""
    name: Optional[str] = Field(None, min_length=2, max_length=100, description="User full name")
    is_active: Optional[bool] = Field(None, description="User active status")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: Optional[str]) -> Optional[str]:
        if v is not None and not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip() if v else None


class UserChangePasswordDTO(BaseModel):
    """DTO for changing user password."""
    current_password: str = Field(..., description="Current password")
    new_password: str = Field(..., min_length=8, description="New password")


class UserResponseDTO(BaseModel):
    """DTO for user response data."""
    id: UUID
    email: str
    name: str
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    model_config = {"from_attributes": True}


class UserListResponseDTO(BaseModel):
    """DTO for paginated user list response."""
    users: list[UserResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int
from .user_dto import UserCreateDTO, UserUpdateDTO, UserResponseDTO
from .session_dto import SessionCreateDTO, SessionResponseDTO
from .auth_dto import LoginDTO, AuthResponseDTO

__all__ = [
    "UserCreateDTO", "UserUpdateDTO", "UserResponseDTO",
    "SessionCreateDTO", "SessionResponseDTO", 
    "LoginDTO", "AuthResponseDTO"
]
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field


class SessionCreateDTO(BaseModel):
    """DTO for creating a new user session."""
    user_id: UUID = Field(..., description="User ID")
    duration_hours: int = Field(24, ge=1, le=720, description="Session duration in hours")
    user_agent: Optional[str] = Field(None, max_length=500, description="User agent string")
    ip_address: Optional[str] = Field(None, max_length=45, description="IP address")


class SessionResponseDTO(BaseModel):
    """DTO for session response data."""
    id: UUID
    user_id: UUID
    token: str
    expires_at: datetime
    created_at: datetime
    is_active: bool
    user_agent: Optional[str] = None
    ip_address: Optional[str] = None
    is_expired: bool
    is_valid: bool
    
    model_config = {"from_attributes": True}


class SessionListResponseDTO(BaseModel):
    """DTO for user sessions list response."""
    sessions: list[SessionResponseDTO]
    total: int
    active_count: int
from .dtos import (
    UserCreateDTO, UserUpdateDTO, UserResponseDTO,
    SessionCreateDTO, SessionResponseDTO,
    LoginDTO, AuthResponseDTO
)
from .use_cases import UserUseCase, AuthUseCase, SessionUseCase

__all__ = [
    # DTOs
    "UserCreateDTO", "UserUpdateDTO", "UserResponseDTO",
    "SessionCreateDTO", "SessionResponseDTO", 
    "LoginDTO", "AuthResponseDTO",
    
    # Use Cases
    "UserUseCase", "AuthUseCase", "SessionUseCase"
]
from typing import Optional
from uuid import UUID, uuid4

from ..dtos.auth_dto import (
    LoginDTO, AuthResponseDTO, LogoutDTO, 
    PasswordResetRequestDTO, PasswordResetConfirmDTO
)
from ..dtos.user_dto import UserResponseDTO
from ..dtos.session_dto import SessionResponseDTO
from ...domain.entities.user import User
from ...domain.entities.user_session import UserSession
from ...domain.repositories.user_repository import UserRepository
from ...domain.repositories.user_session_repository import UserSessionRepository
from ...domain.services.authentication_service import AuthenticationService


class AuthUseCase:
    """Use cases for authentication and authorization."""
    
    def __init__(
        self,
        user_repository: UserRepository,
        session_repository: UserSessionRepository,
        auth_service: AuthenticationService
    ):
        self._user_repository = user_repository
        self._session_repository = session_repository
        self._auth_service = auth_service
    
     def login(self, dto: LoginDTO) -> AuthResponseDTO:
        """Authenticate user and create session."""
        
        # Authenticate user
        user =  self._auth_service.authenticate(dto.email, dto.password)
        
        if not user:
            raise ValueError("Invalid email or password")
        
        # Determine session duration
        duration_hours = 720 if dto.remember_me else 24  # 30 days vs 1 day
        
        # Generate session token
        session_token = self._generate_session_token()
        
        # Create session
        session =  self._auth_service.create_session(
            user=user,
            token=session_token,
            duration_hours=duration_hours,
            user_agent=dto.user_agent,
            ip_address=dto.ip_address
        )
        
        # Create response DTOs
        user_dto = UserResponseDTO.model_validate(user)
        session_dto = SessionResponseDTO.model_validate({
            **session.model_dump(),
            "is_expired": session.is_expired(),
            "is_valid": session.is_valid()
        })
        
        return AuthResponseDTO(
            user=user_dto,
            session=session_dto,
            access_token=session_token,
            expires_in=int(duration_hours * 3600)  # Convert to seconds
        )
    
     def logout(self, token: str, dto: LogoutDTO) -> bool:
        """Logout user by revoking session(s)."""
        
        # Get session to find user
        session =  self._session_repository.get_by_token(token)
        
        if not session:
            return False
        
        if dto.revoke_all_sessions:
            # Revoke all user sessions
             self._auth_service.revoke_all_user_sessions(session.user_id)
        else:
            # Revoke only current session
             self._auth_service.revoke_session(token)
        
        return True
    
     def validate_session(self, token: str) -> Optional[UserResponseDTO]:
        """Validate session token and return user."""
        
        user =  self._auth_service.validate_session(token)
        
        if not user:
            return None
        
        return UserResponseDTO.model_validate(user)
    
     def refresh_session(self, token: str) -> Optional[AuthResponseDTO]:
        """Refresh session if valid."""
        
        # Validate current session
        user =  self._auth_service.validate_session(token)
        
        if not user:
            return None
        
        # Get current session
        session =  self._session_repository.get_by_token(token)
        
        if not session or not session.is_valid():
            return None
        
        # Generate new token
        new_token = self._generate_session_token()
        
        # Create new session with same duration
        original_duration = int((session.expires_at - session.created_at).total_seconds() / 3600)
        
        new_session =  self._auth_service.create_session(
            user=user,
            token=new_token,
            duration_hours=original_duration,
            user_agent=session.user_agent,
            ip_address=session.ip_address
        )
        
        # Revoke old session
         self._auth_service.revoke_session(token)
        
        # Create response DTOs
        user_dto = UserResponseDTO.model_validate(user)
        session_dto = SessionResponseDTO.model_validate({
            **new_session.model_dump(),
            "is_expired": new_session.is_expired(),
            "is_valid": new_session.is_valid()
        })
        
        return AuthResponseDTO(
            user=user_dto,
            session=session_dto,
            access_token=new_token,
            expires_in=int(original_duration * 3600)
        )
    
     def request_password_reset(self, dto: PasswordResetRequestDTO) -> bool:
        """Request password reset for user."""
        from ...domain.value_objects.email import Email
        
        # Check if user exists
        email_vo = Email(value=dto.email)
        user =  self._user_repository.get_by_email(email_vo)
        
        if not user or not user.is_active:
            # Don't reveal if email exists or not
            return True
        
        # Generate reset token (in real implementation, this would be sent via email)
        reset_token = self._generate_reset_token()
        
        # Store reset token (this would typically be in a separate table/cache)
        # For now, just return success
        
        return True
    
     def confirm_password_reset(self, dto: PasswordResetConfirmDTO) -> bool:
        """Confirm password reset with token."""
        
        # In real implementation, validate reset token and get associated user
        # For now, this is a placeholder implementation
        
        # Validate token format
        if len(dto.token) < 32:
            raise ValueError("Invalid reset token")
        
        # Here you would:
        # 1. Validate token exists and is not expired
        # 2. Get associated user
        # 3. Update user password
        # 4. Revoke all user sessions
        # 5. Delete/mark token as used
        
        return True
    
     def change_password_with_current(
        self, 
        user_id: UUID, 
        current_password: str, 
        new_password: str
    ) -> bool:
        """Change password with current password verification."""
        
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        # Verify current password
        if not user.verify_password(current_password):
            raise ValueError("Current password is incorrect")
        
        # Update password
        updated_user = user.change_password(new_password)
         self._user_repository.save(updated_user)
        
        # Revoke all sessions to force re-login
         self._auth_service.revoke_all_user_sessions(user_id)
        
        return True
    
    def _generate_session_token(self) -> str:
        """Generate secure session token."""
        import secrets
        return secrets.token_urlsafe(32)
    
    def _generate_reset_token(self) -> str:
        """Generate secure password reset token."""
        import secrets
        return secrets.token_urlsafe(32)
from typing import Optional
from uuid import UUID
import math

from ..dtos.user_dto import (
    UserCreateDTO, UserUpdateDTO, UserChangePasswordDTO, 
    UserResponseDTO, UserListResponseDTO
)
from ...domain.entities.user import User
from ...domain.repositories.user_repository import UserRepository
from ...domain.services.user_domain_service import UserDomainService
from ...domain.value_objects.email import Email


class UserUseCase:
    """Use cases for user management."""
    
    def __init__(
        self, 
        user_repository: UserRepository,
        user_domain_service: UserDomainService
    ):
        self._user_repository = user_repository
        self._user_domain_service = user_domain_service
    
     def create_user(self, dto: UserCreateDTO) -> UserResponseDTO:
        """Create a new user."""
        
        # Check if email is available
        email_vo = Email(value=dto.email)
        is_available =  self._user_domain_service.is_email_available(email_vo)
        
        if not is_available:
            raise ValueError(f"Email {dto.email} is already in use")
        
        # Create user entity
        user = User.create(
            email=dto.email,
            name=dto.name,
            password=dto.password
        )
        
        # Save user
        saved_user =  self._user_repository.save(user)
        
        return UserResponseDTO.model_validate(saved_user)
    
     def get_user_by_id(self, user_id: UUID) -> Optional[UserResponseDTO]:
        """Get user by ID."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            return None
        
        return UserResponseDTO.model_validate(user)
    
     def get_user_by_email(self, email: str) -> Optional[UserResponseDTO]:
        """Get user by email."""
        email_vo = Email(value=email)
        user =  self._user_repository.get_by_email(email_vo)
        
        if not user:
            return None
        
        return UserResponseDTO.model_validate(user)
    
     def update_user(self, user_id: UUID, dto: UserUpdateDTO) -> UserResponseDTO:
        """Update user information."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        updated_user = user
        
        # Update name if provided
        if dto.name is not None:
            updated_user = updated_user.update_name(dto.name)
        
        # Update active status if provided
        if dto.is_active is not None:
            if dto.is_active and not user.is_active:
                can_activate, reason = self._user_domain_service.validate_user_activation(user)
                if not can_activate:
                    raise ValueError(f"Cannot activate user: {reason}")
                updated_user = updated_user.activate()
            elif not dto.is_active and user.is_active:
                can_deactivate, reason = self._user_domain_service.validate_user_deactivation(user)
                if not can_deactivate:
                    raise ValueError(f"Cannot deactivate user: {reason}")
                updated_user = updated_user.deactivate()
        
        # Save updated user
        saved_user =  self._user_repository.save(updated_user)
        
        return UserResponseDTO.model_validate(saved_user)
    
     def change_password(self, user_id: UUID, dto: UserChangePasswordDTO) -> bool:
        """Change user password."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        # Verify current password
        if not user.verify_password(dto.current_password):
            raise ValueError("Current password is incorrect")
        
        # Update password
        updated_user = user.change_password(dto.new_password)
         self._user_repository.save(updated_user)
        
        return True
    
     def deactivate_user(self, user_id: UUID) -> UserResponseDTO:
        """Deactivate user account."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        can_deactivate, reason = self._user_domain_service.validate_user_deactivation(user)
        if not can_deactivate:
            raise ValueError(f"Cannot deactivate user: {reason}")
        
        updated_user = user.deactivate()
        saved_user =  self._user_repository.save(updated_user)
        
        return UserResponseDTO.model_validate(saved_user)
    
     def activate_user(self, user_id: UUID) -> UserResponseDTO:
        """Activate user account."""
        user =  self._user_repository.get_by_id(user_id)
        
        if not user:
            raise ValueError("User not found")
        
        can_activate, reason = self._user_domain_service.validate_user_activation(user)
        if not can_activate:
            raise ValueError(f"Cannot activate user: {reason}")
        
        updated_user = user.activate()
        saved_user =  self._user_repository.save(updated_user)
        
        return UserResponseDTO.model_validate(saved_user)
    
     def delete_user(self, user_id: UUID) -> bool:
        """Delete user account."""
        can_delete, reason =  self._user_domain_service.can_user_be_deleted(user_id)
        
        if not can_delete:
            raise ValueError(f"Cannot delete user: {reason}")
        
        return  self._user_repository.delete(user_id)
    
     def list_users(
        self, 
        page: int = 1, 
        page_size: int = 100, 
        active_only: bool = True
    ) -> UserListResponseDTO:
        """List users with pagination."""
        
        if page < 1:
            page = 1
        
        if page_size < 1 or page_size > 1000:
            page_size = 100
        
        offset = (page - 1) * page_size
        
        # Get users
        users =  self._user_repository.list_active_users(
            limit=page_size, 
            offset=offset
        )
        
        # Get total count
        total =  self._user_repository.count_active_users()
        
        # Convert to DTOs
        user_dtos = [UserResponseDTO.model_validate(user) for user in users]
        
        total_pages = math.ceil(total / page_size)
        
        return UserListResponseDTO(
            users=user_dtos,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages
        )
    
     def check_email_availability(self, email: str, excluding_user_id: Optional[UUID] = None) -> bool:
        """Check if email is available for use."""
        email_vo = Email(value=email)
        return  self._user_domain_service.is_email_available(email_vo, excluding_user_id)
from typing import Optional
from uuid import UUID

from ..dtos.session_dto import (
    SessionCreateDTO,
    SessionResponseDTO,
    SessionListResponseDTO,
)
from ...domain.entities.user_session import UserSession
from ...domain.repositories.user_repository import UserRepository
from ...domain.repositories.user_session_repository import UserSessionRepository
from ...domain.services.authentication_service import AuthenticationService


class SessionUseCase:
    """Use cases for session management."""

    def __init__(
        self,
        user_repository: UserRepository,
        session_repository: UserSessionRepository,
        auth_service: AuthenticationService,
    ):
        self._user_repository = user_repository
        self._session_repository = session_repository
        self._auth_service = auth_service

     def create_session(self, dto: SessionCreateDTO) -> SessionResponseDTO:
        """Create a new user session."""

        # Verify user exists and is active
        user = self._user_repository.get_by_id(dto.user_id)

        if not user:
            raise ValueError("User not found")

        if not user.is_active:
            raise ValueError("User account is not active")

        # Generate session token
        session_token = self._generate_session_token()

        # Create session
        session = self._auth_service.create_session(
            user=user,
            token=session_token,
            duration_hours=dto.duration_hours,
            user_agent=dto.user_agent,
            ip_address=dto.ip_address,
        )

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

     def get_session_by_id(self, session_id: UUID) -> Optional[SessionResponseDTO]:
        """Get session by ID."""
        session = self._session_repository.get_by_id(session_id)

        if not session:
            return None

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

     def get_session_by_token(self, token: str) -> Optional[SessionResponseDTO]:
        """Get session by token."""
        session = self._session_repository.get_by_token(token)

        if not session:
            return None

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

     def get_user_sessions(self, user_id: UUID) -> SessionListResponseDTO:
        """Get all sessions for a user."""

        # Get active sessions
        sessions = self._session_repository.get_active_by_user_id(user_id)

        # Convert to DTOs
        session_dtos = []
        active_count = 0

        for session in sessions:
            session_dto = SessionResponseDTO.model_validate(
                {
                    **session.model_dump(),
                    "is_expired": session.is_expired(),
                    "is_valid": session.is_valid(),
                }
            )
            session_dtos.append(session_dto)

            if session_dto.is_valid:
                active_count += 1

        return SessionListResponseDTO(
            sessions=session_dtos, total=len(session_dtos), active_count=active_count
        )

     def revoke_session(self, session_id: UUID) -> bool:
        """Revoke a specific session."""
        session = self._session_repository.get_by_id(session_id)

        if not session:
            return False

        return self._auth_service.revoke_session(session.token)

     def revoke_session_by_token(self, token: str) -> bool:
        """Revoke session by token."""
        return self._auth_service.revoke_session(token)

     def revoke_all_user_sessions(self, user_id: UUID) -> int:
        """Revoke all sessions for a user."""
        return self._auth_service.revoke_all_user_sessions(user_id)

     def extend_session(
        self, session_id: UUID, hours: int = 24
    ) -> Optional[SessionResponseDTO]:
        """Extend session duration."""
        session = self._session_repository.get_by_id(session_id)

        if not session or not session.is_valid():
            return None

        # Extend session
        extended_session = session.extend(hours)
        saved_session = self._session_repository.save(extended_session)

        return SessionResponseDTO.model_validate(
            {
                **saved_session.model_dump(),
                "is_expired": saved_session.is_expired(),
                "is_valid": saved_session.is_valid(),
            }
        )

     def cleanup_expired_sessions(self) -> int:
        """Clean up expired sessions."""
        return self._session_repository.cleanup_expired_sessions()

     def validate_session_access(
        self, token: str, required_permissions: list[str] = None
    ) -> bool:
        """Validate session and optional permissions."""

        # Validate session
        user = self._auth_service.validate_session(token)

        if not user:
            return False

        # If no specific permissions required, just return session validity
        if not required_permissions:
            return True

        # Here you would integrate with authorization service to check permissions
        # For now, assume all authenticated users have basic permissions

        return True

    def _generate_session_token(self) -> str:
        """Generate secure session token."""
        import secrets

        return secrets.token_urlsafe(32)
from .user_use_cases import UserUseCase
from .auth_use_cases import AuthUseCase
from .session_use_cases import SessionUseCase

__all__ = ["UserUseCase", "AuthUseCase", "SessionUseCase"]
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete
from sqlalchemy.exc import IntegrityError

from ...domain.entities.user_session import UserSession
from ...domain.repositories.user_session_repository import UserSessionRepository
from ....infrastructure.database.models.user_models import (
    UserSessionModel,
    SessionStatusEnum,
)


class SqlAlchemyUserSessionRepository(UserSessionRepository):
    """SQLAlchemy implementation of UserSessionRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, session_entity: UserSession) -> UserSession:
        """Save a user session entity."""
        try:
            # Check if session exists
            existing = self.session.get(UserSessionModel, session_entity.id)

            if existing:
                # Update existing session
                existing.user_id = session_entity.user_id
                existing.session_token = session_entity.session_token
                existing.status = SessionStatusEnum(session_entity.status)
                existing.expires_at = session_entity.expires_at
                existing.ip_address = session_entity.ip_address
                existing.user_agent = session_entity.user_agent
                existing.last_activity_at = session_entity.last_activity_at
                existing.logout_at = session_entity.logout_at
                existing.metadata = session_entity.metadata
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new session
                session_model = UserSessionModel(
                    id=session_entity.id,
                    user_id=session_entity.user_id,
                    session_token=session_entity.session_token,
                    status=SessionStatusEnum(session_entity.status),
                    expires_at=session_entity.expires_at,
                    ip_address=session_entity.ip_address,
                    user_agent=session_entity.user_agent,
                    last_activity_at=session_entity.last_activity_at,
                    logout_at=session_entity.logout_at,
                    metadata=session_entity.metadata,
                    created_at=session_entity.created_at,
                    updated_at=session_entity.updated_at,
                )

                self.session.add(session_model)
                self.session.flush()
                return self._to_domain_entity(session_model)

        except IntegrityError as e:
            self.session.rollback()
            if "session_token" in str(e):
                raise ValueError("Session token must be unique")
            raise e

    def find_by_id(self, session_id: UUID) -> Optional[UserSession]:
        """Find a session by ID."""
        result = self.session.execute(
            select(UserSessionModel).where(UserSessionModel.id == session_id)
        )
        session_model = result.scalar_one_or_none()

        if session_model:
            return self._to_domain_entity(session_model)
        return None

    def find_by_token(self, session_token: str) -> Optional[UserSession]:
        """Find a session by token."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.session_token == session_token
            )
        )
        session_model = result.scalar_one_or_none()

        if session_model:
            return self._to_domain_entity(session_model)
        return None

    def find_active_by_user(self, user_id: UUID) -> List[UserSession]:
        """Find all active sessions for a user."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.user_id == user_id,
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
                UserSessionModel.expires_at > datetime.now(timezone.utc),
            )
        )
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def find_expired_sessions(self) -> List[UserSession]:
        """Find all expired sessions."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.expires_at <= datetime.now(timezone.utc),
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
            )
        )
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def find_user_sessions(
        self, user_id: UUID, status: Optional[str] = None, limit: int = 10
    ) -> List[UserSession]:
        """Find sessions for a user with optional status filter."""
        query = select(UserSessionModel).where(UserSessionModel.user_id == user_id)

        if status:
            query = query.where(UserSessionModel.status == SessionStatusEnum(status))

        query = query.order_by(UserSessionModel.last_activity_at.desc()).limit(limit)

        result = self.session.execute(query)
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def delete(self, session_id: UUID) -> bool:
        """Delete a session (hard delete)."""
        result = self.session.execute(
            delete(UserSessionModel).where(UserSessionModel.id == session_id)
        )
        return result.rowcount > 0

    def delete_user_sessions(self, user_id: UUID) -> int:
        """Delete all sessions for a user."""
        result = self.session.execute(
            delete(UserSessionModel).where(UserSessionModel.user_id == user_id)
        )
        return result.rowcount

    def revoke_session(self, session_id: UUID) -> bool:
        """Revoke a session by changing its status."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(UserSessionModel.id == session_id)
            .values(
                status=SessionStatusEnum.REVOKED,
                logout_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc),
            )
        )
        return result.rowcount > 0

    def revoke_user_sessions(
        self, user_id: UUID, exclude_session_id: Optional[UUID] = None
    ) -> int:
        """Revoke all sessions for a user, optionally excluding one session."""
        query = update(UserSessionModel).where(
            UserSessionModel.user_id == user_id,
            UserSessionModel.status == SessionStatusEnum.ACTIVE,
        )

        if exclude_session_id:
            query = query.where(UserSessionModel.id != exclude_session_id)

        query = query.values(
            status=SessionStatusEnum.REVOKED,
            logout_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc),
        )

        result = self.session.execute(query)
        return result.rowcount

    def update_activity(self, session_id: UUID, activity_time: datetime) -> bool:
        """Update session's last activity time."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(UserSessionModel.id == session_id)
            .values(
                last_activity_at=activity_time, updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0

    def cleanup_expired_sessions(self) -> int:
        """Clean up expired sessions by updating their status."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(
                UserSessionModel.expires_at <= datetime.now(timezone.utc),
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
            )
            .values(
                status=SessionStatusEnum.EXPIRED, updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount

    def _to_domain_entity(self, session_model: UserSessionModel) -> UserSession:
        """Convert SQLAlchemy model to domain entity."""
        return UserSession(
            id=session_model.id,
            user_id=session_model.user_id,
            session_token=session_model.session_token,
            status=session_model.status.value,
            expires_at=session_model.expires_at,
            ip_address=session_model.ip_address,
            user_agent=session_model.user_agent,
            last_activity_at=session_model.last_activity_at,
            logout_at=session_model.logout_at,
            metadata=session_model.metadata,
            created_at=session_model.created_at,
            updated_at=session_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete
from sqlalchemy.exc import IntegrityError

from ...domain.entities.user import User
from ...domain.repositories.user_repository import UserRepository
from ...domain.value_objects.email import Email
from ...domain.value_objects.password import Password
from ....infrastructure.database.models.user_models import UserModel


class SqlAlchemyUserRepository(UserRepository):
    """SQLAlchemy implementation of UserRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, user: User) -> User:
        """Save a user entity."""
        try:
            # Check if user exists
            existing = self.session.get(UserModel, user.id)

            if existing:
                # Update existing user
                existing.email = str(user.email.value)
                existing.name = user.name
                existing.password_hash = user.password.hash
                existing.is_active = user.is_active
                existing.is_verified = user.is_verified
                existing.last_login_at = user.last_login_at
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new user
                user_model = UserModel(
                    id=user.id,
                    email=str(user.email.value),
                    name=user.name,
                    password_hash=user.password.hash,
                    is_active=user.is_active,
                    is_verified=user.is_verified,
                    last_login_at=user.last_login_at,
                    created_at=user.created_at,
                    updated_at=user.updated_at,
                )

                self.session.add(user_model)
                self.session.flush()
                return self._to_domain_entity(user_model)

        except IntegrityError as e:
            self.session.rollback()
            if "email" in str(e):
                raise ValueError(f"User with email {user.email.value} already exists")
            raise e

    def find_by_id(self, user_id: UUID) -> Optional[User]:
        """Find a user by ID."""
        result = self.session.execute(select(UserModel).where(UserModel.id == user_id))
        user_model = result.scalar_one_or_none()

        if user_model:
            return self._to_domain_entity(user_model)
        return None

    def find_by_email(self, email: Email) -> Optional[User]:
        """Find a user by email."""
        result = self.session.execute(
            select(UserModel).where(UserModel.email == str(email.value))
        )
        user_model = result.scalar_one_or_none()

        if user_model:
            return self._to_domain_entity(user_model)
        return None

    def find_active_users(self) -> List[User]:
        """Find all active users."""
        result = self.session.execute(select(UserModel).where(UserModel.is_active))
        user_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in user_models]

    def find_paginated(
        self,
        offset: int = 0,
        limit: int = 20,
        email_filter: Optional[str] = None,
        name_filter: Optional[str] = None,
        is_active: Optional[bool] = None,
    ) -> tuple[List[User], int]:
        """Find users with pagination and filters."""
        query = select(UserModel)
        count_query = select(UserModel)

        # Apply filters
        if email_filter:
            query = query.where(UserModel.email.ilike(f"%{email_filter}%"))
            count_query = count_query.where(UserModel.email.ilike(f"%{email_filter}%"))

        if name_filter:
            query = query.where(UserModel.name.ilike(f"%{name_filter}%"))
            count_query = count_query.where(UserModel.name.ilike(f"%{name_filter}%"))

        if is_active is not None:
            query = query.where(UserModel.is_active == is_active)
            count_query = count_query.where(UserModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(UserModel.created_at.desc())
        result = self.session.execute(query)
        user_models = result.scalars().all()

        users = [self._to_domain_entity(model) for model in user_models]
        return users, total

    def delete(self, user_id: UUID) -> bool:
        """Delete a user (hard delete)."""
        result = self.session.execute(delete(UserModel).where(UserModel.id == user_id))
        return result.rowcount > 0

    def exists_by_email(self, email: Email) -> bool:
        """Check if a user with the given email exists."""
        result = self.session.execute(
            select(UserModel.id).where(UserModel.email == str(email.value))
        )
        return result.scalar_one_or_none() is not None

    def count_active_users(self) -> int:
        """Count active users."""
        result = self.session.execute(select(UserModel).where(UserModel.is_active))
        return len(result.scalars().all())

    def find_users_created_after(self, date: datetime) -> List[User]:
        """Find users created after a specific date."""
        result = self.session.execute(
            select(UserModel).where(UserModel.created_at >= date)
        )
        user_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in user_models]

    def update_last_login(self, user_id: UUID, login_time: datetime) -> bool:
        """Update user's last login time."""
        result = self.session.execute(
            update(UserModel)
            .where(UserModel.id == user_id)
            .values(last_login_at=login_time, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def _to_domain_entity(self, user_model: UserModel) -> User:
        """Convert SQLAlchemy model to domain entity."""
        return User(
            id=user_model.id,
            email=Email(user_model.email),
            name=user_model.name,
            password=Password.from_hash(user_model.password_hash),
            is_active=user_model.is_active,
            is_verified=user_model.is_verified,
            last_login_at=user_model.last_login_at,
            created_at=user_model.created_at,
            updated_at=user_model.updated_at,
        )
from .sqlalchemy_user_repository import SqlAlchemyUserRepository
from .sqlalchemy_user_session_repository import SqlAlchemyUserSessionRepository

__all__ = [
    "SqlAlchemyUserRepository",
    "SqlAlchemyUserSessionRepository"
]
from .repositories import SqlAlchemyUserRepository, SqlAlchemyUserSessionRepository

__all__ = [
    "SqlAlchemyUserRepository",
    "SqlAlchemyUserSessionRepository"
]
