from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel
from enum import Enum


class OrganizationRole(str, Enum):
    OWNER = "owner"
    ADMIN = "admin"
    MEMBER = "member"
    VIEWER = "viewer"


class UserOrganizationRole(BaseModel):
    id: UUID
    user_id: UUID
    organization_id: UUID
    role: OrganizationRole
    assigned_by: UUID
    assigned_at: datetime
    expires_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        organization_id: UUID,
        role: OrganizationRole,
        assigned_by: UUID,
        expires_at: Optional[datetime] = None
    ) -> "UserOrganizationRole":
        return cls(
            id=uuid4(),
            user_id=user_id,
            organization_id=organization_id,
            role=role,
            assigned_by=assigned_by,
            assigned_at=datetime.utcnow(),
            expires_at=expires_at,
            is_active=True
        )

    def change_role(self, new_role: OrganizationRole, changed_by: UUID) -> "UserOrganizationRole":
        """Change user role in organization."""
        return self.model_copy(update={
            "role": new_role,
            "assigned_by": changed_by,
            "assigned_at": datetime.utcnow()
        })

    def deactivate(self) -> "UserOrganizationRole":
        """Deactivate user role in organization."""
        return self.model_copy(update={"is_active": False})

    def activate(self) -> "UserOrganizationRole":
        """Activate user role in organization."""
        return self.model_copy(update={"is_active": True})

    def is_expired(self) -> bool:
        """Check if role assignment has expired."""
        if not self.expires_at:
            return False
        return datetime.utcnow() > self.expires_at

    def is_valid(self) -> bool:
        """Check if role assignment is valid (active and not expired)."""
        return self.is_active and not self.is_expired()

    def has_admin_privileges(self) -> bool:
        """Check if role has admin privileges."""
        return self.role in [OrganizationRole.OWNER, OrganizationRole.ADMIN]

    def can_manage_users(self) -> bool:
        """Check if role can manage other users."""
        return self.role in [OrganizationRole.OWNER, OrganizationRole.ADMIN]

    def can_modify_organization(self) -> bool:
        """Check if role can modify organization settings."""
        return self.role == OrganizationRole.OWNER
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List
from pydantic import BaseModel

from ..value_objects.organization_name import OrganizationName
from ..value_objects.organization_settings import OrganizationSettings


class Organization(BaseModel):
    id: UUID
    name: OrganizationName
    description: Optional[str] = None
    owner_id: UUID
    settings: OrganizationSettings
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls, 
        name: str, 
        owner_id: UUID, 
        description: Optional[str] = None,
        max_users: int = 10
    ) -> "Organization":
        return cls(
            id=uuid4(),
            name=OrganizationName(value=name),
            description=description,
            owner_id=owner_id,
            settings=OrganizationSettings.create_default(max_users=max_users),
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "Organization":
        return self.model_copy(update={
            "name": OrganizationName(value=name),
            "updated_at": datetime.utcnow()
        })

    def update_description(self, description: str) -> "Organization":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def transfer_ownership(self, new_owner_id: UUID) -> "Organization":
        return self.model_copy(update={
            "owner_id": new_owner_id,
            "updated_at": datetime.utcnow()
        })

    def update_settings(self, settings: OrganizationSettings) -> "Organization":
        return self.model_copy(update={
            "settings": settings,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Organization":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Organization":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })

    def is_owner(self, user_id: UUID) -> bool:
        """Check if user is the owner of this organization."""
        return self.owner_id == user_id

    def can_add_users(self, current_user_count: int) -> bool:
        """Check if organization can add more users based on settings."""
        return current_user_count < self.settings.max_users

    def validate_user_limit(self, new_user_count: int) -> tuple[bool, str]:
        """Validate if organization can support the new user count."""
        if new_user_count > self.settings.max_users:
            return False, f"Organization exceeds maximum user limit of {self.settings.max_users}"
        return True, "User limit validation passed"
from .organization import Organization
from .user_organization_role import UserOrganizationRole

__all__ = ["Organization", "UserOrganizationRole"]
from typing import List
from uuid import UUID

from ..entities.user_organization_role import UserOrganizationRole, OrganizationRole
from ..repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)
from ..repositories.organization_repository import OrganizationRepository


class MembershipService:
    """Domain service for organization membership logic."""

    def __init__(
        self,
        role_repository: UserOrganizationRoleRepository,
        organization_repository: OrganizationRepository,
    ):
        self._role_repository = role_repository
        self._organization_repository = organization_repository

    def add_user_to_organization(
        self,
        user_id: UUID,
        organization_id: UUID,
        role: OrganizationRole,
        assigned_by: UUID,
    ) -> UserOrganizationRole:
        """Add user to organization with specified role."""
        # Check if user already has a role in this organization
        existing_role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if existing_role and existing_role.is_valid():
            raise ValueError("User already has an active role in this organization")

        # Create new role assignment
        new_role = UserOrganizationRole.create(
            user_id=user_id,
            organization_id=organization_id,
            role=role,
            assigned_by=assigned_by,
        )

        return self._role_repository.save(new_role)

    def change_user_role(
        self,
        user_id: UUID,
        organization_id: UUID,
        new_role: OrganizationRole,
        changed_by: UUID,
    ) -> UserOrganizationRole:
        """Change user's role in organization."""
        current_role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if not current_role or not current_role.is_valid():
            raise ValueError("User does not have an active role in this organization")

        # Prevent changing owner role without proper transfer
        if current_role.role == OrganizationRole.OWNER:
            raise ValueError(
                "Cannot change owner role. Use ownership transfer instead."
            )

        updated_role = current_role.change_role(new_role, changed_by)
        return self._role_repository.save(updated_role)

    def remove_user_from_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> bool:
        """Remove user from organization."""
        # Check if user is organization owner
        organization = self._organization_repository.get_by_id(organization_id)

        if organization and organization.is_owner(user_id):
            raise ValueError(
                "Cannot remove organization owner. Transfer ownership first."
            )

        return self._role_repository.remove_user_from_organization(
            user_id, organization_id
        )

    def get_user_permissions_in_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> List[str]:
        """Get list of permissions user has in organization."""
        role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if not role or not role.is_valid():
            return []

        # Define permissions based on role
        permissions_map = {
            OrganizationRole.OWNER: [
                "manage_organization",
                "manage_users",
                "manage_roles",
                "view_analytics",
                "manage_settings",
                "delete_organization",
                "transfer_ownership",
            ],
            OrganizationRole.ADMIN: [
                "manage_users",
                "manage_roles",
                "view_analytics",
                "manage_settings",
            ],
            OrganizationRole.MEMBER: ["view_organization", "use_features"],
            OrganizationRole.VIEWER: ["view_organization"],
        }

        return permissions_map.get(role.role, [])

    def can_user_perform_action(
        self, user_id: UUID, organization_id: UUID, action: str
    ) -> bool:
        """Check if user can perform specific action in organization."""
        permissions = self.get_user_permissions_in_organization(
            user_id, organization_id
        )
        return action in permissions

    def transfer_ownership(
        self, organization_id: UUID, current_owner_id: UUID, new_owner_id: UUID
    ) -> tuple[UserOrganizationRole, UserOrganizationRole]:
        """Transfer organization ownership."""
        # Get current owner role
        owner_role = self._role_repository.get_by_user_and_organization(
            current_owner_id, organization_id
        )

        if not owner_role or owner_role.role != OrganizationRole.OWNER:
            raise ValueError("Current user is not the organization owner")

        # Get new owner's current role
        new_owner_role = self._role_repository.get_by_user_and_organization(
            new_owner_id, organization_id
        )

        if not new_owner_role or not new_owner_role.is_valid():
            raise ValueError("New owner must be an active member of the organization")

        # Update organization owner
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        updated_organization = organization.transfer_ownership(new_owner_id)
        self._organization_repository.save(updated_organization)

        # Change roles
        demoted_owner = owner_role.change_role(OrganizationRole.ADMIN, new_owner_id)
        promoted_owner = new_owner_role.change_role(
            OrganizationRole.OWNER, current_owner_id
        )

        # Save role changes
        self._role_repository.save(demoted_owner)
        self._role_repository.save(promoted_owner)

        return demoted_owner, promoted_owner
from typing import Optional, List
from uuid import UUID

from ..entities.organization import Organization
from ..entities.user_organization_role import UserOrganizationRole, OrganizationRole
from ..value_objects.organization_name import OrganizationName
from ..repositories.organization_repository import OrganizationRepository
from ..repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)


class OrganizationDomainService:
    """Domain service for organization-specific business logic."""

    def __init__(
        self,
        organization_repository: OrganizationRepository,
        role_repository: UserOrganizationRoleRepository,
    ):
        self._organization_repository = organization_repository
        self._role_repository = role_repository

    def is_organization_name_available(
        self, name: OrganizationName, excluding_org_id: Optional[UUID] = None
    ) -> bool:
        """Check if organization name is available."""
        existing_org = self._organization_repository.get_by_name(name)

        if not existing_org:
            return True

        # If excluding a specific org (for updates), check if it's the same org
        if excluding_org_id and existing_org.id == excluding_org_id:
            return True

        return False

    def can_organization_be_deleted(self, organization_id: UUID) -> tuple[bool, str]:
        """Check if organization can be safely deleted."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return False, "Organization not found"

        # Check if organization has active members
        user_count = self._role_repository.count_organization_users(organization_id)

        if user_count > 1:  # Owner + other members
            return (
                False,
                f"Organization has {user_count} active members and cannot be deleted",
            )

        return True, "Can be deleted"

    def can_user_leave_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> tuple[bool, str]:
        """Check if user can leave organization."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return False, "Organization not found"

        # Owner cannot leave organization
        if organization.is_owner(user_id):
            return False, "Organization owner cannot leave. Transfer ownership first."

        user_role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if not user_role:
            return False, "User is not a member of this organization"

        return True, "User can leave organization"

    def can_transfer_ownership(
        self, organization_id: UUID, current_owner_id: UUID, new_owner_id: UUID
    ) -> tuple[bool, str]:
        """Check if ownership can be transferred."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return False, "Organization not found"

        if not organization.is_owner(current_owner_id):
            return False, "Only organization owner can transfer ownership"

        # Check if new owner is a member of the organization
        new_owner_role = self._role_repository.get_by_user_and_organization(
            new_owner_id, organization_id
        )

        if not new_owner_role or not new_owner_role.is_valid():
            return False, "New owner must be an active member of the organization"

        return True, "Ownership can be transferred"

    def validate_user_addition(
        self, organization_id: UUID, role: OrganizationRole
    ) -> tuple[bool, str]:
        """Validate if a new user can be added to organization."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return False, "Organization not found"

        if not organization.is_active:
            return False, "Cannot add users to inactive organization"

        current_user_count = self._role_repository.count_organization_users(
            organization_id
        )

        if not organization.can_add_users(current_user_count):
            return (
                False,
                f"Organization has reached maximum user limit of {organization.settings.max_users}",
            )

        return True, "User can be added to organization"
from .organization_domain_service import OrganizationDomainService
from .membership_service import MembershipService

__all__ = ["OrganizationDomainService", "MembershipService"]
from pydantic import BaseModel, field_validator
from typing import Dict, Any


class OrganizationSettings(BaseModel):
    max_users: int
    allow_user_registration: bool
    require_email_verification: bool
    session_timeout_hours: int
    features_enabled: Dict[str, bool]
    custom_settings: Dict[str, Any]

    model_config = {"frozen": True}

    @field_validator('max_users')
    @classmethod
    def validate_max_users(cls, v: int) -> int:
        if v < 1:
            raise ValueError("Maximum users must be at least 1")
        if v > 10000:
            raise ValueError("Maximum users cannot exceed 10,000")
        return v

    @field_validator('session_timeout_hours')
    @classmethod
    def validate_session_timeout(cls, v: int) -> int:
        if v < 1:
            raise ValueError("Session timeout must be at least 1 hour")
        if v > 720:  # 30 days
            raise ValueError("Session timeout cannot exceed 720 hours (30 days)")
        return v

    @classmethod
    def create_default(cls, max_users: int = 10) -> "OrganizationSettings":
        return cls(
            max_users=max_users,
            allow_user_registration=True,
            require_email_verification=True,
            session_timeout_hours=24,
            features_enabled={
                "chat_whatsapp": False,
                "chat_iframe": False,
                "api_access": True,
                "custom_branding": False,
                "analytics": True
            },
            custom_settings={}
        )

    def enable_feature(self, feature_name: str) -> "OrganizationSettings":
        """Enable a specific feature."""
        new_features = self.features_enabled.copy()
        new_features[feature_name] = True
        
        return self.model_copy(update={"features_enabled": new_features})

    def disable_feature(self, feature_name: str) -> "OrganizationSettings":
        """Disable a specific feature."""
        new_features = self.features_enabled.copy()
        new_features[feature_name] = False
        
        return self.model_copy(update={"features_enabled": new_features})

    def is_feature_enabled(self, feature_name: str) -> bool:
        """Check if a feature is enabled."""
        return self.features_enabled.get(feature_name, False)

    def update_max_users(self, new_max: int) -> "OrganizationSettings":
        """Update maximum users limit."""
        return self.model_copy(update={"max_users": new_max})

    def update_custom_setting(self, key: str, value: Any) -> "OrganizationSettings":
        """Update a custom setting."""
        new_custom = self.custom_settings.copy()
        new_custom[key] = value
        
        return self.model_copy(update={"custom_settings": new_custom})

    def get_custom_setting(self, key: str, default: Any = None) -> Any:
        """Get a custom setting value."""
        return self.custom_settings.get(key, default)
from pydantic import BaseModel, field_validator
from typing import Any
import re


class OrganizationName(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Organization name cannot be empty")
        
        cleaned_name = v.strip()
        
        if len(cleaned_name) < 2:
            raise ValueError("Organization name must be at least 2 characters long")
        
        if len(cleaned_name) > 100:
            raise ValueError("Organization name cannot exceed 100 characters")
        
        # Allow letters, numbers, spaces, hyphens, and underscores
        if not re.match(r'^[a-zA-Z0-9\s\-_]+$', cleaned_name):
            raise ValueError("Organization name can only contain letters, numbers, spaces, hyphens, and underscores")
        
        return cleaned_name

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, OrganizationName):
            return self.value == other.value
        return False

    def to_slug(self) -> str:
        """Convert name to URL-friendly slug."""
        return re.sub(r'[^a-zA-Z0-9\-_]', '-', self.value.lower()).strip('-')
from .organization_name import OrganizationName
from .organization_settings import OrganizationSettings

__all__ = ["OrganizationName", "OrganizationSettings"]
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.organization import Organization
from ..value_objects.organization_name import OrganizationName


class OrganizationRepository(ABC):
    """Organization repository interface for the Organization bounded context."""

    @abstractmethod
    def save(self, organization: Organization) -> Organization:
        """Save or update an organization."""
        pass

    @abstractmethod
    def get_by_id(self, organization_id: UUID) -> Optional[Organization]:
        """Get organization by ID."""
        pass

    @abstractmethod
    def get_by_name(self, name: OrganizationName) -> Optional[Organization]:
        """Get organization by name."""
        pass

    @abstractmethod
    def get_by_owner_id(self, owner_id: UUID) -> List[Organization]:
        """Get organizations owned by a user."""
        pass

    @abstractmethod
    def exists_by_name(self, name: OrganizationName) -> bool:
        """Check if organization exists by name."""
        pass

    @abstractmethod
    def delete(self, organization_id: UUID) -> bool:
        """Delete organization by ID."""
        pass

    @abstractmethod
    def list_active_organizations(
        self, limit: int = 100, offset: int = 0
    ) -> List[Organization]:
        """List active organizations with pagination."""
        pass

    @abstractmethod
    def count_active_organizations(self) -> int:
        """Count total active organizations."""
        pass

    @abstractmethod
    def get_user_organizations(self, user_id: UUID) -> List[Organization]:
        """Get organizations where user is a member."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.user_organization_role import UserOrganizationRole, OrganizationRole


class UserOrganizationRoleRepository(ABC):
    """User organization role repository interface for the Organization bounded context."""

    @abstractmethod
    def save(self, role: UserOrganizationRole) -> UserOrganizationRole:
        """Save or update a user organization role."""
        pass

    @abstractmethod
    def get_by_id(self, role_id: UUID) -> Optional[UserOrganizationRole]:
        """Get role by ID."""
        pass

    @abstractmethod
    def get_by_user_and_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> Optional[UserOrganizationRole]:
        """Get role by user and organization."""
        pass

    @abstractmethod
    def get_user_roles_in_organization(
        self, organization_id: UUID
    ) -> List[UserOrganizationRole]:
        """Get all user roles in an organization."""
        pass

    @abstractmethod
    def get_user_organizations(self, user_id: UUID) -> List[UserOrganizationRole]:
        """Get all organizations where user has a role."""
        pass

    @abstractmethod
    def user_has_role_in_organization(
        self, user_id: UUID, organization_id: UUID, role: OrganizationRole
    ) -> bool:
        """Check if user has specific role in organization."""
        pass

    @abstractmethod
    def count_organization_users(self, organization_id: UUID) -> int:
        """Count active users in organization."""
        pass

    @abstractmethod
    def remove_user_from_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> bool:
        """Remove user from organization."""
        pass

    @abstractmethod
    def delete(self, role_id: UUID) -> bool:
        """Delete role by ID."""
        pass

    @abstractmethod
    def cleanup_expired_roles(self) -> int:
        """Cleanup expired roles. Returns count of cleaned roles."""
        pass
from .organization_repository import OrganizationRepository
from .user_organization_role_repository import UserOrganizationRoleRepository

__all__ = ["OrganizationRepository", "UserOrganizationRoleRepository"]
from .entities import Organization, UserOrganizationRole
from .value_objects import OrganizationName, OrganizationSettings
from .repositories import OrganizationRepository, UserOrganizationRoleRepository
from .services import OrganizationDomainService, MembershipService

__all__ = [
    "Organization", 
    "UserOrganizationRole",
    "OrganizationName", 
    "OrganizationSettings",
    "OrganizationRepository", 
    "UserOrganizationRoleRepository",
    "OrganizationDomainService",
    "MembershipService"
]
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status, Query
from pydantic import BaseModel

from ..application.dtos.organization_dto import (
    OrganizationCreateDTO,
    OrganizationUpdateDTO,
    OrganizationSettingsUpdateDTO,
    OrganizationResponseDTO,
    OrganizationListResponseDTO,
    OrganizationDetailResponseDTO,
)
from ..application.use_cases.organization_use_cases import OrganizationUseCase
from .dependencies import get_organization_use_case


organization_router = APIRouter(prefix="/organizations", tags=["organizations"])


class OrganizationOwnershipTransferRequest(BaseModel):
    new_owner_id: UUID


@organization_router.post(
    "/",
    response_model=OrganizationResponseDTO,
    status_code=status.HTTP_201_CREATED,
    summary="Create Organization",
    description="Create a new organization. The creator becomes the owner.",
)
def create_organization(
    organization_data: OrganizationCreateDTO,
    current_user_id: UUID = Depends(),  # This would come from auth middleware
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
) -> OrganizationResponseDTO:
    try:
        return use_case.create_organization(organization_data, current_user_id)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create organization",
        )


@organization_router.get(
    "/",
    response_model=OrganizationListResponseDTO,
    summary="List Organizations",
    description="Get a paginated list of organizations.",
)
def list_organizations(
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(100, ge=1, le=1000, description="Number of organizations per page"),
    active_only: bool = Query(True, description="Filter for active organizations only"),
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
) -> OrganizationListResponseDTO:
    try:
        return use_case.list_organizations(page, page_size, active_only)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to list organizations",
        )


@organization_router.get(
    "/{organization_id}",
    response_model=OrganizationResponseDTO,
    summary="Get Organization",
    description="Get organization details by ID.",
)
def get_organization(
    organization_id: UUID,
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
) -> OrganizationResponseDTO:
    try:
        organization = use_case.get_organization_by_id(organization_id)
        if not organization:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Organization not found",
            )
        return organization
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get organization",
        )


@organization_router.get(
    "/{organization_id}/detail",
    response_model=OrganizationDetailResponseDTO,
    summary="Get Organization Detail",
    description="Get detailed organization information including members.",
)
def get_organization_detail(
    organization_id: UUID,
    current_user_id: UUID = Depends(),  # This would come from auth middleware
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
) -> OrganizationDetailResponseDTO:
    try:
        organization = use_case.get_organization_detail(organization_id)
        if not organization:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Organization not found",
            )
        return organization
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get organization detail",
        )


@organization_router.put(
    "/{organization_id}",
    response_model=OrganizationResponseDTO,
    summary="Update Organization",
    description="Update organization information.",
)
def update_organization(
    organization_id: UUID,
    update_data: OrganizationUpdateDTO,
    current_user_id: UUID = Depends(),  # This would come from auth middleware
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
) -> OrganizationResponseDTO:
    try:
        return use_case.update_organization(organization_id, update_data, current_user_id)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update organization",
        )


@organization_router.put(
    "/{organization_id}/settings",
    response_model=OrganizationResponseDTO,
    summary="Update Organization Settings",
    description="Update organization settings.",
)
def update_organization_settings(
    organization_id: UUID,
    settings_data: OrganizationSettingsUpdateDTO,
    current_user_id: UUID = Depends(),  # This would come from auth middleware
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
) -> OrganizationResponseDTO:
    try:
        return use_case.update_organization_settings(
            organization_id, settings_data, current_user_id
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update organization settings",
        )


@organization_router.post(
    "/{organization_id}/transfer-ownership",
    response_model=OrganizationResponseDTO,
    summary="Transfer Ownership",
    description="Transfer organization ownership to another user.",
)
def transfer_ownership(
    organization_id: UUID,
    transfer_request: OrganizationOwnershipTransferRequest,
    current_user_id: UUID = Depends(),  # This would come from auth middleware
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
) -> OrganizationResponseDTO:
    try:
        return use_case.transfer_ownership(
            organization_id, current_user_id, transfer_request.new_owner_id
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to transfer ownership",
        )


@organization_router.delete(
    "/{organization_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Deactivate Organization",
    description="Deactivate an organization.",
)
def deactivate_organization(
    organization_id: UUID,
    current_user_id: UUID = Depends(),  # This would come from auth middleware
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
):
    try:
        use_case.deactivate_organization(organization_id, current_user_id)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to deactivate organization",
        )


@organization_router.get(
    "/user/{user_id}",
    response_model=List[OrganizationResponseDTO],
    summary="Get User Organizations",
    description="Get all organizations where a user is a member.",
)
def get_user_organizations(
    user_id: UUID,
    current_user_id: UUID = Depends(),  # This would come from auth middleware
    use_case: OrganizationUseCase = Depends(get_organization_use_case),
) -> List[OrganizationResponseDTO]:
    try:
        return use_case.get_user_organizations(user_id)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get user organizations",
        )
from fastapi import Depends
from sqlalchemy.orm import Session

from shared.infrastructure.database.connection import get_db
from ..application.use_cases.organization_use_cases import OrganizationUseCase
from ..application.use_cases.membership_use_cases import MembershipUseCase
from ..infrastructure.organization_unit_of_work import OrganizationUnitOfWork


def get_organization_uow(db: Session = Depends(get_db)) -> OrganizationUnitOfWork:
    """Get an OrganizationUnitOfWork instance with organization and user_organization_role repositories."""
    return OrganizationUnitOfWork(db, ["organization", "user_organization_role"])


def get_organization_use_case(
    uow: OrganizationUnitOfWork = Depends(get_organization_uow),
) -> OrganizationUseCase:
    """Get organization use case with proper UnitOfWork dependency."""
    return OrganizationUseCase(uow)


def get_membership_use_case(
    uow: OrganizationUnitOfWork = Depends(get_organization_uow),
) -> MembershipUseCase:
    """Get membership use case with proper UnitOfWork dependency."""
    return MembershipUseCase(uow)
from .routes import organization_router

__all__ = ["organization_router"]
from datetime import datetime
from typing import Optional, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, field_validator


class OrganizationCreateDTO(BaseModel):
    """DTO for creating a new organization."""
    name: str = Field(..., min_length=2, max_length=100, description="Organization name")
    description: Optional[str] = Field(None, max_length=500, description="Organization description")
    max_users: int = Field(10, ge=1, le=1000, description="Maximum users allowed")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Organization name cannot be empty')
        return v.strip()


class OrganizationUpdateDTO(BaseModel):
    """DTO for updating an existing organization."""
    name: Optional[str] = Field(None, min_length=2, max_length=100, description="Organization name")
    description: Optional[str] = Field(None, max_length=500, description="Organization description")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: Optional[str]) -> Optional[str]:
        if v is not None and not v.strip():
            raise ValueError('Organization name cannot be empty')
        return v.strip() if v else None


class OrganizationSettingsUpdateDTO(BaseModel):
    """DTO for updating organization settings."""
    max_users: Optional[int] = Field(None, ge=1, le=1000, description="Maximum users allowed")
    allow_user_registration: Optional[bool] = Field(None, description="Allow user registration")
    require_email_verification: Optional[bool] = Field(None, description="Require email verification")
    session_timeout_hours: Optional[int] = Field(None, ge=1, le=720, description="Session timeout in hours")
    features_enabled: Optional[Dict[str, bool]] = Field(None, description="Enabled features")
    custom_settings: Optional[Dict[str, Any]] = Field(None, description="Custom settings")


class OrganizationResponseDTO(BaseModel):
    """DTO for organization response data."""
    id: UUID
    name: str
    description: Optional[str] = None
    owner_id: UUID
    max_users: int
    current_user_count: int
    settings: Dict[str, Any]
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    model_config = {"from_attributes": True}


class OrganizationListResponseDTO(BaseModel):
    """DTO for paginated organization list response."""
    organizations: list[OrganizationResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class OrganizationMemberSummaryDTO(BaseModel):
    """DTO for organization member summary."""
    user_id: UUID
    user_name: str
    user_email: str
    role: str
    joined_at: datetime
    is_active: bool


class OrganizationDetailResponseDTO(OrganizationResponseDTO):
    """DTO for detailed organization response with members."""
    members: list[OrganizationMemberSummaryDTO]
    member_count: int
    roles_distribution: Dict[str, int]
from .organization_dto import (
    OrganizationCreateDTO, OrganizationUpdateDTO, OrganizationResponseDTO, 
    OrganizationListResponseDTO
)
from .membership_dto import (
    MembershipCreateDTO, MembershipUpdateDTO, MembershipResponseDTO,
    MembershipListResponseDTO, OwnershipTransferDTO
)

__all__ = [
    "OrganizationCreateDTO", "OrganizationUpdateDTO", "OrganizationResponseDTO",
    "OrganizationListResponseDTO", "MembershipCreateDTO", "MembershipUpdateDTO", 
    "MembershipResponseDTO", "MembershipListResponseDTO", "OwnershipTransferDTO"
]
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field
from enum import Enum


class OrganizationRoleEnum(str, Enum):
    OWNER = "owner"
    ADMIN = "admin"
    MEMBER = "member"
    VIEWER = "viewer"


class MembershipCreateDTO(BaseModel):
    """DTO for adding a user to an organization."""
    user_id: UUID = Field(..., description="User ID to add")
    role: OrganizationRoleEnum = Field(OrganizationRoleEnum.MEMBER, description="Role to assign")
    expires_at: Optional[datetime] = Field(None, description="Role expiration date")


class MembershipUpdateDTO(BaseModel):
    """DTO for updating a user's role in an organization."""
    role: OrganizationRoleEnum = Field(..., description="New role to assign")
    expires_at: Optional[datetime] = Field(None, description="Role expiration date")


class MembershipResponseDTO(BaseModel):
    """DTO for membership response data."""
    id: UUID
    user_id: UUID
    organization_id: UUID
    role: str
    assigned_by: UUID
    assigned_at: datetime
    expires_at: Optional[datetime] = None
    is_active: bool
    user_name: str
    user_email: str
    organization_name: str
    
    model_config = {"from_attributes": True}


class MembershipListResponseDTO(BaseModel):
    """DTO for paginated membership list response."""
    memberships: list[MembershipResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class OwnershipTransferDTO(BaseModel):
    """DTO for transferring organization ownership."""
    new_owner_id: UUID = Field(..., description="User ID of the new owner")
    
    @field_validator('new_owner_id')
    @classmethod
    def validate_new_owner_id(cls, v: UUID) -> UUID:
        if not v:
            raise ValueError('New owner ID is required')
        return v


class MembershipInviteDTO(BaseModel):
    """DTO for inviting a user to an organization."""
    email: str = Field(..., description="Email of user to invite")
    role: OrganizationRoleEnum = Field(OrganizationRoleEnum.MEMBER, description="Role to assign")
    message: Optional[str] = Field(None, max_length=500, description="Invitation message")


class UserOrganizationSummaryDTO(BaseModel):
    """DTO for user's organization summary."""
    organization_id: UUID
    organization_name: str
    role: str
    is_owner: bool
    joined_at: datetime
    member_count: int
    is_active: bool


class UserOrganizationsResponseDTO(BaseModel):
    """DTO for user's organizations list."""
    organizations: list[UserOrganizationSummaryDTO]
    total: int
    owned_count: int
    member_count: int
from .dtos import (
    OrganizationCreateDTO, OrganizationUpdateDTO, OrganizationResponseDTO,
    MembershipCreateDTO, MembershipUpdateDTO, MembershipResponseDTO,
    OwnershipTransferDTO
)
from .use_cases import OrganizationUseCase, MembershipUseCase

__all__ = [
    # DTOs
    "OrganizationCreateDTO", "OrganizationUpdateDTO", "OrganizationResponseDTO",
    "MembershipCreateDTO", "MembershipUpdateDTO", "MembershipResponseDTO",
    "OwnershipTransferDTO",
    
    # Use Cases
    "OrganizationUseCase", "MembershipUseCase"
]
from typing import Optional
from uuid import UUID
import math

from shared.domain.repositories.unit_of_work import UnitOfWork

from ..dtos.membership_dto import (
    MembershipCreateDTO,
    MembershipUpdateDTO,
    MembershipResponseDTO,
    MembershipListResponseDTO,
    OwnershipTransferDTO,
    MembershipInviteDTO,
    UserOrganizationSummaryDTO,
    UserOrganizationsResponseDTO,
)
from ...domain.entities.user_organization_role import (
    OrganizationRole,
)
from ...domain.repositories.organization_repository import OrganizationRepository
from ...domain.repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)
from ...domain.services.organization_domain_service import OrganizationDomainService
from ...domain.services.membership_service import MembershipService


class MembershipUseCase:
    """Use cases for organization membership management."""

    def __init__(self, uow: UnitOfWork):
        self._organization_repository: OrganizationRepository = uow.get_repository("organization")
        self._role_repository: UserOrganizationRoleRepository = uow.get_repository("user_organization_role")
        self._organization_domain_service = OrganizationDomainService(uow)
        self._membership_service = MembershipService(uow)
        self._uow = uow

    def add_member(
        self, organization_id: UUID, dto: MembershipCreateDTO, assigned_by: UUID
    ) -> MembershipResponseDTO:
        """Add a user to an organization."""
        with self._uow:
            # Check if organization exists
            organization = self._organization_repository.get_by_id(organization_id)
            if not organization:
                raise ValueError("Organization not found")

            # Check if user can manage members
            assigner_role = self._role_repository.get_by_user_and_organization(
                assigned_by, organization_id
            )

            if not assigner_role or not assigner_role.can_manage_users():
                raise ValueError(
                    "User does not have permission to manage organization members"
                )

            # Validate user addition
            can_add, reason = self._organization_domain_service.validate_user_addition(
                organization_id, dto.role
            )

            if not can_add:
                raise ValueError(f"Cannot add user: {reason}")

            # Add user to organization
            role = self._membership_service.add_user_to_organization(
                user_id=dto.user_id,
                organization_id=organization_id,
                role=dto.role,
                assigned_by=assigned_by,
            )

        return MembershipResponseDTO(
            **role.model_dump(),
            user_name="User Name",  # Would fetch from user service
            user_email="user@example.com",  # Would fetch from user service
            organization_name=organization.name.value,
        )

    def update_member_role(
        self,
        organization_id: UUID,
        user_id: UUID,
        dto: MembershipUpdateDTO,
        updated_by: UUID,
    ) -> MembershipResponseDTO:
        """Update a member's role in an organization."""
        with self._uow:
            # Check if organization exists
            organization = self._organization_repository.get_by_id(organization_id)
            if not organization:
                raise ValueError("Organization not found")

            # Check permissions
            updater_role = self._role_repository.get_by_user_and_organization(
                updated_by, organization_id
            )

            if not updater_role or not updater_role.can_manage_users():
                raise ValueError(
                    "User does not have permission to manage organization members"
                )

            # Update role
            updated_role = self._membership_service.change_user_role(
                user_id=user_id,
                organization_id=organization_id,
                new_role=dto.role,
                changed_by=updated_by,
            )

        return MembershipResponseDTO(
            **updated_role.model_dump(),
            user_name="User Name",  # Would fetch from user service
            user_email="user@example.com",  # Would fetch from user service
            organization_name=organization.name.value,
        )

    def remove_member(
        self, organization_id: UUID, user_id: UUID, removed_by: UUID
    ) -> bool:
        """Remove a user from an organization."""
        with self._uow:
            # Check if organization exists
            organization = self._organization_repository.get_by_id(organization_id)
            if not organization:
                raise ValueError("Organization not found")

            # Check permissions (can remove others or themselves)
            remover_role = self._role_repository.get_by_user_and_organization(
                removed_by, organization_id
            )

            can_remove_others = remover_role and remover_role.can_manage_users()
            is_self_removal = removed_by == user_id

            if not can_remove_others and not is_self_removal:
                raise ValueError("User does not have permission to remove this member")

            # Check if user can leave organization
            if is_self_removal:
                can_leave, reason = (
                    self._organization_domain_service.can_user_leave_organization(
                        user_id, organization_id
                    )
                )

                if not can_leave:
                    raise ValueError(f"Cannot leave organization: {reason}")

            # Remove user from organization
            result = self._membership_service.remove_user_from_organization(
                user_id, organization_id
            )

        return result

    def get_organization_members(
        self, organization_id: UUID, page: int = 1, page_size: int = 100
    ) -> MembershipListResponseDTO:
        """Get paginated list of organization members."""

        if page < 1:
            page = 1

        if page_size < 1 or page_size > 1000:
            page_size = 100

        # Get organization to verify it exists
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        # Get all user roles in organization
        user_roles = self._role_repository.get_user_roles_in_organization(
            organization_id
        )

        # Filter active roles and paginate
        active_roles = [role for role in user_roles if role.is_valid()]
        total = len(active_roles)

        offset = (page - 1) * page_size
        paginated_roles = active_roles[offset : offset + page_size]

        # Convert to DTOs
        membership_dtos = []
        for role in paginated_roles:
            dto = MembershipResponseDTO(
                **role.model_dump(),
                user_name="User Name",  # Would fetch from user service
                user_email="user@example.com",  # Would fetch from user service
                organization_name=organization.name.value,
            )
            membership_dtos.append(dto)

        total_pages = math.ceil(total / page_size)

        return MembershipListResponseDTO(
            memberships=membership_dtos,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_user_membership(
        self, user_id: UUID, organization_id: UUID
    ) -> Optional[MembershipResponseDTO]:
        """Get user's membership in a specific organization."""

        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            return None

        role = self._role_repository.get_by_user_and_organization(
            user_id, organization_id
        )

        if not role or not role.is_valid():
            return None

        return MembershipResponseDTO(
            **role.model_dump(),
            user_name="User Name",  # Would fetch from user service
            user_email="user@example.com",  # Would fetch from user service
            organization_name=organization.name.value,
        )

    def get_user_organizations(self, user_id: UUID) -> UserOrganizationsResponseDTO:
        """Get all organizations where user is a member."""

        user_roles = self._role_repository.get_user_organizations(user_id)

        organizations = []
        owned_count = 0

        for role in user_roles:
            if role.is_valid():
                organization = self._organization_repository.get_by_id(
                    role.organization_id
                )

                if organization:
                    member_count = self._role_repository.count_organization_users(
                        organization.id
                    )

                    is_owner = role.role == OrganizationRole.OWNER
                    if is_owner:
                        owned_count += 1

                    org_summary = UserOrganizationSummaryDTO(
                        organization_id=organization.id,
                        organization_name=organization.name.value,
                        role=role.role.value,
                        is_owner=is_owner,
                        joined_at=role.assigned_at,
                        member_count=member_count,
                        is_active=organization.is_active,
                    )
                    organizations.append(org_summary)

        return UserOrganizationsResponseDTO(
            organizations=organizations,
            total=len(organizations),
            owned_count=owned_count,
            member_count=len(organizations) - owned_count,
        )

    def transfer_ownership(
        self, organization_id: UUID, dto: OwnershipTransferDTO, current_owner_id: UUID
    ) -> MembershipResponseDTO:
        """Transfer organization ownership."""
        with self._uow:
            # Validate transfer
            can_transfer, reason = self._organization_domain_service.can_transfer_ownership(
                organization_id, current_owner_id, dto.new_owner_id
            )

            if not can_transfer:
                raise ValueError(f"Cannot transfer ownership: {reason}")

            # Perform transfer
            old_role, new_role = self._membership_service.transfer_ownership(
                organization_id, current_owner_id, dto.new_owner_id
            )

            # Get organization for response
            organization = self._organization_repository.get_by_id(organization_id)

        return MembershipResponseDTO(
            **new_role.model_dump(),
            user_name="New Owner Name",  # Would fetch from user service
            user_email="newowner@example.com",  # Would fetch from user service
            organization_name=organization.name.value,
        )

    def invite_user(
        self, organization_id: UUID, dto: MembershipInviteDTO, invited_by: UUID
    ) -> bool:
        """Invite a user to join an organization."""

        # Check if organization exists
        organization = self._organization_repository.get_by_id(organization_id)
        if not organization:
            raise ValueError("Organization not found")

        # Check permissions
        inviter_role = self._role_repository.get_by_user_and_organization(
            invited_by, organization_id
        )

        if not inviter_role or not inviter_role.can_manage_users():
            raise ValueError("User does not have permission to invite members")

        # Validate user addition
        can_add, reason = self._organization_domain_service.validate_user_addition(
            organization_id, dto.role
        )

        if not can_add:
            raise ValueError(f"Cannot invite user: {reason}")

        # In a real implementation, this would:
        # 1. Create an invitation record
        # 2. Send an email invitation
        # 3. Generate invitation token

        return True

    def get_user_permissions(self, user_id: UUID, organization_id: UUID) -> list[str]:
        """Get user's permissions in an organization."""

        return self._membership_service.get_user_permissions_in_organization(
            user_id, organization_id
        )

    def check_user_permission(
        self, user_id: UUID, organization_id: UUID, action: str
    ) -> bool:
        """Check if user can perform specific action in organization."""

        return self._membership_service.can_user_perform_action(
            user_id, organization_id, action
        )
from typing import Optional
from uuid import UUID
import math

from shared.domain.repositories.unit_of_work import UnitOfWork

from ..dtos.organization_dto import (
    OrganizationCreateDTO,
    OrganizationUpdateDTO,
    OrganizationSettingsUpdateDTO,
    OrganizationResponseDTO,
    OrganizationListResponseDTO,
    OrganizationDetailResponseDTO,
    OrganizationMemberSummaryDTO,
)
from ...domain.entities.organization import Organization
from ...domain.entities.user_organization_role import (
    UserOrganizationRole,
    OrganizationRole,
)
from ...domain.repositories.organization_repository import OrganizationRepository
from ...domain.repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)
from ...domain.services.organization_domain_service import OrganizationDomainService
from ...domain.services.membership_service import MembershipService
from ...domain.value_objects.organization_name import OrganizationName


class OrganizationUseCase:
    """Use cases for organization management."""

    def __init__(self, uow: UnitOfWork):
        self._organization_repository: OrganizationRepository = uow.get_repository("organization")
        self._role_repository: UserOrganizationRoleRepository = uow.get_repository("user_organization_role")
        self._organization_domain_service = OrganizationDomainService(uow)
        self._membership_service = MembershipService(uow)
        self._uow = uow

    def create_organization(
        self, dto: OrganizationCreateDTO, owner_id: UUID
    ) -> OrganizationResponseDTO:
        """Create a new organization."""
        with self._uow:
            # Check if organization name is available
            org_name = OrganizationName(value=dto.name)
            is_available = self._organization_domain_service.is_organization_name_available(
                org_name
            )

            if not is_available:
                raise ValueError(f"Organization name '{dto.name}' is already in use")

            # Create organization entity
            organization = Organization.create(
                name=dto.name,
                owner_id=owner_id,
                description=dto.description,
                max_users=dto.max_users,
            )

            # Save organization
            saved_org = self._organization_repository.save(organization)

            # Create owner role
            self._membership_service.add_user_to_organization(
                user_id=owner_id,
                organization_id=saved_org.id,
                role=OrganizationRole.OWNER,
                assigned_by=owner_id,
            )

            # Get current user count
            user_count = self._role_repository.count_organization_users(saved_org.id)

        return OrganizationResponseDTO(
            **saved_org.model_dump(),
            current_user_count=user_count,
            max_users=dto.max_users,
            settings=saved_org.settings.model_dump(),
        )

    def get_organization_by_id(
        self, organization_id: UUID
    ) -> Optional[OrganizationResponseDTO]:
        """Get organization by ID."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return None

        # Get current user count
        user_count = self._role_repository.count_organization_users(organization_id)

        return OrganizationResponseDTO(
            **organization.model_dump(),
            current_user_count=user_count,
            max_users=organization.settings.max_users,
            settings=organization.settings.model_dump(),
        )

    def get_organization_detail(
        self, organization_id: UUID
    ) -> Optional[OrganizationDetailResponseDTO]:
        """Get detailed organization information with members."""
        organization = self._organization_repository.get_by_id(organization_id)

        if not organization:
            return None

        # Get organization members
        user_roles = self._role_repository.get_user_roles_in_organization(
            organization_id
        )

        # Convert to member summary DTOs
        members = []
        roles_distribution = {}

        for role in user_roles:
            if role.is_valid():
                # This would typically require joining with user data
                member = OrganizationMemberSummaryDTO(
                    user_id=role.user_id,
                    user_name="User Name",  # Would fetch from user service
                    user_email="user@example.com",  # Would fetch from user service
                    role=role.role.value,
                    joined_at=role.assigned_at,
                    is_active=role.is_active,
                )
                members.append(member)

                # Count roles
                role_name = role.role.value
                roles_distribution[role_name] = roles_distribution.get(role_name, 0) + 1

        return OrganizationDetailResponseDTO(
            **organization.model_dump(),
            current_user_count=len(members),
            max_users=organization.settings.max_users,
            settings=organization.settings.model_dump(),
            members=members,
            member_count=len(members),
            roles_distribution=roles_distribution,
        )

    def update_organization(
        self, organization_id: UUID, dto: OrganizationUpdateDTO, updated_by: UUID
    ) -> OrganizationResponseDTO:
        """Update organization information."""
        with self._uow:
            organization = self._organization_repository.get_by_id(organization_id)

            if not organization:
                raise ValueError("Organization not found")

            # Check if user can modify organization
            user_role = self._role_repository.get_by_user_and_organization(
                updated_by, organization_id
            )

            if not user_role or not user_role.can_modify_organization():
                raise ValueError("User does not have permission to modify organization")

            updated_org = organization

            # Update name if provided
            if dto.name is not None:
                org_name = OrganizationName(value=dto.name)
                is_available = (
                    self._organization_domain_service.is_organization_name_available(
                        org_name, organization_id
                    )
                )
                if not is_available:
                    raise ValueError(f"Organization name '{dto.name}' is already in use")

                updated_org = updated_org.update_name(dto.name)

            # Update description if provided
            if dto.description is not None:
                updated_org = updated_org.update_description(dto.description)

            # Save updated organization
            saved_org = self._organization_repository.save(updated_org)

            # Get current user count
            user_count = self._role_repository.count_organization_users(organization_id)

        return OrganizationResponseDTO(
            **saved_org.model_dump(),
            current_user_count=user_count,
            max_users=saved_org.settings.max_users,
            settings=saved_org.settings.model_dump(),
        )

    def update_organization_settings(
        self,
        organization_id: UUID,
        dto: OrganizationSettingsUpdateDTO,
        updated_by: UUID,
    ) -> OrganizationResponseDTO:
        """Update organization settings."""
        with self._uow:
            organization = self._organization_repository.get_by_id(organization_id)

            if not organization:
                raise ValueError("Organization not found")

            # Check permissions
            user_role = self._role_repository.get_by_user_and_organization(
                updated_by, organization_id
            )

            if not user_role or not user_role.can_modify_organization():
                raise ValueError(
                    "User does not have permission to modify organization settings"
                )

            # Update settings
            updated_settings = organization.settings

            if dto.max_users is not None:
                # Validate new max_users doesn't violate current user count
                current_user_count = self._role_repository.count_organization_users(
                    organization_id
                )
                if dto.max_users < current_user_count:
                    raise ValueError(
                        f"Cannot reduce max users below current count: {current_user_count}"
                    )

                updated_settings = updated_settings.update_max_users(dto.max_users)

            if dto.allow_user_registration is not None:
                updated_settings = updated_settings.update_custom_setting(
                    "allow_user_registration", dto.allow_user_registration
                )

            if dto.require_email_verification is not None:
                updated_settings = updated_settings.update_custom_setting(
                    "require_email_verification", dto.require_email_verification
                )

            if dto.session_timeout_hours is not None:
                updated_settings = updated_settings.update_custom_setting(
                    "session_timeout_hours", dto.session_timeout_hours
                )

            if dto.features_enabled is not None:
                for feature, enabled in dto.features_enabled.items():
                    if enabled:
                        updated_settings = updated_settings.enable_feature(feature)
                    else:
                        updated_settings = updated_settings.disable_feature(feature)

            if dto.custom_settings is not None:
                for key, value in dto.custom_settings.items():
                    updated_settings = updated_settings.update_custom_setting(key, value)

            # Update organization with new settings
            updated_org = organization.update_settings(updated_settings)
            saved_org = self._organization_repository.save(updated_org)

            # Get current user count
            user_count = self._role_repository.count_organization_users(organization_id)

        return OrganizationResponseDTO(
            **saved_org.model_dump(),
            current_user_count=user_count,
            max_users=updated_settings.max_users,
            settings=updated_settings.model_dump(),
        )

    def deactivate_organization(
        self, organization_id: UUID, deactivated_by: UUID
    ) -> bool:
        """Deactivate an organization."""
        with self._uow:
            organization = self._organization_repository.get_by_id(organization_id)

            if not organization:
                raise ValueError("Organization not found")

            # Check if user is owner
            if not organization.is_owner(deactivated_by):
                raise ValueError("Only organization owner can deactivate the organization")

            # Check if organization can be safely deactivated
            (
                can_delete,
                reason,
            ) = self._organization_domain_service.can_organization_be_deleted(
                organization_id
            )

            if not can_delete:
                raise ValueError(f"Cannot deactivate organization: {reason}")

            # Deactivate organization
            updated_org = organization.deactivate()
            self._organization_repository.save(updated_org)

        return True

    def transfer_ownership(
        self, organization_id: UUID, current_owner_id: UUID, new_owner_id: UUID
    ) -> OrganizationResponseDTO:
        """Transfer organization ownership."""
        with self._uow:
            # Validate transfer
            (
                can_transfer,
                reason,
            ) = self._organization_domain_service.can_transfer_ownership(
                organization_id, current_owner_id, new_owner_id
            )

            if not can_transfer:
                raise ValueError(f"Cannot transfer ownership: {reason}")

            # Perform transfer
            self._membership_service.transfer_ownership(
                organization_id, current_owner_id, new_owner_id
            )

        # Return updated organization
        return self.get_organization_by_id(organization_id)

    def list_organizations(
        self, page: int = 1, page_size: int = 100, active_only: bool = True
    ) -> OrganizationListResponseDTO:
        """List organizations with pagination."""

        if page < 1:
            page = 1

        if page_size < 1 or page_size > 1000:
            page_size = 100

        offset = (page - 1) * page_size

        # Get organizations
        organizations = self._organization_repository.list_active_organizations(
            limit=page_size, offset=offset
        )

        # Get total count
        total = self._organization_repository.count_active_organizations()

        # Convert to DTOs
        org_dtos = []
        for org in organizations:
            user_count = self._role_repository.count_organization_users(org.id)
            org_dto = OrganizationResponseDTO(
                **org.model_dump(),
                current_user_count=user_count,
                max_users=org.settings.max_users,
                settings=org.settings.model_dump(),
            )
            org_dtos.append(org_dto)

        total_pages = math.ceil(total / page_size)

        return OrganizationListResponseDTO(
            organizations=org_dtos,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_user_organizations(self, user_id: UUID) -> list[OrganizationResponseDTO]:
        """Get all organizations where user is a member."""
        organizations = self._organization_repository.get_user_organizations(user_id)

        org_dtos = []
        for org in organizations:
            user_count = self._role_repository.count_organization_users(org.id)
            org_dto = OrganizationResponseDTO(
                **org.model_dump(),
                current_user_count=user_count,
                max_users=org.settings.max_users,
                settings=org.settings.model_dump(),
            )
            org_dtos.append(org_dto)

        return org_dtos
from .organization_use_cases import OrganizationUseCase
from .membership_use_cases import MembershipUseCase

__all__ = ["OrganizationUseCase", "MembershipUseCase"]
from shared.infrastructure.repositories.sqlalchemy_unit_of_work import (
    SQLAlchemyUnitOfWork,
)
from sqlalchemy.orm import Session
from organization.infrastructure.repositories.sqlalchemy_organization_repository import (
    SqlAlchemyOrganizationRepository,
)
from organization.infrastructure.repositories.sqlalchemy_user_organization_role_repository import (
    SqlAlchemyUserOrganizationRoleRepository,
)


class OrganizationUnitOfWork(SQLAlchemyUnitOfWork):
    _repositories = {}

    def __init__(self, session: Session, repositories: list[str]):
        if "organization" in repositories:
            self._repositories.update({"organization": SqlAlchemyOrganizationRepository(session)})
        if "user_organization_role" in repositories:
            self._repositories.update(
                {"user_organization_role": SqlAlchemyUserOrganizationRoleRepository(session)}
            )

        super().__init__(session)
from shared.infrastructure.database.models.base import BaseModel as SQLBaseModel
from sqlalchemy import (
    Column,
    String,
    Boolean,
    ForeignKey,
    DateTime,
    Text,
    Enum,
    Integer,
)
from sqlalchemy.dialects.postgresql import UUID, JSON
import enum


class OrganizationRoleEnum(str, enum.Enum):
    OWNER = "owner"
    ADMIN = "admin"
    MEMBER = "member"
    VIEWER = "viewer"


class OrganizationModel(SQLBaseModel):
    """SQLAlchemy model for Organization entity."""

    __tablename__ = "organizations"

    name = Column(String(255), nullable=False, index=True)
    description = Column(Text, nullable=True)
    owner_id = Column(
        UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True
    )
    is_active = Column(Boolean, default=True, nullable=False)
    settings = Column(JSON, nullable=False, default={})  # Organization settings as JSON
    member_count = Column(Integer, default=1, nullable=False)
    max_members = Column(Integer, nullable=True)


class UserOrganizationRoleModel(SQLBaseModel):
    """SQLAlchemy model for UserOrganizationRole entity."""

    __tablename__ = "user_organization_roles"

    user_id = Column(
        UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True
    )
    organization_id = Column(
        UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True
    )
    role = Column(Enum(OrganizationRoleEnum), nullable=False, index=True)
    assigned_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)

    # Ensure unique active membership per user per organization
    __table_args__ = ({"postgresql_where": "is_active = true"},)
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete, and_
from sqlalchemy.exc import IntegrityError

from ...domain.entities.user_organization_role import UserOrganizationRole
from ...domain.repositories.user_organization_role_repository import (
    UserOrganizationRoleRepository,
)
from ..database.models import (
    UserOrganizationRoleModel,
    OrganizationRoleEnum,
)


class SqlAlchemyUserOrganizationRoleRepository(UserOrganizationRoleRepository):
    """SQLAlchemy implementation of UserOrganizationRoleRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, membership: UserOrganizationRole) -> UserOrganizationRole:
        """Save a user organization role entity."""
        try:
            # Check if membership exists
            existing = self.session.get(UserOrganizationRoleModel, membership.id)

            if existing:
                # Update existing membership
                existing.user_id = membership.user_id
                existing.organization_id = membership.organization_id
                existing.role = OrganizationRoleEnum(membership.role)
                existing.assigned_by = membership.assigned_by
                existing.expires_at = membership.expires_at
                existing.is_active = membership.is_active
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new membership
                membership_model = UserOrganizationRoleModel(
                    id=membership.id,
                    user_id=membership.user_id,
                    organization_id=membership.organization_id,
                    role=OrganizationRoleEnum(membership.role),
                    assigned_by=membership.assigned_by,
                    expires_at=membership.expires_at,
                    is_active=membership.is_active,
                    created_at=membership.created_at,
                    updated_at=membership.updated_at,
                )

                self.session.add(membership_model)
                self.session.flush()
                return self._to_domain_entity(membership_model)

        except IntegrityError as e:
            self.session.rollback()
            raise e

    def find_by_id(self, membership_id: UUID) -> Optional[UserOrganizationRole]:
        """Find a membership by ID."""
        result = self.session.execute(
            select(UserOrganizationRoleModel).where(
                UserOrganizationRoleModel.id == membership_id
            )
        )
        membership_model = result.scalar_one_or_none()

        if membership_model:
            return self._to_domain_entity(membership_model)
        return None

    def find_by_user_and_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> Optional[UserOrganizationRole]:
        """Find active membership for user in organization."""
        result = self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.user_id == user_id,
                    UserOrganizationRoleModel.organization_id == organization_id,
                    UserOrganizationRoleModel.is_active,
                )
            )
        )
        membership_model = result.scalar_one_or_none()

        if membership_model:
            return self._to_domain_entity(membership_model)
        return None

    def find_user_memberships(self, user_id: UUID) -> List[UserOrganizationRole]:
        """Find all active memberships for a user."""
        result = self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.user_id == user_id,
                    UserOrganizationRoleModel.is_active,
                )
            )
        )
        membership_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in membership_models]

    def find_organization_members(
        self, organization_id: UUID
    ) -> List[UserOrganizationRole]:
        """Find all active members of an organization."""
        result = self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.organization_id == organization_id,
                    UserOrganizationRoleModel.is_active,
                )
            )
        )
        membership_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in membership_models]

    def find_organization_members_by_role(
        self, organization_id: UUID, role: str
    ) -> List[UserOrganizationRole]:
        """Find organization members with specific role."""
        result = self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.organization_id == organization_id,
                    UserOrganizationRoleModel.role == OrganizationRoleEnum(role),
                    UserOrganizationRoleModel.is_active,
                )
            )
        )
        membership_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in membership_models]

    def find_expired_memberships(self) -> List[UserOrganizationRole]:
        """Find expired memberships that are still active."""
        current_time = datetime.now(timezone.utc)
        result = self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.expires_at <= current_time,
                    UserOrganizationRoleModel.is_active,
                )
            )
        )
        membership_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in membership_models]

    def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        user_id: Optional[UUID] = None,
        role: Optional[str] = None,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[UserOrganizationRole], int]:
        """Find memberships with pagination and filters."""
        query = select(UserOrganizationRoleModel)
        count_query = select(UserOrganizationRoleModel)

        # Apply filters
        if organization_id:
            query = query.where(
                UserOrganizationRoleModel.organization_id == organization_id
            )
            count_query = count_query.where(
                UserOrganizationRoleModel.organization_id == organization_id
            )

        if user_id:
            query = query.where(UserOrganizationRoleModel.user_id == user_id)
            count_query = count_query.where(
                UserOrganizationRoleModel.user_id == user_id
            )

        if role:
            query = query.where(
                UserOrganizationRoleModel.role == OrganizationRoleEnum(role)
            )
            count_query = count_query.where(
                UserOrganizationRoleModel.role == OrganizationRoleEnum(role)
            )

        if is_active is not None:
            query = query.where(UserOrganizationRoleModel.is_active == is_active)
            count_query = count_query.where(
                UserOrganizationRoleModel.is_active == is_active
            )

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(UserOrganizationRoleModel.created_at.desc())
        )
        result = self.session.execute(query)
        membership_models = result.scalars().all()

        memberships = [self._to_domain_entity(model) for model in membership_models]
        return memberships, total

    def delete(self, membership_id: UUID) -> bool:
        """Delete a membership (hard delete)."""
        result = self.session.execute(
            delete(UserOrganizationRoleModel).where(
                UserOrganizationRoleModel.id == membership_id
            )
        )
        return result.rowcount > 0

    def deactivate_membership(self, membership_id: UUID) -> bool:
        """Deactivate a membership (soft delete)."""
        result = self.session.execute(
            update(UserOrganizationRoleModel)
            .where(UserOrganizationRoleModel.id == membership_id)
            .values(is_active=False, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def update_role(self, membership_id: UUID, new_role: str) -> bool:
        """Update membership role."""
        result = self.session.execute(
            update(UserOrganizationRoleModel)
            .where(UserOrganizationRoleModel.id == membership_id)
            .values(
                role=OrganizationRoleEnum(new_role),
                updated_at=datetime.now(timezone.utc),
            )
        )
        return result.rowcount > 0

    def extend_membership(self, membership_id: UUID, new_expiration: datetime) -> bool:
        """Extend membership expiration."""
        result = self.session.execute(
            update(UserOrganizationRoleModel)
            .where(UserOrganizationRoleModel.id == membership_id)
            .values(expires_at=new_expiration, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def count_organization_members(self, organization_id: UUID) -> int:
        """Count active members in an organization."""
        result = self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.organization_id == organization_id,
                    UserOrganizationRoleModel.is_active,
                )
            )
        )
        return len(result.scalars().all())

    def count_user_memberships(self, user_id: UUID) -> int:
        """Count active memberships for a user."""
        result = self.session.execute(
            select(UserOrganizationRoleModel).where(
                and_(
                    UserOrganizationRoleModel.user_id == user_id,
                    UserOrganizationRoleModel.is_active,
                )
            )
        )
        return len(result.scalars().all())

    def expire_memberships(self) -> int:
        """Mark expired memberships as inactive."""
        current_time = datetime.now(timezone.utc)
        result = self.session.execute(
            update(UserOrganizationRoleModel)
            .where(
                and_(
                    UserOrganizationRoleModel.expires_at <= current_time,
                    UserOrganizationRoleModel.is_active,
                )
            )
            .values(is_active=False, updated_at=current_time)
        )
        return result.rowcount

    def _to_domain_entity(
        self, membership_model: UserOrganizationRoleModel
    ) -> UserOrganizationRole:
        """Convert SQLAlchemy model to domain entity."""
        return UserOrganizationRole(
            id=membership_model.id,
            user_id=membership_model.user_id,
            organization_id=membership_model.organization_id,
            role=membership_model.role.value,
            assigned_by=membership_model.assigned_by,
            expires_at=membership_model.expires_at,
            is_active=membership_model.is_active,
            created_at=membership_model.created_at,
            updated_at=membership_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete

from ...domain.entities.organization import Organization
from ...domain.repositories.organization_repository import OrganizationRepository
from ...domain.value_objects.organization_name import OrganizationName
from ...domain.value_objects.organization_settings import OrganizationSettings
from ..database.models import OrganizationModel


class SqlAlchemyOrganizationRepository(OrganizationRepository):
    """SQLAlchemy implementation of OrganizationRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, organization: Organization) -> Organization:
        """Save an organization entity."""
        # Check if organization exists
        existing = self.session.get(OrganizationModel, organization.id)

        if existing:
            # Update existing organization
            existing.name = organization.name.value
            existing.description = organization.description
            existing.owner_id = organization.owner_id
            existing.is_active = organization.is_active
            existing.settings = organization.settings.to_dict()
            existing.member_count = organization.member_count
            existing.max_members = organization.max_members
            existing.updated_at = datetime.now(timezone.utc)

            self.session.flush()
            return self._to_domain_entity(existing)
        else:
            # Create new organization
            org_model = OrganizationModel(
                id=organization.id,
                name=organization.name.value,
                description=organization.description,
                owner_id=organization.owner_id,
                is_active=organization.is_active,
                settings=organization.settings.to_dict(),
                member_count=organization.member_count,
                max_members=organization.max_members,
                created_at=organization.created_at,
                updated_at=organization.updated_at,
            )

            self.session.add(org_model)
            self.session.flush()
            return self._to_domain_entity(org_model)

    def find_by_id(self, organization_id: UUID) -> Optional[Organization]:
        """Find an organization by ID."""
        result = self.session.execute(
            select(OrganizationModel).where(OrganizationModel.id == organization_id)
        )
        org_model = result.scalar_one_or_none()

        if org_model:
            return self._to_domain_entity(org_model)
        return None

    def find_by_name(self, name: OrganizationName) -> Optional[Organization]:
        """Find an organization by name."""
        result = self.session.execute(
            select(OrganizationModel).where(OrganizationModel.name == name.value)
        )
        org_model = result.scalar_one_or_none()

        if org_model:
            return self._to_domain_entity(org_model)
        return None

    def find_by_owner(self, owner_id: UUID) -> List[Organization]:
        """Find organizations owned by a user."""
        result = self.session.execute(
            select(OrganizationModel).where(OrganizationModel.owner_id == owner_id)
        )
        org_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in org_models]

    def find_active_organizations(self) -> List[Organization]:
        """Find all active organizations."""
        result = self.session.execute(
            select(OrganizationModel).where(OrganizationModel.is_active)
        )
        org_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in org_models]

    def find_paginated(
        self,
        offset: int = 0,
        limit: int = 20,
        name_filter: Optional[str] = None,
        owner_id: Optional[UUID] = None,
        is_active: Optional[bool] = None,
    ) -> tuple[List[Organization], int]:
        """Find organizations with pagination and filters."""
        query = select(OrganizationModel)
        count_query = select(OrganizationModel)

        # Apply filters
        if name_filter:
            query = query.where(OrganizationModel.name.ilike(f"%{name_filter}%"))
            count_query = count_query.where(
                OrganizationModel.name.ilike(f"%{name_filter}%")
            )

        if owner_id:
            query = query.where(OrganizationModel.owner_id == owner_id)
            count_query = count_query.where(OrganizationModel.owner_id == owner_id)

        if is_active is not None:
            query = query.where(OrganizationModel.is_active == is_active)
            count_query = count_query.where(OrganizationModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(OrganizationModel.created_at.desc())
        )
        result = self.session.execute(query)
        org_models = result.scalars().all()

        organizations = [self._to_domain_entity(model) for model in org_models]
        return organizations, total

    def delete(self, organization_id: UUID) -> bool:
        """Delete an organization (hard delete)."""
        result = self.session.execute(
            delete(OrganizationModel).where(OrganizationModel.id == organization_id)
        )
        return result.rowcount > 0

    def exists_by_name(self, name: OrganizationName) -> bool:
        """Check if an organization with the given name exists."""
        result = self.session.execute(
            select(OrganizationModel.id).where(OrganizationModel.name == name.value)
        )
        return result.scalar_one_or_none() is not None

    def update_member_count(self, organization_id: UUID, member_count: int) -> bool:
        """Update organization's member count."""
        result = self.session.execute(
            update(OrganizationModel)
            .where(OrganizationModel.id == organization_id)
            .values(member_count=member_count, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def transfer_ownership(self, organization_id: UUID, new_owner_id: UUID) -> bool:
        """Transfer organization ownership."""
        result = self.session.execute(
            update(OrganizationModel)
            .where(OrganizationModel.id == organization_id)
            .values(owner_id=new_owner_id, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def update_settings(
        self, organization_id: UUID, settings: OrganizationSettings
    ) -> bool:
        """Update organization settings."""
        result = self.session.execute(
            update(OrganizationModel)
            .where(OrganizationModel.id == organization_id)
            .values(settings=settings.to_dict(), updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def count_organizations_by_owner(self, owner_id: UUID) -> int:
        """Count organizations owned by a user."""
        result = self.session.execute(
            select(OrganizationModel).where(OrganizationModel.owner_id == owner_id)
        )
        return len(result.scalars().all())

    def _to_domain_entity(self, org_model: OrganizationModel) -> Organization:
        """Convert SQLAlchemy model to domain entity."""
        return Organization(
            id=org_model.id,
            name=OrganizationName(org_model.name),
            description=org_model.description,
            owner_id=org_model.owner_id,
            is_active=org_model.is_active,
            settings=OrganizationSettings.from_dict(org_model.settings),
            member_count=org_model.member_count,
            max_members=org_model.max_members,
            created_at=org_model.created_at,
            updated_at=org_model.updated_at,
        )
from .sqlalchemy_organization_repository import SqlAlchemyOrganizationRepository
from .sqlalchemy_user_organization_role_repository import SqlAlchemyUserOrganizationRoleRepository

__all__ = [
    "SqlAlchemyOrganizationRepository",
    "SqlAlchemyUserOrganizationRoleRepository"
]
from .repositories import SqlAlchemyOrganizationRepository, SqlAlchemyUserOrganizationRoleRepository

__all__ = [
    "SqlAlchemyOrganizationRepository",
    "SqlAlchemyUserOrganizationRoleRepository"
]
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List
from pydantic import BaseModel


class UserOrganizationRole(BaseModel):
    id: UUID
    user_id: UUID
    organization_id: UUID
    role_id: UUID
    assigned_at: datetime
    assigned_by: UUID
    revoked_at: Optional[datetime] = None
    revoked_by: Optional[UUID] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(cls, user_id: UUID, organization_id: UUID, role_id: UUID, assigned_by: UUID) -> "UserOrganizationRole":
        return cls(
            id=uuid4(),
            user_id=user_id,
            organization_id=organization_id,
            role_id=role_id,
            assigned_by=assigned_by,
            assigned_at=datetime.utcnow(),
            is_active=True
        )

    def revoke(self, revoked_by: UUID) -> "UserOrganizationRole":
        return self.model_copy(update={
            "revoked_at": datetime.utcnow(),
            "revoked_by": revoked_by,
            "is_active": False
        })

    def reactivate(self) -> "UserOrganizationRole":
        return self.model_copy(update={
            "revoked_at": None,
            "revoked_by": None,
            "is_active": True
        })
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel, Field

from domain.value_objects.email import Email
from domain.value_objects.password import Password


class User(BaseModel):
    id: UUID
    email: Email
    name: str
    password: Password
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"arbitrary_types_allowed": True}

    @classmethod
    def create(cls, email: str, name: str, password: str) -> "User":
        return cls(
            id=uuid4(),
            email=Email(value=email),
            name=name,
            password=Password.create(password),
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "User":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "User":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "User":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
    
    def change_password(self, new_password: str) -> "User":
        return self.model_copy(update={
            "password": Password.create(new_password),
            "updated_at": datetime.utcnow()
        })
    
    def verify_password(self, plain_password: str) -> bool:
        return self.password.verify(plain_password)
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel


class Organization(BaseModel):
    id: UUID
    name: str
    description: Optional[str] = None
    owner_id: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(cls, name: str, owner_id: UUID, description: Optional[str] = None) -> "Organization":
        return cls(
            id=uuid4(),
            name=name,
            description=description,
            owner_id=owner_id,
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "Organization":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def update_description(self, description: str) -> "Organization":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def transfer_ownership(self, new_owner_id: UUID) -> "Organization":
        return self.model_copy(update={
            "owner_id": new_owner_id,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Organization":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Organization":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class PermissionEffect(str, Enum):
    ALLOW = "allow"
    DENY = "deny"


class ContextCondition(BaseModel):
    """Defines conditions that must be met for the permission to apply"""
    attribute: str  # e.g., "user.department", "resource.project_code", "context.time"
    operator: str  # e.g., "equals", "in", "contains", "greater_than"
    value: Any  # e.g., "engineering", ["proj_a", "proj_b"], "2024-01-01"

    model_config = {"frozen": True}


class ResourcePermission(BaseModel):
    """Specific permission for a user/role on a resource with contextual conditions"""
    id: UUID
    user_id: Optional[UUID] = None  # Direct user permission
    role_id: Optional[UUID] = None  # Role-based permission
    resource_id: UUID
    permission_id: UUID  # Links to base Permission (read, write, delete, etc.)
    effect: PermissionEffect = PermissionEffect.ALLOW
    conditions: list[ContextCondition] = []  # ABAC conditions
    priority: int = 0  # Higher priority rules override lower ones
    assigned_at: datetime
    assigned_by: UUID
    revoked_at: Optional[datetime] = None
    revoked_by: Optional[UUID] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create_user_permission(
        cls,
        user_id: UUID,
        resource_id: UUID,
        permission_id: UUID,
        assigned_by: UUID,
        effect: PermissionEffect = PermissionEffect.ALLOW,
        conditions: Optional[list[ContextCondition]] = None,
        priority: int = 0,
    ) -> "ResourcePermission":
        return cls(
            id=uuid4(),
            user_id=user_id,
            resource_id=resource_id,
            permission_id=permission_id,
            effect=effect,
            conditions=conditions or [],
            priority=priority,
            assigned_at=datetime.utcnow(),
            assigned_by=assigned_by,
            is_active=True,
        )

    @classmethod
    def create_role_permission(
        cls,
        role_id: UUID,
        resource_id: UUID,
        permission_id: UUID,
        assigned_by: UUID,
        effect: PermissionEffect = PermissionEffect.ALLOW,
        conditions: Optional[list[ContextCondition]] = None,
        priority: int = 0,
    ) -> "ResourcePermission":
        return cls(
            id=uuid4(),
            role_id=role_id,
            resource_id=resource_id,
            permission_id=permission_id,
            effect=effect,
            conditions=conditions or [],
            priority=priority,
            assigned_at=datetime.utcnow(),
            assigned_by=assigned_by,
            is_active=True,
        )

    def revoke(self, revoked_by: UUID) -> "ResourcePermission":
        return self.model_copy(update={
            "revoked_at": datetime.utcnow(),
            "revoked_by": revoked_by,
            "is_active": False,
        })

    def update_conditions(self, conditions: list[ContextCondition]) -> "ResourcePermission":
        return self.model_copy(update={"conditions": conditions})

    def update_priority(self, priority: int) -> "ResourcePermission":
        return self.model_copy(update={"priority": priority})
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List
from pydantic import BaseModel


class Role(BaseModel):
    id: UUID
    name: str
    description: Optional[str] = None
    is_system: bool = False
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(cls, name: str, description: Optional[str] = None, is_system: bool = False) -> "Role":
        return cls(
            id=uuid4(),
            name=name,
            description=description,
            is_system=is_system,
            created_at=datetime.utcnow(),
            is_active=True
        )

    def update_name(self, name: str) -> "Role":
        return self.model_copy(update={
            "name": name,
            "updated_at": datetime.utcnow()
        })

    def update_description(self, description: str) -> "Role":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Role":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Role":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class ResourceType(str, Enum):
    PROJECT = "project"
    DOCUMENT = "document"
    DATASET = "dataset"
    REPORT = "report"
    DASHBOARD = "dashboard"
    FOLDER = "folder"
    CUSTOM = "custom"


class Resource(BaseModel):
    id: UUID
    name: str
    resource_type: ResourceType
    description: Optional[str] = None
    parent_id: Optional[UUID] = None  # For hierarchical resources
    organization_id: Optional[UUID] = None  # Multi-tenant support
    metadata: Dict[str, Any] = {}  # Flexible attributes (project_code, department, etc.)
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        name: str,
        resource_type: ResourceType,
        description: Optional[str] = None,
        parent_id: Optional[UUID] = None,
        organization_id: Optional[UUID] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> "Resource":
        return cls(
            id=uuid4(),
            name=name,
            resource_type=resource_type,
            description=description,
            parent_id=parent_id,
            organization_id=organization_id,
            metadata=metadata or {},
            created_at=datetime.utcnow(),
            is_active=True,
        )

    def update_metadata(self, metadata: Dict[str, Any]) -> "Resource":
        return self.model_copy(update={
            "metadata": {**self.metadata, **metadata},
            "updated_at": datetime.utcnow()
        })

    def set_parent(self, parent_id: UUID) -> "Resource":
        return self.model_copy(update={
            "parent_id": parent_id,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Resource":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Resource":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })
from datetime import datetime
from uuid import UUID
from typing import Optional, Dict, Any
from pydantic import BaseModel


class AuthorizationContext(BaseModel):
    """Context information used for ABAC authorization decisions"""

    user_id: UUID
    resource_id: Optional[UUID] = None
    organization_id: Optional[UUID] = None
    user_attributes: Dict[str, Any] = {}  # department, team, level, etc.
    resource_attributes: Dict[
        str, Any
    ] = {}  # project_code, classification, owner, etc.
    environment_attributes: Dict[str, Any] = {}  # time, ip_address, location, etc.
    request_attributes: Dict[str, Any] = {}  # action, client_type, etc.

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        resource_id: Optional[UUID] = None,
        organization_id: Optional[UUID] = None,
        user_attributes: Optional[Dict[str, Any]] = None,
        resource_attributes: Optional[Dict[str, Any]] = None,
        environment_attributes: Optional[Dict[str, Any]] = None,
        request_attributes: Optional[Dict[str, Any]] = None,
    ) -> "AuthorizationContext":
        # Add default environment attributes
        env_attrs = environment_attributes or {}
        env_attrs.setdefault("timestamp", datetime.utcnow().isoformat())

        return cls(
            user_id=user_id,
            resource_id=resource_id,
            organization_id=organization_id,
            user_attributes=user_attributes or {},
            resource_attributes=resource_attributes or {},
            environment_attributes=env_attrs,
            request_attributes=request_attributes or {},
        )

    def get_attribute(self, attribute_path: str) -> Any:
        """Get attribute value using dot notation (e.g., 'user.department', 'resource.project_code')"""
        parts = attribute_path.split(".")
        if len(parts) != 2:
            return None

        category, key = parts
        if category == "user":
            return self.user_attributes.get(key)
        elif category == "resource":
            return self.resource_attributes.get(key)
        elif category == "environment":
            return self.environment_attributes.get(key)
        elif category == "request":
            return self.request_attributes.get(key)
        else:
            return None

    def with_user_attributes(self, **attributes) -> "AuthorizationContext":
        return self.model_copy(
            update={"user_attributes": {**self.user_attributes, **attributes}}
        )

    def with_resource_attributes(self, **attributes) -> "AuthorizationContext":
        return self.model_copy(
            update={"resource_attributes": {**self.resource_attributes, **attributes}}
        )

    def with_environment_attributes(self, **attributes) -> "AuthorizationContext":
        return self.model_copy(
            update={
                "environment_attributes": {**self.environment_attributes, **attributes}
            }
        )

    def with_request_attributes(self, **attributes) -> "AuthorizationContext":
        return self.model_copy(
            update={"request_attributes": {**self.request_attributes, **attributes}}
        )
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel
from enum import Enum


class SessionStatus(str, Enum):
    ACTIVE = "active"
    EXPIRED = "expired"
    LOGGED_OUT = "logged_out"
    REVOKED = "revoked"


class UserSession(BaseModel):
    id: UUID
    user_id: UUID
    session_token: str
    status: SessionStatus
    login_at: datetime
    logout_at: Optional[datetime] = None
    expires_at: datetime
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        session_token: str,
        expires_at: datetime,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> "UserSession":
        now = datetime.utcnow()
        return cls(
            id=uuid4(),
            user_id=user_id,
            session_token=session_token,
            status=SessionStatus.ACTIVE,
            login_at=now,
            expires_at=expires_at,
            ip_address=ip_address,
            user_agent=user_agent,
            created_at=now
        )

    def logout(self) -> "UserSession":
        """Mark session as logged out."""
        return self.model_copy(update={
            "status": SessionStatus.LOGGED_OUT,
            "logout_at": datetime.utcnow(),
            "updated_at": datetime.utcnow()
        })

    def expire(self) -> "UserSession":
        """Mark session as expired."""
        return self.model_copy(update={
            "status": SessionStatus.EXPIRED,
            "updated_at": datetime.utcnow()
        })

    def revoke(self) -> "UserSession":
        """Mark session as revoked (admin action)."""
        return self.model_copy(update={
            "status": SessionStatus.REVOKED,
            "logout_at": datetime.utcnow(),
            "updated_at": datetime.utcnow()
        })

    def is_active(self) -> bool:
        """Check if session is currently active."""
        if self.status != SessionStatus.ACTIVE:
            return False
        
        return datetime.utcnow() < self.expires_at

    def is_expired(self) -> bool:
        """Check if session has expired."""
        return datetime.utcnow() >= self.expires_at

    def get_session_duration(self) -> Optional[int]:
        """Get session duration in seconds. Returns None if still active."""
        if not self.logout_at:
            return None
        
        duration = self.logout_at - self.login_at
        return int(duration.total_seconds())

    def extend_session(self, new_expires_at: datetime) -> "UserSession":
        """Extend session expiration time."""
        if self.status != SessionStatus.ACTIVE:
            raise ValueError("Cannot extend inactive session")
        
        return self.model_copy(update={
            "expires_at": new_expires_at,
            "updated_at": datetime.utcnow()
        })
import re
from pydantic import BaseModel, field_validator
from typing import Any


class Email(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if not cls._is_valid_email(v):
            raise ValueError(f"Invalid email format: {v}")
        return v

    @staticmethod
    def _is_valid_email(email: str) -> bool:
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, Email):
            return self.value == other.value
        return False
from pydantic import BaseModel
from typing import Any
import bcrypt


class Password(BaseModel, frozen=True):
    """Password value object with bcrypt encryption."""
    
    hashed_value: str
    
    @classmethod
    def create(cls, plain_password: str) -> "Password":
        """Create a new password by hashing the plain text."""
        if not plain_password or len(plain_password.strip()) == 0:
            raise ValueError("Password cannot be empty")
        
        if len(plain_password) < 8:
            raise ValueError("Password must be at least 8 characters long")
        
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(plain_password.encode('utf-8'), salt)
        return cls(hashed_value=hashed.decode('utf-8'))
    
    @classmethod
    def from_hash(cls, hashed_password: str) -> "Password":
        """Create password object from existing hash."""
        return cls(hashed_value=hashed_password)
    
    def verify(self, plain_password: str) -> bool:
        """Verify a plain password against this hashed password."""
        return bcrypt.checkpw(
            plain_password.encode('utf-8'), 
            self.hashed_value.encode('utf-8')
        )
    
    def __str__(self) -> str:
        return "[PROTECTED]"
    
    def __repr__(self) -> str:
        return "Password([PROTECTED])"
    
    def __hash__(self) -> int:
        return hash(self.hashed_value)
    
    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Password):
            return False
        return self.hashed_value == other.hashed_value
from abc import ABC, abstractmethod
from typing import Generic, TypeVar, List, Optional
from uuid import UUID

T = TypeVar("T")


class Repository(ABC, Generic[T]):
    @abstractmethod
    def create(self, entity: T) -> T:
        pass

    @abstractmethod
    def get_by_id(self, entity_id: UUID) -> Optional[T]:
        pass

    @abstractmethod
    def get_all(self) -> List[T]:
        pass

    @abstractmethod
    def update(self, entity: T) -> T:
        pass

    @abstractmethod
    def delete(self, entity_id: UUID) -> bool:
        pass
from abc import ABC, abstractmethod
from typing import Any


class UnitOfWork(ABC):
    _repositories: dict[str, Any] = {}

    @abstractmethod
    def __enter__(self) -> "UnitOfWork":
        pass

    @abstractmethod
    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        pass

    @abstractmethod
    def commit(self) -> None:
        pass

    @abstractmethod
    def rollback(self) -> None:
        pass

    @abstractmethod
    def get_repository(self, name: str) -> Any:
        pass
import os
from sqlalchemy import create_engine, MetaData
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv(
    "DATABASE_URL", "postgresql://postgres:password@localhost:5432/ddd_app"
)

SCHEMA_NAME = "contas"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create Base with schema support
Base = declarative_base(metadata=MetaData(schema=SCHEMA_NAME))


def get_db():
    """Legacy dependency - use get_unit_of_work instead for new code."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
from sqlalchemy import Column, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from sqlalchemy.ext.declarative import declarative_base
import uuid

from shared.infrastructure.database.connection import Base


class BaseModel(Base):
    """Base model with common fields for all entities."""

    __abstract__ = True

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    created_at = Column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)
from abc import abstractmethod
from typing import Generic, TypeVar, List, Optional, Type
from uuid import UUID
from sqlalchemy.orm import Session

from shared.domain.repositories.base_repository import Repository

DomainEntity = TypeVar("DomainEntity")
DatabaseModel = TypeVar("DatabaseModel")


class SQLAlchemyRepository(
    Repository[DomainEntity], Generic[DomainEntity, DatabaseModel]
):
    def __init__(self, db: Session, model_class: Type[DatabaseModel]):
        self.db = db
        self.model_class = model_class

    @abstractmethod
    def _to_domain(self, model: DatabaseModel) -> DomainEntity:
        pass

    @abstractmethod
    def _to_model(self, entity: DomainEntity) -> DatabaseModel:
        pass

    @abstractmethod
    def _update_model(
        self, model: DatabaseModel, entity: DomainEntity
    ) -> DatabaseModel:
        pass

    def create(self, entity: DomainEntity) -> DomainEntity:
        model = self._to_model(entity)
        self.db.add(model)
        self.db.flush()  # Flush to get the ID but don't commit
        self.db.refresh(model)
        return self._to_domain(model)

    def get_by_id(self, entity_id: UUID) -> Optional[DomainEntity]:
        model = (
            self.db.query(self.model_class)
            .filter(self.model_class.id == entity_id)
            .first()
        )
        return self._to_domain(model) if model else None

    def get_all(self) -> List[DomainEntity]:
        models = self.db.query(self.model_class).all()
        return [self._to_domain(model) for model in models]

    def update(self, entity: DomainEntity) -> DomainEntity:
        model = (
            self.db.query(self.model_class)
            .filter(self.model_class.id == entity.id)
            .first()
        )
        if model:
            updated_model = self._update_model(model, entity)
            self.db.flush()  # Flush changes but don't commit
            self.db.refresh(updated_model)
            return self._to_domain(updated_model)
        raise ValueError(f"Entity with id {entity.id} not found")

    def delete(self, entity_id: UUID) -> bool:
        model = (
            self.db.query(self.model_class)
            .filter(self.model_class.id == entity_id)
            .first()
        )
        if model:
            self.db.delete(model)
            self.db.flush()  # Flush changes but don't commit
            return True
        return False
from shared.domain.repositories.unit_of_work import UnitOfWork
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError


class SQLAlchemyUnitOfWork(UnitOfWork):
    def __init__(self, session: Session):
        self.session = session
        self._committed = False

    def __enter__(self) -> "SQLAlchemyUnitOfWork":
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        if exc_type is None:
            self.commit()
        else:
            self.rollback()
        self.session.close()

    def commit(self) -> None:
        if not self._committed:
            try:
                self.session.commit()
                self._committed = True
            except SQLAlchemyError:
                self.rollback()
                raise

    def rollback(self) -> None:
        self.session.rollback()
        self._committed = False
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
import logging
import time

from shared.infrastructure.database.connection import engine, Base
from user.presentation.routers import user_api_router
# from presentation.api.auth_routes import router as auth_router

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def create_tables():
    Base.metadata.create_all(bind=engine)


def create_app() -> FastAPI:
    app = FastAPI(
        title="DDD FastAPI Application",
        description="A FastAPI application following Domain Driven Design principles",
        version="1.0.0",
        redirect_slashes=False,  # Desabilita redirecionamento automtico de trailing slash
    )

    @app.middleware("http")
    def log_requests(request: Request, call_next):
        start_time = time.time()

        # Logar requisies suspeitas para endpoints de IA
        ai_endpoints = ["/v1/models", "/v1/chat", "/v1/completions", "/models", "/chat"]
        if any(request.url.path.startswith(endpoint) for endpoint in ai_endpoints):
            logger.warning(
                f"AI API request detected: {request.method} {request.url.path} "
                f"from {request.client.host if request.client else 'unknown'} "
                f"User-Agent: {request.headers.get('user-agent', 'unknown')}"
            )

        response = call_next(request)
        process_time = time.time() - start_time

        # Logar requisies problemticas e redirecionamentos
        if (
            response.status_code >= 400
            or request.url.path.startswith("/v1/")
            or response.status_code == 307
        ):
            status_msg = ""
            if response.status_code == 307:
                status_msg = " (REDIRECT - check trailing slash)"

            logger.info(
                f"{request.method} {request.url.path} - "
                f"Status: {response.status_code}{status_msg} - "
                f"Time: {process_time:.4f}s - "
                f"Client: {request.client.host if request.client else 'unknown'}"
            )

        return response

    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    app.include_router(user_api_router, prefix="/api/v1")
    # app.include_router(auth_router, prefix="/api/v1")

    return app


app = create_app()


@app.on_event("startup")
def startup_event():
    create_tables()


@app.get("/")
def root():
    return {"message": "Welcome to DDD FastAPI Application"}


@app.get("/health")
def health_check():
    return {"status": "healthy"}


@app.get("/v1/models")
def models_endpoint():
    """
    Endpoint para esclarecer que esta no  uma API de modelos de IA.
    Algumas ferramentas podem tentar acessar este endpoint pensando que  uma API OpenAI-like.
    """
    return {
        "error": "Not an AI models API",
        "message": "This is a FastAPI DDD application, not an AI models server",
        "application": "FastAPI DDD Project",
        "available_endpoints": [
            "/docs - API Documentation",
            "/api/v1/users - User management endpoints",
            "/api/v1/auth - Authentication endpoints",
            "/health - Health check",
        ],
        "note": "If you're looking for AI models, try OpenAI API, Ollama, or similar services",
    }


@app.post("/v1/chat/completions")
@app.post("/v1/completions")
@app.get("/models")
def ai_endpoints_handler():
    """
    Handler para outros endpoints comuns de APIs de IA
    """
    return {
        "error": "AI API not available",
        "message": "This is not an AI service. This is a FastAPI DDD application for user management.",
        "redirect": "Check /docs for available endpoints",
        "suggestion": "For AI services, try OpenAI, Anthropic, Ollama, or other AI providers",
    }
from datetime import datetime, timezone
from uuid import UUID, uuid4
from typing import Optional, Dict, Any, List
from pydantic import BaseModel
from enum import Enum


class PolicyEffect(str, Enum):
    ALLOW = "allow"
    DENY = "deny"


class PolicyCondition(BaseModel):
    attribute: str
    operator: str  # eq, ne, gt, lt, gte, lte, in, not_in, contains
    value: Any

    model_config = {"frozen": True}

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Evaluate condition against context."""
        context_value = context.get(self.attribute)

        if context_value is None:
            return False

        if self.operator == "eq":
            return context_value == self.value
        elif self.operator == "ne":
            return context_value != self.value
        elif self.operator == "gt":
            return context_value > self.value
        elif self.operator == "lt":
            return context_value < self.value
        elif self.operator == "gte":
            return context_value >= self.value
        elif self.operator == "lte":
            return context_value <= self.value
        elif self.operator == "in":
            return context_value in self.value
        elif self.operator == "not_in":
            return context_value not in self.value
        elif self.operator == "contains":
            return self.value in context_value

        return False


class Policy(BaseModel):
    id: UUID
    name: str
    description: str
    effect: PolicyEffect
    resource_type: str
    action: str
    conditions: List[PolicyCondition]
    organization_id: Optional[UUID] = None
    created_by: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True
    priority: int = 0  # Higher number = higher priority

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls,
        name: str,
        description: str,
        effect: PolicyEffect,
        resource_type: str,
        action: str,
        conditions: List[PolicyCondition],
        created_by: UUID,
        organization_id: Optional[UUID] = None,
        priority: int = 0,
    ) -> "Policy":
        return cls(
            id=uuid4(),
            name=name,
            description=description,
            effect=effect,
            resource_type=resource_type,
            action=action,
            conditions=conditions,
            organization_id=organization_id,
            created_by=created_by,
            created_at=datetime.now(timezone.utc),
            is_active=True,
            priority=priority,
        )

    def evaluate(self, context: Dict[str, Any]) -> Optional[bool]:
        """Evaluate policy against context. Returns None if not applicable."""
        if not self.is_active:
            return None

        # Check if policy applies to this resource type and action
        if (
            context.get("resource_type") != self.resource_type
            or context.get("action") != self.action
        ):
            return None

        # Check organization scope
        if (
            self.organization_id
            and context.get("organization_id") != self.organization_id
        ):
            return None

        # Evaluate all conditions
        for condition in self.conditions:
            if not condition.evaluate(context):
                return None  # Policy doesn't apply

        # All conditions met, return effect
        return self.effect == PolicyEffect.ALLOW

    def update_conditions(self, conditions: List[PolicyCondition]) -> "Policy":
        """Update policy conditions."""
        return self.model_copy(
            update={"conditions": conditions, "updated_at": datetime.now(timezone.utc)}
        )

    def update_priority(self, priority: int) -> "Policy":
        """Update policy priority."""
        return self.model_copy(
            update={"priority": priority, "updated_at": datetime.now(timezone.utc)}
        )

    def deactivate(self) -> "Policy":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.now(timezone.utc)
        })

    def activate(self) -> "Policy":
        return self.model_copy(
            update={"is_active": True, "updated_at": datetime.now(timezone.utc)}
        )

    def matches_request(
        self, resource_type: str, action: str, organization_id: Optional[UUID] = None
    ) -> bool:
        """Check if policy matches the request."""
        if not self.is_active:
            return False

        if self.resource_type != resource_type or self.action != action:
            return False

        if self.organization_id and self.organization_id != organization_id:
            return False

        return True
from datetime import datetime, timezone

from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel
from enum import Enum

from ..value_objects.permission_name import PermissionName


class PermissionAction(str, Enum):
    CREATE = "create"
    READ = "read"
    UPDATE = "update"
    DELETE = "delete"
    EXECUTE = "execute"
    MANAGE = "manage"


class Permission(BaseModel):
    id: UUID
    name: PermissionName
    description: str
    action: PermissionAction
    resource_type: str  # e.g., "user", "organization", "chat"
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True
    is_system_permission: bool = False

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls, 
        name: str, 
        description: str, 
        action: PermissionAction,
        resource_type: str,
        is_system_permission: bool = False
    ) -> "Permission":
        return cls(
            id=uuid4(),
            name=PermissionName(value=name),
            description=description,
            action=action,
            resource_type=resource_type,
            created_at=datetime.now(timezone.utc),
            is_active=True,
            is_system_permission=is_system_permission
        )

    def update_description(self, description: str) -> "Permission":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "Permission":
        if self.is_system_permission:
            raise ValueError("Cannot deactivate system permissions")
        
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Permission":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.now(timezone.utc)
        })

    def get_full_name(self) -> str:
        """Get full permission name in format: resource_type:action"""
        return f"{self.resource_type}:{self.action.value}"

    def can_be_deleted(self) -> tuple[bool, str]:
        """Check if permission can be deleted."""
        if self.is_system_permission:
            return False, "System permissions cannot be deleted"
        
        return True, "Permission can be deleted"

    def matches_resource_and_action(self, resource_type: str, action: PermissionAction) -> bool:
        """Check if this permission matches the given resource and action."""
        return (
            self.resource_type == resource_type and 
            self.action == action and 
            self.is_active
        )
from datetime import datetime, timezone

from uuid import UUID, uuid4
from typing import Optional, List, Set
from pydantic import BaseModel

from ..value_objects.role_name import RoleName


class Role(BaseModel):
    id: UUID
    name: RoleName
    description: str
    organization_id: Optional[UUID] = None  # None for system-wide roles
    parent_role_id: Optional[UUID] = None  # For role inheritance
    created_by: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True
    is_system_role: bool = False

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls,
        name: str,
        description: str,
        created_by: UUID,
        organization_id: Optional[UUID] = None,
        parent_role_id: Optional[UUID] = None,
        is_system_role: bool = False,
    ) -> "Role":
        return cls(
            id=uuid4(),
            name=RoleName(value=name),
            description=description,
            organization_id=organization_id,
            parent_role_id=parent_role_id,
            created_by=created_by,
            created_at=datetime.now(timezone.utc),
            is_active=True,
            is_system_role=is_system_role,
        )

    def update_description(self, description: str) -> "Role":
        return self.model_copy(
            update={"description": description, "updated_at": datetime.utcnow()}
        )

    def deactivate(self) -> "Role":
        if self.is_system_role:
            raise ValueError("Cannot deactivate system roles")

        return self.model_copy(
            update={"is_active": False, "updated_at": datetime.utcnow()}
        )

    def activate(self) -> "Role":
        return self.model_copy(
            update={"is_active": True, "updated_at": datetime.utcnow()}
        )

    def is_organization_role(self) -> bool:
        """Check if this is an organization-specific role."""
        return self.organization_id is not None

    def is_global_role(self) -> bool:
        """Check if this is a global/system role."""
        return self.organization_id is None

    def can_be_deleted(self) -> tuple[bool, str]:
        """Check if role can be deleted."""
        if self.is_system_role:
            return False, "System roles cannot be deleted"

        return True, "Role can be deleted"

    def can_be_modified(self) -> tuple[bool, str]:
        """Check if role can be modified."""
        if self.is_system_role:
            return False, "System roles cannot be modified"

        if not self.is_active:
            return False, "Inactive roles cannot be modified"

        return True, "Role can be modified"

    def has_parent(self) -> bool:
        """Check if this role inherits from another role."""
        return self.parent_role_id is not None

    def set_parent_role(self, parent_role_id: UUID) -> "Role":
        """Set parent role for inheritance."""
        if self.is_system_role:
            raise ValueError("System roles cannot inherit from other roles")

        if parent_role_id == self.id:
            raise ValueError("Role cannot inherit from itself")

        return self.model_copy(
            update={"parent_role_id": parent_role_id, "updated_at": datetime.utcnow()}
        )

    def remove_parent_role(self) -> "Role":
        """Remove parent role inheritance."""
        if self.is_system_role:
            raise ValueError("System roles cannot be modified")

        return self.model_copy(
            update={"parent_role_id": None, "updated_at": datetime.now(timezone.utc)}
        )

    def is_descendant_of(self, role_hierarchy: List["Role"], ancestor_id: UUID) -> bool:
        """Check if this role is a descendant of the given ancestor role."""
        if not self.has_parent():
            return False

        # Create lookup map for efficiency
        role_map = {role.id: role for role in role_hierarchy}

        current_parent_id = self.parent_role_id
        visited = set()  # Prevent infinite loops

        while current_parent_id and current_parent_id not in visited:
            if current_parent_id == ancestor_id:
                return True

            visited.add(current_parent_id)
            parent_role = role_map.get(current_parent_id)

            if not parent_role:
                break

            current_parent_id = parent_role.parent_role_id

        return False

    def get_role_hierarchy_path(self, role_hierarchy: List["Role"]) -> List[UUID]:
        """Get the complete inheritance path from root to this role."""
        if not self.has_parent():
            return [self.id]

        # Create lookup map
        role_map = {role.id: role for role in role_hierarchy}

        path = []
        current_role = self
        visited = set()

        while current_role and current_role.id not in visited:
            path.insert(
                0, current_role.id
            )  # Insert at beginning to get root-to-child order
            visited.add(current_role.id)

            if current_role.parent_role_id:
                current_role = role_map.get(current_role.parent_role_id)
            else:
                break

        return path

    def validate_inheritance_rules(
        self, role_hierarchy: List["Role"]
    ) -> tuple[bool, str]:
        """Validate role inheritance rules."""
        if not self.has_parent():
            return True, "Role has no parent"

        # Check for circular inheritance
        if self.is_descendant_of(role_hierarchy, self.id):
            return False, "Circular inheritance detected"

        # Find parent role
        parent_role = next(
            (r for r in role_hierarchy if r.id == self.parent_role_id), None
        )
        if not parent_role:
            return False, "Parent role not found"

        # Check if parent is active
        if not parent_role.is_active:
            return False, "Cannot inherit from inactive role"

        # Check organization scope - child role must be in same or narrower scope
        if self.organization_id and parent_role.organization_id:
            if self.organization_id != parent_role.organization_id:
                return False, "Child role must be in same organization as parent"
        elif self.organization_id and not parent_role.organization_id:
            # OK: organization role can inherit from global role
            pass
        elif not self.organization_id and parent_role.organization_id:
            return False, "Global role cannot inherit from organization role"

        return True, "Inheritance rules validated"
from datetime import datetime, timezone

from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel


class Resource(BaseModel):
    id: UUID
    resource_type: str  # e.g., "user", "organization", "chat", "plan"
    resource_id: UUID  # ID of the actual resource
    owner_id: UUID
    organization_id: Optional[UUID] = None
    attributes: Dict[str, Any]  # For ABAC - resource attributes
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls, 
        resource_type: str, 
        resource_id: UUID, 
        owner_id: UUID,
        organization_id: Optional[UUID] = None,
        attributes: Optional[Dict[str, Any]] = None
    ) -> "Resource":
        return cls(
            id=uuid4(),
            resource_type=resource_type,
            resource_id=resource_id,
            owner_id=owner_id,
            organization_id=organization_id,
            attributes=attributes or {},
            created_at=datetime.now(timezone.utc),
            is_active=True
        )

    def update_attributes(self, attributes: Dict[str, Any]) -> "Resource":
        """Update resource attributes for ABAC."""
        return self.model_copy(update={
            "attributes": {**self.attributes, **attributes},
            "updated_at": datetime.utcnow()
        })

    def set_attribute(self, key: str, value: Any) -> "Resource":
        """Set a single attribute."""
        new_attributes = self.attributes.copy()
        new_attributes[key] = value
        
        return self.model_copy(update={
            "attributes": new_attributes,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_attribute(self, key: str) -> "Resource":
        """Remove an attribute."""
        new_attributes = self.attributes.copy()
        new_attributes.pop(key, None)
        
        return self.model_copy(update={
            "attributes": new_attributes,
            "updated_at": datetime.now(timezone.utc)
        })

    def get_attribute(self, key: str, default: Any = None) -> Any:
        """Get attribute value."""
        return self.attributes.get(key, default)

    def has_attribute(self, key: str) -> bool:
        """Check if resource has specific attribute."""
        return key in self.attributes

    def is_owned_by(self, user_id: UUID) -> bool:
        """Check if resource is owned by specific user."""
        return self.owner_id == user_id

    def belongs_to_organization(self, organization_id: UUID) -> bool:
        """Check if resource belongs to specific organization."""
        return self.organization_id == organization_id

    def deactivate(self) -> "Resource":
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "Resource":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.now(timezone.utc)
        })

    def transfer_ownership(self, new_owner_id: UUID) -> "Resource":
        """Transfer resource ownership."""
        return self.model_copy(update={
            "owner_id": new_owner_id,
            "updated_at": datetime.now(timezone.utc)
        })
from datetime import datetime, timezone
from uuid import UUID
from typing import Optional, Dict, Any, List
from pydantic import BaseModel


class AuthorizationContext(BaseModel):
    """Context for authorization decisions containing all relevant information."""
    
    user_id: UUID
    organization_id: Optional[UUID]
    resource_type: str
    resource_id: Optional[UUID]
    action: str
    user_attributes: Dict[str, Any]
    resource_attributes: Dict[str, Any]
    environment_attributes: Dict[str, Any]
    request_time: datetime
    
    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        resource_type: str,
        action: str,
        organization_id: Optional[UUID] = None,
        resource_id: Optional[UUID] = None,
        user_attributes: Optional[Dict[str, Any]] = None,
        resource_attributes: Optional[Dict[str, Any]] = None,
        environment_attributes: Optional[Dict[str, Any]] = None
    ) -> "AuthorizationContext":
        return cls(
            user_id=user_id,
            organization_id=organization_id,
            resource_type=resource_type,
            resource_id=resource_id,
            action=action,
            user_attributes=user_attributes or {},
            resource_attributes=resource_attributes or {},
            environment_attributes=environment_attributes or {},
            request_time=datetime.now(timezone.utc)
        )

    def add_user_attribute(self, key: str, value: Any) -> "AuthorizationContext":
        """Add user attribute to context."""
        new_attributes = self.user_attributes.copy()
        new_attributes[key] = value
        return self.model_copy(update={"user_attributes": new_attributes})

    def add_resource_attribute(self, key: str, value: Any) -> "AuthorizationContext":
        """Add resource attribute to context."""
        new_attributes = self.resource_attributes.copy()
        new_attributes[key] = value
        return self.model_copy(update={"resource_attributes": new_attributes})

    def add_environment_attribute(self, key: str, value: Any) -> "AuthorizationContext":
        """Add environment attribute to context."""
        new_attributes = self.environment_attributes.copy()
        new_attributes[key] = value
        return self.model_copy(update={"environment_attributes": new_attributes})

    def get_user_attribute(self, key: str, default: Any = None) -> Any:
        """Get user attribute value."""
        return self.user_attributes.get(key, default)

    def get_resource_attribute(self, key: str, default: Any = None) -> Any:
        """Get resource attribute value."""
        return self.resource_attributes.get(key, default)

    def get_environment_attribute(self, key: str, default: Any = None) -> Any:
        """Get environment attribute value."""
        return self.environment_attributes.get(key, default)

    def to_dict(self) -> Dict[str, Any]:
        """Convert context to dictionary for policy evaluation."""
        return {
            "user_id": str(self.user_id),
            "organization_id": str(self.organization_id) if self.organization_id else None,
            "resource_type": self.resource_type,
            "resource_id": str(self.resource_id) if self.resource_id else None,
            "action": self.action,
            "request_time": self.request_time.isoformat(),
            **self.user_attributes,
            **{f"resource_{k}": v for k, v in self.resource_attributes.items()},
            **{f"env_{k}": v for k, v in self.environment_attributes.items()}
        }

    def is_same_organization(self, other_org_id: Optional[UUID]) -> bool:
        """Check if context belongs to same organization."""
        return self.organization_id == other_org_id

    def is_resource_owner(self) -> bool:
        """Check if user is the resource owner."""
        return self.get_resource_attribute("owner_id") == str(self.user_id)

    def get_user_roles(self) -> List[str]:
        """Get user roles from context."""
        return self.get_user_attribute("roles", [])

    def has_role(self, role: str) -> bool:
        """Check if user has specific role."""
        return role in self.get_user_roles()
from .role import Role
from .permission import Permission
from .resource import Resource
from .policy import Policy
from .authorization_context import AuthorizationContext

__all__ = ["Role", "Permission", "Resource", "Policy", "AuthorizationContext"]
from typing import List, Optional
from uuid import UUID

from ..entities.authorization_context import AuthorizationContext
from ..repositories.role_repository import RoleRepository
from ..repositories.permission_repository import PermissionRepository
from ..repositories.role_permission_repository import RolePermissionRepository
from ..value_objects.authorization_decision import AuthorizationDecision, DecisionReason


class RBACService:
    """Role-Based Access Control service."""

    def __init__(
        self,
        role_repository: RoleRepository,
        permission_repository: PermissionRepository,
        role_permission_repository: RolePermissionRepository,
    ):
        self._role_repository = role_repository
        self._permission_repository = permission_repository
        self._role_permission_repository = role_permission_repository

    def authorize(self, context: AuthorizationContext) -> AuthorizationDecision:
        """Authorize request using RBAC."""
        reasons: List[DecisionReason] = []

        # Get user roles
        user_roles = self._role_repository.get_user_roles(
            context.user_id, context.organization_id
        )

        if not user_roles:
            reason = DecisionReason(
                type="rbac_no_roles",
                message="User has no roles assigned",
                details={"user_id": str(context.user_id)},
            )
            return AuthorizationDecision.deny([reason])

        # Get user permissions through roles
        user_permissions = self.get_user_permissions(
            context.user_id, context.organization_id
        )

        if not user_permissions:
            reason = DecisionReason(
                type="rbac_no_permissions",
                message="User has no permissions through assigned roles",
                details={
                    "user_id": str(context.user_id),
                    "roles": [role.name.value for role in user_roles],
                },
            )
            return AuthorizationDecision.deny([reason])

        # Check if user has required permission
        required_permission = f"{context.resource_type}:{context.action}"

        # Check exact permission match
        if required_permission in user_permissions:
            reason = DecisionReason(
                type="rbac_allow",
                message=f"User has required permission: {required_permission}",
                details={
                    "permission": required_permission,
                    "roles": [role.name.value for role in user_roles],
                },
            )
            return AuthorizationDecision.allow([reason])

        # Check wildcard permissions
        resource_wildcard = f"{context.resource_type}:*"
        if resource_wildcard in user_permissions:
            reason = DecisionReason(
                type="rbac_allow",
                message=f"User has wildcard permission for resource: {resource_wildcard}",
                details={
                    "permission": resource_wildcard,
                    "roles": [role.name.value for role in user_roles],
                },
            )
            return AuthorizationDecision.allow([reason])

        # Check global wildcard
        if "*:*" in user_permissions:
            reason = DecisionReason(
                type="rbac_allow",
                message="User has global wildcard permission",
                details={
                    "permission": "*:*",
                    "roles": [role.name.value for role in user_roles],
                },
            )
            return AuthorizationDecision.allow([reason])

        # No matching permission found
        reason = DecisionReason(
            type="rbac_deny",
            message=f"User lacks required permission: {required_permission}",
            details={
                "required_permission": required_permission,
                "user_permissions": user_permissions,
                "roles": [role.name.value for role in user_roles],
            },
        )
        return AuthorizationDecision.deny([reason])

    def get_user_permissions(
        self, user_id: UUID, organization_id: Optional[UUID] = None
    ) -> List[str]:
        """Get all permissions for a user through their roles."""
        # Get user roles
        user_roles = self._role_repository.get_user_roles(user_id, organization_id)

        if not user_roles:
            return []

        # Get permissions for all roles
        all_permissions = set()

        for role in user_roles:
            if not role.is_active:
                continue

            role_permissions = self._permission_repository.get_role_permissions(role.id)

            for permission in role_permissions:
                if permission.is_active:
                    all_permissions.add(permission.get_full_name())

        return list(all_permissions)

    def user_has_permission(
        self,
        user_id: UUID,
        permission_name: str,
        organization_id: Optional[UUID] = None,
    ) -> bool:
        """Check if user has a specific permission."""
        user_permissions = self.get_user_permissions(user_id, organization_id)

        # Check exact match
        if permission_name in user_permissions:
            return True

        # Check wildcard matches
        resource_type, action = (
            permission_name.split(":", 1)
            if ":" in permission_name
            else (permission_name, "")
        )

        # Check resource wildcard
        resource_wildcard = f"{resource_type}:*"
        if resource_wildcard in user_permissions:
            return True

        # Check global wildcard
        if "*:*" in user_permissions:
            return True

        return False

    def get_user_roles_in_organization(
        self, user_id: UUID, organization_id: UUID
    ) -> List[str]:
        """Get user role names in a specific organization."""
        roles = self._role_repository.get_user_roles(user_id, organization_id)
        return [role.name.value for role in roles if role.is_active]

    def user_has_role(
        self, user_id: UUID, role_name: str, organization_id: Optional[UUID] = None
    ) -> bool:
        """Check if user has a specific role."""
        user_roles = self.get_user_roles_in_organization(user_id, organization_id)
        return role_name in user_roles
from typing import List, Set, Dict, Optional
from uuid import UUID

from ..entities.role import Role
from ..entities.permission import Permission


class RoleInheritanceService:
    """Service for handling role inheritance and permission calculation."""
    
    def calculate_inherited_permissions(
        self, 
        role: Role, 
        all_roles: List[Role], 
        role_permissions: Dict[UUID, List[Permission]]
    ) -> List[Permission]:
        """
        Calculate all permissions for a role including inherited permissions.
        
        Args:
            role: The role to calculate permissions for
            all_roles: All available roles in the system
            role_permissions: Map of role_id to direct permissions
            
        Returns:
            List of all permissions (direct + inherited)
        """
        if not role.has_parent():
            return role_permissions.get(role.id, [])
        
        # Get role hierarchy path (from root to current role)
        hierarchy_path = role.get_role_hierarchy_path(all_roles)
        
        # Collect permissions from all roles in hierarchy
        all_permissions = []
        seen_permissions = set()  # Track to avoid duplicates
        
        # Start from root and work down to ensure proper inheritance order
        for role_id in hierarchy_path:
            direct_permissions = role_permissions.get(role_id, [])
            
            for permission in direct_permissions:
                # Use permission action + resource_type as unique key
                permission_key = f"{permission.action}:{permission.resource_type}"
                
                if permission_key not in seen_permissions:
                    all_permissions.append(permission)
                    seen_permissions.add(permission_key)
        
        return all_permissions
    
    def get_role_hierarchy(self, role: Role, all_roles: List[Role]) -> List[Role]:
        """
        Get complete role hierarchy for a given role.
        
        Returns list of roles from root ancestor to the given role.
        """
        if not role.has_parent():
            return [role]
        
        role_map = {r.id: r for r in all_roles}
        hierarchy = []
        
        # Get hierarchy path
        hierarchy_path = role.get_role_hierarchy_path(all_roles)
        
        # Convert IDs to Role objects
        for role_id in hierarchy_path:
            if role_id in role_map:
                hierarchy.append(role_map[role_id])
        
        return hierarchy
    
    def get_child_roles(self, parent_role_id: UUID, all_roles: List[Role]) -> List[Role]:
        """Get all direct child roles of a parent role."""
        return [role for role in all_roles if role.parent_role_id == parent_role_id]
    
    def get_descendant_roles(self, ancestor_role_id: UUID, all_roles: List[Role]) -> List[Role]:
        """Get all descendant roles (children, grandchildren, etc.) of a role."""
        descendants = []
        
        # Get direct children
        children = self.get_child_roles(ancestor_role_id, all_roles)
        
        for child in children:
            descendants.append(child)
            # Recursively get descendants of child
            descendants.extend(self.get_descendant_roles(child.id, all_roles))
        
        return descendants
    
    def validate_role_hierarchy(self, roles: List[Role]) -> List[str]:
        """
        Validate entire role hierarchy for issues.
        
        Returns list of validation errors.
        """
        errors = []
        
        for role in roles:
            is_valid, message = role.validate_inheritance_rules(roles)
            if not is_valid:
                errors.append(f"Role {role.name.value}: {message}")
        
        # Check for orphaned roles (parent_role_id points to non-existent role)
        role_ids = {role.id for role in roles}
        for role in roles:
            if role.parent_role_id and role.parent_role_id not in role_ids:
                errors.append(f"Role {role.name.value}: Parent role {role.parent_role_id} not found")
        
        return errors
    
    def build_role_tree(self, roles: List[Role]) -> Dict[UUID, List[Role]]:
        """
        Build a tree structure of roles organized by parent.
        
        Returns dict where key is parent_role_id and value is list of child roles.
        """
        tree = {}
        
        for role in roles:
            parent_id = role.parent_role_id or "root"
            
            if parent_id not in tree:
                tree[parent_id] = []
            
            tree[parent_id].append(role)
        
        return tree
    
    def get_effective_permissions_for_user_roles(
        self, 
        user_role_ids: List[UUID], 
        all_roles: List[Role], 
        role_permissions: Dict[UUID, List[Permission]]
    ) -> List[Permission]:
        """
        Calculate effective permissions for a user with multiple roles.
        
        Combines permissions from all roles including inherited permissions.
        """
        all_permissions = []
        seen_permissions = set()
        
        for role_id in user_role_ids:
            role = next((r for r in all_roles if r.id == role_id), None)
            if not role or not role.is_active:
                continue
            
            # Get permissions for this role (including inherited)
            role_perms = self.calculate_inherited_permissions(role, all_roles, role_permissions)
            
            for permission in role_perms:
                permission_key = f"{permission.action}:{permission.resource_type}"
                
                if permission_key not in seen_permissions:
                    all_permissions.append(permission)
                    seen_permissions.add(permission_key)
        
        return all_permissions
    
    def can_role_inherit_from(
        self, 
        child_role: Role, 
        potential_parent_role: Role, 
        all_roles: List[Role]
    ) -> tuple[bool, str]:
        """
        Check if a role can inherit from another role.
        
        Returns (can_inherit, reason)
        """
        # Basic checks
        if child_role.id == potential_parent_role.id:
            return False, "Role cannot inherit from itself"
        
        if child_role.is_system_role:
            return False, "System roles cannot inherit from other roles"
        
        if not potential_parent_role.is_active:
            return False, "Cannot inherit from inactive role"
        
        # Check for circular inheritance
        temp_role = child_role.set_parent_role(potential_parent_role.id)
        if temp_role.is_descendant_of(all_roles + [temp_role], child_role.id):
            return False, "Would create circular inheritance"
        
        # Check organization scope
        if child_role.organization_id and potential_parent_role.organization_id:
            if child_role.organization_id != potential_parent_role.organization_id:
                return False, "Child role must be in same organization as parent"
        elif not child_role.organization_id and potential_parent_role.organization_id:
            return False, "Global role cannot inherit from organization role"
        
        return True, "Inheritance is allowed"
from typing import Dict, Any, Optional
from datetime import datetime

from ..entities.policy import Policy, PolicyCondition
from ..entities.authorization_context import AuthorizationContext


class PolicyEvaluationService:
    """Service for evaluating ABAC policies against authorization contexts."""

    def evaluate_policy(
        self, policy: Policy, context: AuthorizationContext
    ) -> Optional[bool]:
        """Evaluate a policy against an authorization context."""
        if not policy.is_active:
            return None

        # Check if policy applies to this request
        if not self._policy_applies_to_context(policy, context):
            return None

        # Convert context to evaluation dictionary
        evaluation_context = context.to_dict()

        # Add computed attributes
        evaluation_context.update(self._get_computed_attributes(context))

        # Evaluate all conditions
        all_conditions_met = True
        for condition in policy.conditions:
            if not self._evaluate_condition(condition, evaluation_context):
                all_conditions_met = False
                break

        if all_conditions_met:
            # All conditions met, return policy effect
            return policy.effect.value == "allow"

        # Conditions not met, policy doesn't apply
        return None

    def _policy_applies_to_context(
        self, policy: Policy, context: AuthorizationContext
    ) -> bool:
        """Check if policy applies to the authorization context."""
        # Check resource type
        if policy.resource_type != context.resource_type:
            return False

        # Check action
        if policy.action != context.action:
            return False

        # Check organization scope
        if policy.organization_id and policy.organization_id != context.organization_id:
            return False

        return True

    def _evaluate_condition(
        self, condition: PolicyCondition, context: Dict[str, Any]
    ) -> bool:
        """Evaluate a single policy condition."""
        try:
            return condition.evaluate(context)
        except Exception:
            # If condition evaluation fails, consider it false
            return False

    def _get_computed_attributes(self, context: AuthorizationContext) -> Dict[str, Any]:
        """Get computed attributes for policy evaluation."""
        now = datetime.utcnow()

        computed = {
            # Time-based attributes
            "current_hour": now.hour,
            "current_day_of_week": now.weekday(),  # 0 = Monday
            "current_month": now.month,
            "current_year": now.year,
            "is_weekend": now.weekday() >= 5,
            "is_business_hours": 9 <= now.hour <= 17,
            # Request attributes
            "is_same_user": str(context.user_id)
            == context.get_resource_attribute("owner_id"),
            "is_same_organization": (
                context.organization_id
                and str(context.organization_id)
                == context.get_resource_attribute("organization_id")
            ),
            # Derived attributes
            "resource_age_days": self._calculate_resource_age_days(context),
            "user_role_count": len(context.get_user_attribute("roles", [])),
        }

        return computed

    def _calculate_resource_age_days(self, context: AuthorizationContext) -> int:
        """Calculate resource age in days."""
        created_at_str = context.get_resource_attribute("created_at")
        if not created_at_str:
            return 0

        try:
            if isinstance(created_at_str, str):
                created_at = datetime.fromisoformat(
                    created_at_str.replace("Z", "+00:00")
                )
            else:
                created_at = created_at_str

            age = datetime.now(timezone.utc) - created_at
            return age.days
        except Exception:
            return 0

    def test_policy_condition(
        self, condition: PolicyCondition, test_context: Dict[str, Any]
    ) -> bool:
        """Test a policy condition with provided context (for testing/debugging)."""
        return self._evaluate_condition(condition, test_context)

    def validate_policy_conditions(self, policy: Policy) -> tuple[bool, list[str]]:
        """Validate policy conditions for syntax and logic errors."""
        errors = []

        for i, condition in enumerate(policy.conditions):
            # Check attribute name
            if not condition.attribute:
                errors.append(f"Condition {i + 1}: attribute name is empty")
                continue

            # Check operator
            valid_operators = [
                "eq",
                "ne",
                "gt",
                "lt",
                "gte",
                "lte",
                "in",
                "not_in",
                "contains",
            ]
            if condition.operator not in valid_operators:
                errors.append(
                    f"Condition {i + 1}: invalid operator '{condition.operator}'"
                )

            # Check value type for specific operators
            if condition.operator in ["in", "not_in"] and not isinstance(
                condition.value, list
            ):
                errors.append(
                    f"Condition {i + 1}: operator '{condition.operator}' requires list value"
                )

            if condition.operator in ["gt", "lt", "gte", "lte"]:
                if not isinstance(condition.value, (int, float)):
                    errors.append(
                        f"Condition {i + 1}: operator '{condition.operator}' requires numeric value"
                    )

        return len(errors) == 0, errors

    def explain_policy_evaluation(
        self, policy: Policy, context: AuthorizationContext
    ) -> Dict[str, Any]:
        """Explain how a policy was evaluated (for debugging)."""
        explanation = {
            "policy_id": str(policy.id),
            "policy_name": policy.name,
            "policy_applies": self._policy_applies_to_context(policy, context),
            "conditions": [],
            "overall_result": None,
        }

        if not explanation["policy_applies"]:
            explanation["reason"] = "Policy does not apply to this context"
            return explanation

        evaluation_context = context.to_dict()
        evaluation_context.update(self._get_computed_attributes(context))

        all_conditions_met = True
        for i, condition in enumerate(policy.conditions):
            condition_result = self._evaluate_condition(condition, evaluation_context)

            explanation["conditions"].append(
                {
                    "index": i,
                    "attribute": condition.attribute,
                    "operator": condition.operator,
                    "expected_value": condition.value,
                    "actual_value": evaluation_context.get(condition.attribute),
                    "result": condition_result,
                }
            )

            if not condition_result:
                all_conditions_met = False

        if all_conditions_met:
            explanation["overall_result"] = policy.effect.value == "allow"
        else:
            explanation["overall_result"] = None
            explanation["reason"] = "Not all conditions were met"

        return explanation
import time
from typing import List
from uuid import UUID

from ..entities.authorization_context import AuthorizationContext
from ..value_objects.authorization_decision import (
    AuthorizationDecision,
    DecisionReason,
)
from .rbac_service import RBACService
from .abac_service import ABACService


class AuthorizationService:
    """Main authorization service that combines RBAC and ABAC."""

    def __init__(self, rbac_service: RBACService, abac_service: ABACService):
        self._rbac_service = rbac_service
        self._abac_service = abac_service

    def authorize(self, context: AuthorizationContext) -> AuthorizationDecision:
        """Main authorization method combining RBAC and ABAC."""
        start_time = time.time()
        reasons: List[DecisionReason] = []

        try:
            # First try RBAC (faster)
            rbac_decision = self._rbac_service.authorize(context)
            reasons.extend(rbac_decision.reasons)

            if rbac_decision.is_allowed():
                # RBAC allows, check if there are any ABAC policies that deny
                abac_decision = self._abac_service.evaluate_policies(context)
                reasons.extend(abac_decision.reasons)

                if abac_decision.is_denied():
                    # ABAC explicitly denies
                    evaluation_time = (time.time() - start_time) * 1000
                    return AuthorizationDecision.deny(reasons, evaluation_time)

                # RBAC allows and ABAC doesn't deny
                evaluation_time = (time.time() - start_time) * 1000
                return AuthorizationDecision.allow(reasons, evaluation_time)

            # RBAC denies, check ABAC for potential allow
            abac_decision = self._abac_service.evaluate_policies(context)
            reasons.extend(abac_decision.reasons)

            if abac_decision.is_allowed():
                # ABAC explicitly allows despite RBAC denial
                evaluation_time = (time.time() - start_time) * 1000
                return AuthorizationDecision.allow(reasons, evaluation_time)

            # Both deny or are not applicable
            evaluation_time = (time.time() - start_time) * 1000

            # If we have explicit deny reasons, deny. Otherwise, default deny
            has_explicit_deny = any(
                reason.type in ["rbac_deny", "policy_deny"] for reason in reasons
            )

            if has_explicit_deny or reasons:
                return AuthorizationDecision.deny(reasons, evaluation_time)
            else:
                # No applicable rules found, default deny
                default_reason = DecisionReason(
                    type="default_deny",
                    message="No applicable authorization rules found",
                    details={
                        "resource_type": context.resource_type,
                        "action": context.action,
                        "user_id": str(context.user_id),
                    },
                )
                return AuthorizationDecision.deny([default_reason], evaluation_time)

        except Exception as e:
            # Authorization failure should default to deny
            evaluation_time = (time.time() - start_time) * 1000
            error_reason = DecisionReason(
                type="authorization_error",
                message=f"Authorization evaluation failed: {str(e)}",
                details={"error": str(e)},
            )
            return AuthorizationDecision.deny([error_reason], evaluation_time)

    def can_user_access_resource(
        self,
        user_id: UUID,
        resource_type: str,
        resource_id: UUID,
        action: str,
        organization_id: UUID = None,
    ) -> bool:
        """Simplified method to check if user can access a resource."""
        context = AuthorizationContext.create(
            user_id=user_id,
            resource_type=resource_type,
            resource_id=resource_id,
            action=action,
            organization_id=organization_id,
        )

        decision = self.authorize(context)
        return decision.is_allowed()

    def get_user_permissions(
        self, user_id: UUID, organization_id: UUID = None
    ) -> List[str]:
        """Get all permissions for a user."""
        return self._rbac_service.get_user_permissions(user_id, organization_id)

    def check_multiple_permissions(
        self,
        user_id: UUID,
        resource_type: str,
        actions: List[str],
        organization_id: UUID = None,
        resource_id: UUID = None,
    ) -> dict[str, bool]:
        """Check multiple permissions at once for efficiency."""
        results = {}

        for action in actions:
            context = AuthorizationContext.create(
                user_id=user_id,
                resource_type=resource_type,
                action=action,
                organization_id=organization_id,
                resource_id=resource_id,
            )

            decision = self.authorize(context)
            results[action] = decision.is_allowed()

        return results
from typing import List, Dict, Any
from uuid import UUID

from ..entities.authorization_context import AuthorizationContext
from ..entities.policy import Policy
from ..repositories.policy_repository import PolicyRepository
from ..repositories.resource_repository import ResourceRepository
from ..value_objects.authorization_decision import AuthorizationDecision, DecisionReason
from .policy_evaluation_service import PolicyEvaluationService


class ABACService:
    """Attribute-Based Access Control service."""

    def __init__(
        self,
        policy_repository: PolicyRepository,
        resource_repository: ResourceRepository,
        policy_evaluation_service: PolicyEvaluationService,
    ):
        self._policy_repository = policy_repository
        self._resource_repository = resource_repository
        self._policy_evaluation_service = policy_evaluation_service

    def evaluate_policies(self, context: AuthorizationContext) -> AuthorizationDecision:
        """Evaluate ABAC policies for the given context."""
        reasons: List[DecisionReason] = []

        # Enrich context with resource attributes if resource_id is provided
        enriched_context = self._enrich_context_with_resource_attributes(context)

        # Get applicable policies
        applicable_policies = self._policy_repository.get_applicable_policies(
            enriched_context.resource_type,
            enriched_context.action,
            enriched_context.organization_id,
        )

        if not applicable_policies:
            reason = DecisionReason(
                type="abac_no_policies",
                message="No applicable ABAC policies found",
                details={
                    "resource_type": enriched_context.resource_type,
                    "action": enriched_context.action,
                },
            )
            return AuthorizationDecision.not_applicable([reason])

        # Sort policies by priority (highest first)
        sorted_policies = sorted(
            applicable_policies, key=lambda p: p.priority, reverse=True
        )

        # Evaluate policies
        policy_results = []
        for policy in sorted_policies:
            if not policy.is_active:
                continue

            evaluation_result = self._policy_evaluation_service.evaluate_policy(
                policy, enriched_context
            )

            if evaluation_result is not None:  # Policy is applicable
                policy_results.append((policy, evaluation_result))

                reason = DecisionReason(
                    type="policy_evaluation",
                    message=f"Policy '{policy.name}' evaluated to {evaluation_result}",
                    details={
                        "policy_id": str(policy.id),
                        "policy_name": policy.name,
                        "effect": policy.effect.value,
                        "result": evaluation_result,
                        "priority": policy.priority,
                    },
                )
                reasons.append(reason)

        # Apply policy combination logic
        final_decision = self._combine_policy_results(policy_results)

        if final_decision is True:
            return AuthorizationDecision.allow(reasons)
        elif final_decision is False:
            return AuthorizationDecision.deny(reasons)
        else:
            # No applicable policies or all policies were not applicable
            reason = DecisionReason(
                type="abac_not_applicable",
                message="No ABAC policies were applicable to this request",
                details={
                    "evaluated_policies": len(policy_results),
                    "total_policies": len(applicable_policies),
                },
            )
            return AuthorizationDecision.not_applicable([reason])

    def _enrich_context_with_resource_attributes(
        self, context: AuthorizationContext
    ) -> AuthorizationContext:
        """Enrich authorization context with resource attributes."""
        if not context.resource_id:
            return context

        # Get resource from repository
        resource = self._resource_repository.get_by_resource_id(
            context.resource_type, context.resource_id
        )

        if not resource:
            return context

        # Add resource attributes to context
        enriched_context = context
        for key, value in resource.attributes.items():
            enriched_context = enriched_context.add_resource_attribute(key, value)

        # Add common resource attributes
        enriched_context = enriched_context.add_resource_attribute(
            "owner_id", str(resource.owner_id)
        )
        enriched_context = enriched_context.add_resource_attribute(
            "is_active", resource.is_active
        )

        if resource.organization_id:
            enriched_context = enriched_context.add_resource_attribute(
                "organization_id", str(resource.organization_id)
            )

        return enriched_context

    def _combine_policy_results(
        self, policy_results: List[tuple[Policy, bool]]
    ) -> bool | None:
        """Combine policy evaluation results using deny-overrides algorithm."""
        if not policy_results:
            return None

        has_allow = False
        has_deny = False

        for policy, result in policy_results:
            if result:  # Policy condition matched
                if policy.effect.value == "deny":
                    has_deny = True
                elif policy.effect.value == "allow":
                    has_allow = True

        # Deny-overrides: if any policy denies, deny
        if has_deny:
            return False

        # If any policy allows and no policy denies, allow
        if has_allow:
            return True

        # No applicable policies
        return None

    def check_resource_ownership(
        self, user_id: UUID, resource_type: str, resource_id: UUID
    ) -> bool:
        """Check if user owns the resource."""
        resource = self._resource_repository.get_by_resource_id(
            resource_type, resource_id
        )

        if not resource:
            return False

        return resource.is_owned_by(user_id)

    def check_resource_organization_membership(
        self,
        user_id: UUID,
        resource_type: str,
        resource_id: UUID,
        organization_id: UUID,
    ) -> bool:
        """Check if resource belongs to user's organization."""
        resource = self._resource_repository.get_by_resource_id(
            resource_type, resource_id
        )

        if not resource:
            return False

        return resource.belongs_to_organization(organization_id)

    def evaluate_policy_conditions(self, policy: Policy, context: AuthorizationContext) -> tuple[bool, list[dict[str, Any]]]:
        """Evaluate policy conditions against context."""
        condition_results = []
        all_conditions_met = True

        for condition in policy.conditions:
            result = self._policy_evaluation_service.evaluate_condition(condition, context.to_dict())
            condition_results.append({
                "condition": condition.model_dump(),
                "result": result
            })
            if not result:
                all_conditions_met = False

        return all_conditions_met, condition_results
from .authorization_service import AuthorizationService
from .rbac_service import RBACService
from .abac_service import ABACService
from .policy_evaluation_service import PolicyEvaluationService

__all__ = [
    "AuthorizationService",
    "RBACService", 
    "ABACService",
    "PolicyEvaluationService"
]
from pydantic import BaseModel, field_validator
from typing import Any
import re


class RoleName(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator("value")
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Role name cannot be empty")

        cleaned_name = v.strip().lower()

        if len(cleaned_name) < 2:
            raise ValueError("Role name must be at least 2 characters long")

        if len(cleaned_name) > 50:
            raise ValueError("Role name cannot exceed 50 characters")

        # Allow letters, numbers, and underscores only
        if not re.match(r"^[a-z0-9_]+$", cleaned_name):
            raise ValueError(
                "Role name can only contain lowercase letters, numbers, and underscores"
            )

        # Must start with a letter
        if not cleaned_name[0].isalpha():
            raise ValueError("Role name must start with a letter")

        return cleaned_name

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, RoleName):
            return self.value == other.value
        return False

    def is_system_role(self) -> bool:
        """Check if this is a system role (starts with 'system_')."""
        return self.value.startswith("system_")

    def get_display_name(self) -> str:
        """Get human-readable display name."""
        return self.value.replace("_", " ").title()
from datetime import datetime, timezone
from typing import Optional, List, Dict, Any
from pydantic import BaseModel
from enum import Enum


class DecisionResult(str, Enum):
    ALLOW = "allow"
    DENY = "deny"
    NOT_APPLICABLE = "not_applicable"


class DecisionReason(BaseModel):
    type: str  # "role", "policy", "ownership", "default"
    message: str
    details: Dict[str, Any]

    model_config = {"frozen": True}


class AuthorizationDecision(BaseModel):
    result: DecisionResult
    reasons: List[DecisionReason]
    evaluated_at: datetime
    evaluation_time_ms: float

    model_config = {"frozen": True}

    @classmethod
    def allow(
        cls, 
        reasons: List[DecisionReason], 
        evaluation_time_ms: float = 0.0
    ) -> "AuthorizationDecision":
        return cls(
            result=DecisionResult.ALLOW,
            reasons=reasons,
            evaluated_at=datetime.now(timezone.utc),
            evaluation_time_ms=evaluation_time_ms
        )

    @classmethod
    def deny(
        cls, 
        reasons: List[DecisionReason], 
        evaluation_time_ms: float = 0.0
    ) -> "AuthorizationDecision":
        return cls(
            result=DecisionResult.DENY,
            reasons=reasons,
            evaluated_at=datetime.now(timezone.utc),
            evaluation_time_ms=evaluation_time_ms
        )

    @classmethod
    def not_applicable(
        cls, 
        reasons: List[DecisionReason], 
        evaluation_time_ms: float = 0.0
    ) -> "AuthorizationDecision":
        return cls(
            result=DecisionResult.NOT_APPLICABLE,
            reasons=reasons,
            evaluated_at=datetime.now(timezone.utc),
            evaluation_time_ms=evaluation_time_ms
        )

    def is_allowed(self) -> bool:
        """Check if the decision allows access."""
        return self.result == DecisionResult.ALLOW

    def is_denied(self) -> bool:
        """Check if the decision denies access."""
        return self.result == DecisionResult.DENY

    def is_not_applicable(self) -> bool:
        """Check if the decision is not applicable."""
        return self.result == DecisionResult.NOT_APPLICABLE

    def get_primary_reason(self) -> Optional[DecisionReason]:
        """Get the primary reason for the decision."""
        return self.reasons[0] if self.reasons else None

    def get_reasons_by_type(self, reason_type: str) -> List[DecisionReason]:
        """Get all reasons of a specific type."""
        return [reason for reason in self.reasons if reason.type == reason_type]

    def add_reason(self, reason: DecisionReason) -> "AuthorizationDecision":
        """Add a reason to the decision."""
        new_reasons = self.reasons.copy()
        new_reasons.append(reason)
        return self.model_copy(update={"reasons": new_reasons})

    def get_summary(self) -> str:
        """Get a summary of the decision."""
        if not self.reasons:
            return f"Access {self.result.value}"
        
        primary_reason = self.get_primary_reason()
        return f"Access {self.result.value}: {primary_reason.message}"

    def to_dict(self) -> Dict[str, Any]:
        """Convert decision to dictionary for logging/debugging."""
        return {
            "result": self.result.value,
            "reasons": [
                {
                    "type": reason.type,
                    "message": reason.message,
                    "details": reason.details
                }
                for reason in self.reasons
            ],
            "evaluated_at": self.evaluated_at.isoformat(),
            "evaluation_time_ms": self.evaluation_time_ms
        }
from .role_name import RoleName
from .permission_name import PermissionName
from .authorization_decision import AuthorizationDecision

__all__ = ["RoleName", "PermissionName", "AuthorizationDecision"]
from pydantic import BaseModel, field_validator
from typing import Any
import re


class PermissionName(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Permission name cannot be empty")
        
        cleaned_name = v.strip().lower()
        
        if len(cleaned_name) < 3:
            raise ValueError("Permission name must be at least 3 characters long")
        
        if len(cleaned_name) > 100:
            raise ValueError("Permission name cannot exceed 100 characters")
        
        # Allow letters, numbers, underscores, and colons
        if not re.match(r'^[a-z0-9_:]+$', cleaned_name):
            raise ValueError("Permission name can only contain lowercase letters, numbers, underscores, and colons")
        
        # Must start with a letter
        if not cleaned_name[0].isalpha():
            raise ValueError("Permission name must start with a letter")
        
        return cleaned_name

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, PermissionName):
            return self.value == other.value
        return False

    def get_resource_type(self) -> str:
        """Extract resource type from permission name (before first colon)."""
        if ':' in self.value:
            return self.value.split(':')[0]
        return self.value

    def get_action(self) -> str:
        """Extract action from permission name (after first colon)."""
        if ':' in self.value:
            parts = self.value.split(':', 1)
            return parts[1] if len(parts) > 1 else ""
        return ""

    def is_resource_permission(self) -> bool:
        """Check if this is a resource-specific permission (contains colon)."""
        return ':' in self.value

    def matches_pattern(self, pattern: str) -> bool:
        """Check if permission matches a pattern (supports wildcards)."""
        if pattern == "*":
            return True
        
        if pattern.endswith("*"):
            prefix = pattern[:-1]
            return self.value.startswith(prefix)
        
        return self.value == pattern

    def get_display_name(self) -> str:
        """Get human-readable display name."""
        return self.value.replace('_', ' ').replace(':', ' - ').title()
from abc import ABC, abstractmethod
from typing import List
from uuid import UUID


class RolePermissionRepository(ABC):
    """Role-Permission repository interface for the Authorization bounded context."""

    @abstractmethod
    def assign_permission_to_role(self, role_id: UUID, permission_id: UUID) -> bool:
        """Assign a permission to a role."""
        pass

    @abstractmethod
    def remove_permission_from_role(self, role_id: UUID, permission_id: UUID) -> bool:
        """Remove a permission from a role."""
        pass

    @abstractmethod
    def get_role_permission_ids(self, role_id: UUID) -> List[UUID]:
        """Get all permission IDs assigned to a role."""
        pass

    @abstractmethod
    def get_permission_role_ids(self, permission_id: UUID) -> List[UUID]:
        """Get all role IDs that have a permission."""
        pass

    @abstractmethod
    def role_has_permission(self, role_id: UUID, permission_id: UUID) -> bool:
        """Check if a role has a specific permission."""
        pass

    @abstractmethod
    def remove_all_role_permissions(self, role_id: UUID) -> int:
        """Remove all permissions from a role. Returns count of removed permissions."""
        pass

    @abstractmethod
    def remove_all_permission_assignments(self, permission_id: UUID) -> int:
        """Remove a permission from all roles. Returns count of removed assignments."""
        pass

    @abstractmethod
    def bulk_assign_permissions_to_role(
        self, role_id: UUID, permission_ids: List[UUID]
    ) -> int:
        """Bulk assign permissions to a role. Returns count of new assignments."""
        pass

    @abstractmethod
    def replace_role_permissions(
        self, role_id: UUID, permission_ids: List[UUID]
    ) -> bool:
        """Replace all permissions for a role with new set."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
from uuid import UUID

from ..entities.resource import Resource


class ResourceRepository(ABC):
    """Resource repository interface for the Authorization bounded context."""

    @abstractmethod
    def save(self, resource: Resource) -> Resource:
        """Save or update a resource."""
        pass

    @abstractmethod
    def get_by_id(self, resource_id: UUID) -> Optional[Resource]:
        """Get resource by ID."""
        pass

    @abstractmethod
    def get_by_resource_id(
        self, resource_type: str, resource_id: UUID
    ) -> Optional[Resource]:
        """Get resource by type and actual resource ID."""
        pass

    @abstractmethod
    def get_by_owner_id(self, owner_id: UUID) -> List[Resource]:
        """Get all resources owned by a user."""
        pass

    @abstractmethod
    def get_by_organization_id(self, organization_id: UUID) -> List[Resource]:
        """Get all resources belonging to an organization."""
        pass

    @abstractmethod
    def get_by_type(self, resource_type: str) -> List[Resource]:
        """Get all resources of a specific type."""
        pass

    @abstractmethod
    def find_by_attributes(
        self, resource_type: str, attributes: Dict[str, Any]
    ) -> List[Resource]:
        """Find resources by attributes."""
        pass

    @abstractmethod
    def delete(self, resource_id: UUID) -> bool:
        """Delete resource by ID."""
        pass

    @abstractmethod
    def delete_by_resource_id(self, resource_type: str, resource_id: UUID) -> bool:
        """Delete resource by type and actual resource ID."""
        pass

    @abstractmethod
    def list_active_resources(
        self, resource_type: Optional[str] = None, limit: int = 100, offset: int = 0
    ) -> List[Resource]:
        """List active resources with pagination."""
        pass

    @abstractmethod
    def count_user_resources(
        self, user_id: UUID, resource_type: Optional[str] = None
    ) -> int:
        """Count resources owned by a user."""
        pass

    @abstractmethod
    def transfer_ownership(
        self, resource_type: str, resource_id: UUID, new_owner_id: UUID
    ) -> bool:
        """Transfer resource ownership."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.policy import Policy, PolicyEffect


class PolicyRepository(ABC):
    """Policy repository interface for the Authorization bounded context."""

    @abstractmethod
    def save(self, policy: Policy) -> Policy:
        """Save or update a policy."""
        pass

    @abstractmethod
    def find_by_id(self, policy_id: UUID) -> Optional[Policy]:
        """Get policy by ID."""
        pass

    @abstractmethod
    def find_by_name(
        self, name: str, organization_id: Optional[UUID] = None
    ) -> Optional[Policy]:
        """Get policy by name within organization scope."""
        pass

    @abstractmethod
    def find_by_resource_and_action(
        self, resource_type: str, action: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        pass

    @abstractmethod
    def find_by_organization(self, organization_id: UUID) -> List[Policy]:
        pass

    @abstractmethod
    def find_global_policies(self) -> List[Policy]:
        pass

    @abstractmethod
    def find_paginated(
        self,
        organization_id: Optional[UUID],
        resource_type: Optional[str],
        action: Optional[str],
        offset: int,
        limit: int,
    ) -> tuple[List[Policy], int]:
        pass

    @abstractmethod
    def get_applicable_policies(
        self, resource_type: str, action: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Get policies applicable to a resource type and action."""
        pass

    @abstractmethod
    def get_organization_policies(self, organization_id: UUID) -> List[Policy]:
        """Get all policies for an organization."""
        pass

    @abstractmethod
    def get_global_policies(self) -> List[Policy]:
        """Get all global policies."""
        pass

    @abstractmethod
    def get_policies_by_effect(
        self, effect: PolicyEffect, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Get policies by effect (allow/deny)."""
        pass

    @abstractmethod
    def delete(self, policy_id: UUID) -> bool:
        """Delete policy by ID."""
        pass

    @abstractmethod
    def list_active_policies(
        self, organization_id: Optional[UUID] = None, limit: int = 100, offset: int = 0
    ) -> List[Policy]:
        """List active policies with pagination."""
        pass

    @abstractmethod
    def search_policies(
        self, query: str, organization_id: Optional[UUID] = None, limit: int = 100
    ) -> List[Policy]:
        """Search policies by name or description."""
        pass

    @abstractmethod
    def get_policies_by_priority(
        self, resource_type: str, action: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Get policies ordered by priority (highest first)."""
        pass

    @abstractmethod
    def find_by_resource_type(self, resource_type: str, organization_id: Optional[UUID]) -> List[Policy]:
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID
from datetime import datetime

from ..entities.role import Role
from ..value_objects.role_name import RoleName


class RoleRepository(ABC):
    """Role repository interface for the Authorization bounded context."""

    @abstractmethod
    def save(self, role: Role) -> Role:
        """Save or update a role."""
        pass

    @abstractmethod
    def get_by_id(self, role_id: UUID) -> Optional[Role]:
        """Get role by ID."""
        pass

    @abstractmethod
    def get_by_name(
        self, name: RoleName, organization_id: Optional[UUID] = None
    ) -> Optional[Role]:
        """Get role by name within organization scope."""
        pass

    @abstractmethod
    def get_organization_roles(self, organization_id: UUID) -> List[Role]:
        """Get all roles for an organization."""
        pass

    @abstractmethod
    def get_system_roles(self) -> List[Role]:
        """Get all system roles."""
        pass

    @abstractmethod
    def get_user_roles(
        self, user_id: UUID, organization_id: Optional[UUID] = None
    ) -> List[Role]:
        """Get roles assigned to a user."""
        pass

    @abstractmethod
    def exists_by_name(
        self, name: RoleName, organization_id: Optional[UUID] = None
    ) -> bool:
        """Check if role exists by name within organization scope."""
        pass

    @abstractmethod
    def delete(self, role_id: UUID) -> bool:
        """Delete role by ID."""
        pass

    @abstractmethod
    def list_active_roles(
        self, organization_id: Optional[UUID] = None, limit: int = 100, offset: int = 0
    ) -> List[Role]:
        """List active roles with pagination."""
        pass

    @abstractmethod
    def count_role_assignments(self, role_id: UUID) -> int:
        """Count how many users have this role assigned."""
        pass

    @abstractmethod
    def get_child_roles(self, parent_role_id: UUID) -> List[Role]:
        """Get all direct child roles of a parent role."""
        pass

    @abstractmethod
    def get_roles_by_parent(self, parent_role_id: Optional[UUID]) -> List[Role]:
        """Get all roles with the specified parent (None for root roles)."""
        pass

    @abstractmethod
    def get_role_hierarchy(self, organization_id: Optional[UUID] = None) -> List[Role]:
        """Get all roles in hierarchical order for an organization."""
        pass

    @abstractmethod
    def has_child_roles(self, role_id: UUID) -> bool:
        """Check if role has any child roles."""
        pass

    @abstractmethod
    def get_root_roles(self, organization_id: Optional[UUID] = None) -> List[Role]:
        """Get all root roles (roles with no parent) for an organization."""
        pass

    @abstractmethod
    def find_paginated(
        self, organization_id: Optional[UUID], include_system: bool, offset: int, limit: int
    ) -> tuple[List[Role], int]:
        pass

    @abstractmethod
    def get_assignment_count(self, role_id: UUID) -> int:
        pass

    @abstractmethod
    def assign_permissions(self, role_id: UUID, permission_ids: list[UUID]) -> None:
        pass

    @abstractmethod
    def replace_permissions(self, role_id: UUID, permission_ids: list[UUID]) -> None:
        pass

    @abstractmethod
    def remove_permissions(self, role_id: UUID, permission_ids: list[UUID]) -> None:
        pass

    @abstractmethod
    def get_role_permissions(self, role_id: UUID) -> List[Role]:
        pass

    @abstractmethod
    def get_permission_count(self, role_id: UUID) -> int:
        pass

    @abstractmethod
    def find_user_roles(self, user_id: UUID, organization_id: Optional[UUID]) -> List[Role]:
        pass

    @abstractmethod
    def find_by_id(self, role_id: UUID) -> Optional[Role]:
        pass

    @abstractmethod
    def assign_role_to_user(
        self, user_id: UUID, role_id: UUID, organization_id: Optional[UUID], assigned_by: UUID, expires_at: Optional[datetime]
    ) -> None:
        pass

    @abstractmethod
    def remove_role_from_user(self, user_id: UUID, role_id: UUID, organization_id: Optional[UUID]) -> bool:
        pass
from .role_repository import RoleRepository
from .permission_repository import PermissionRepository
from .resource_repository import ResourceRepository
from .policy_repository import PolicyRepository
from .role_permission_repository import RolePermissionRepository

__all__ = [
    "RoleRepository", 
    "PermissionRepository", 
    "ResourceRepository", 
    "PolicyRepository",
    "RolePermissionRepository"
]
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.permission import Permission, PermissionAction
from ..value_objects.permission_name import PermissionName


class PermissionRepository(ABC):
    """Permission repository interface for the Authorization bounded context."""

    @abstractmethod
    def save(self, permission: Permission) -> Permission:
        """Save or update a permission."""
        pass

    @abstractmethod
    def find_by_id(self, permission_id: UUID) -> Optional[Permission]:
        """Get permission by ID."""
        pass

    @abstractmethod
    def find_by_name_and_resource(
        self, name: str, resource_type: str
    ) -> Optional[Permission]:
        """Get permission by name and resource type."""
        pass

    @abstractmethod
    def find_by_resource_type(self, resource_type: str) -> List[Permission]:
        """Get all permissions for a resource type."""
        pass

    @abstractmethod
    def get_by_resource_and_type(
        self, resource_type: str, permission_type: PermissionAction
    ) -> List[Permission]:
        """Get permissions by resource type and permission type."""
        pass

    @abstractmethod
    def get_role_permissions(self, role_id: UUID) -> List[Permission]:
        """Get all permissions assigned to a role."""
        pass

    @abstractmethod
    def get_user_permissions(
        self, user_id: UUID, organization_id: Optional[UUID] = None
    ) -> List[Permission]:
        """Get all permissions for a user (through roles)."""
        pass

    @abstractmethod
    def exists_by_name(self, name: PermissionName) -> bool:
        """Check if permission exists by name."""
        pass

    @abstractmethod
    def delete(self, permission_id: UUID) -> bool:
        """Delete permission by ID."""
        pass

    @abstractmethod
    def find_paginated(
        self, include_system: bool, offset: int, limit: int
    ) -> tuple[List[Permission], int]:
        pass

    @abstractmethod
    def search(
        self,
        query: Optional[str],
        resource_type: Optional[str],
        action: Optional[PermissionAction],
        is_active: Optional[bool],
        offset: int,
        limit: int,
    ) -> tuple[List[Permission], int]:
        pass

    @abstractmethod
    def get_role_count(self, permission_id: UUID) -> int:
        pass

    @abstractmethod
    def find_system_permissions(self) -> List[Permission]:
        pass

    @abstractmethod
    def bulk_save(self, permissions: List[Permission]) -> List[Permission]:
        pass

    @abstractmethod
    def find_by_ids(self, permission_ids: List[UUID]) -> List[Permission]:
        pass
from .entities import (
    Role, Permission, Resource, Policy, AuthorizationContext
)
from .value_objects import (
    RoleName, PermissionName, AuthorizationDecision
)
from .repositories import (
    RoleRepository, PermissionRepository, ResourceRepository, 
    PolicyRepository, RolePermissionRepository
)
from .services import (
    AuthorizationService, RBACService, ABACService, PolicyEvaluationService
)

__all__ = [
    # Entities
    "Role", "Permission", "Resource", "Policy", "AuthorizationContext",
    
    # Value Objects
    "RoleName", "PermissionName", "AuthorizationDecision",
    
    # Repositories
    "RoleRepository", "PermissionRepository", "ResourceRepository", 
    "PolicyRepository", "RolePermissionRepository",
    
    # Services
    "AuthorizationService", "RBACService", "ABACService", "PolicyEvaluationService"
]
from fastapi import APIRouter

from .routes.role_routes import router as role_router

# Create main authorization router
authorization_api_router = APIRouter(prefix="/api/v1/authorization", tags=["Authorization Context"])

# Include all sub-routers
authorization_api_router.include_router(role_router)

__all__ = ["authorization_api_router"]
from fastapi import Depends
from sqlalchemy.orm import Session

from shared.infrastructure.database.connection import get_db
from ..infrastructure.repositories.sqlalchemy_role_repository import (
    SqlAlchemyRoleRepository,
)
from ..infrastructure.repositories.sqlalchemy_permission_repository import (
    SqlAlchemyPermissionRepository,
)
from ..application.use_cases.role_use_cases import RoleUseCase
from ..application.use_cases.permission_use_cases import PermissionUseCase


def get_role_repository(db: Session = Depends(get_db)) -> SqlAlchemyRoleRepository:
    """Get role repository dependency."""
    return SqlAlchemyRoleRepository(db)


def get_permission_repository(
    db: Session = Depends(get_db),
) -> SqlAlchemyPermissionRepository:
    """Get permission repository dependency."""
    return SqlAlchemyPermissionRepository(db)


def get_role_use_case(
    role_repo: SqlAlchemyRoleRepository = Depends(get_role_repository),
    permission_repo: SqlAlchemyPermissionRepository = Depends(
        get_permission_repository
    ),
) -> RoleUseCase:
    """Get role use case dependency."""
    return RoleUseCase(role_repo, permission_repo)


def get_permission_use_case(
    permission_repo: SqlAlchemyPermissionRepository = Depends(
        get_permission_repository
    ),
) -> PermissionUseCase:
    """Get permission use case dependency."""
    return PermissionUseCase(permission_repo)
from typing import List, Optional
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status, Query


from ..dependencies import get_role_use_case
from ...application.use_cases.role_use_cases import RoleUseCase
from ...application.dtos.role_dto import (
    RoleCreateDTO,
    RoleUpdateDTO,
    RoleResponseDTO,
    RoleDetailResponseDTO,
    RoleListResponseDTO,
    RolePermissionAssignDTO,
    RolePermissionRemoveDTO,
    RoleInheritanceDTO,
    RoleHierarchyResponseDTO,
)
from ...application.dtos.permission_dto import PermissionResponseDTO

router = APIRouter(prefix="/roles", tags=["Roles"])


@router.post("/", response_model=RoleResponseDTO, status_code=status.HTTP_201_CREATED)
async def create_role(
    role_data: RoleCreateDTO,
    created_by: UUID = Query(..., description="User ID who is creating the role"),
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Create a new role with optional parent for inheritance."""
    try:
        return role_use_case.create_role(role_data, created_by)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/{role_id}", response_model=RoleDetailResponseDTO)
async def get_role(
    role_id: UUID,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Get role by ID with permissions."""
    role = role_use_case.get_role_by_id(role_id)
    if not role:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
    return role


@router.put("/{role_id}", response_model=RoleResponseDTO)
async def update_role(
    role_id: UUID,
    role_data: RoleUpdateDTO,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Update an existing role."""
    try:
        role = role_use_case.update_role(role_id, role_data)
        if not role:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
        return role
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.delete("/{role_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_role(
    role_id: UUID,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Delete a role (soft delete)."""
    try:
        success = role_use_case.delete_role(role_id)
        if not success:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/", response_model=RoleListResponseDTO)
async def list_roles(
    organization_id: Optional[UUID] = Query(None, description="Filter by organization"),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    include_system: bool = Query(True, description="Include system roles"),
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """List roles with pagination."""
    try:
        return role_use_case.list_roles(
            organization_id=organization_id,
            page=page,
            page_size=page_size,
            include_system=include_system,
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.post("/{role_id}/permissions", response_model=RoleDetailResponseDTO)
async def assign_permissions(
    role_id: UUID,
    permission_data: RolePermissionAssignDTO,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Assign permissions to a role."""
    try:
        role = role_use_case.assign_permissions(role_id, permission_data)
        if not role:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
        return role
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.delete("/{role_id}/permissions", response_model=RoleDetailResponseDTO)
async def remove_permissions(
    role_id: UUID,
    permission_data: RolePermissionRemoveDTO,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Remove permissions from a role."""
    try:
        role = role_use_case.remove_permissions(role_id, permission_data)
        if not role:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
        return role
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


# Role Inheritance Endpoints

@router.put("/{role_id}/parent", response_model=RoleResponseDTO)
async def set_role_parent(
    role_id: UUID,
    inheritance_data: RoleInheritanceDTO,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Set parent role for inheritance."""
    try:
        role = role_use_case.set_role_parent(role_id, inheritance_data.parent_role_id)
        if not role:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
        return role
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.delete("/{role_id}/parent", response_model=RoleResponseDTO)
async def remove_role_parent(
    role_id: UUID,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Remove parent role inheritance."""
    try:
        role = role_use_case.remove_role_parent(role_id)
        if not role:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Role not found")
        return role
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/hierarchy/", response_model=List[RoleResponseDTO])
async def get_role_hierarchy(
    organization_id: Optional[UUID] = Query(None, description="Organization ID"),
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Get role hierarchy for an organization."""
    try:
        return role_use_case.get_role_hierarchy(organization_id)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/{role_id}/children", response_model=List[RoleResponseDTO])
async def get_role_children(
    role_id: UUID,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Get direct child roles of a role."""
    try:
        return role_use_case.get_role_children(role_id)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/{role_id}/effective-permissions", response_model=List[PermissionResponseDTO])
async def get_effective_permissions(
    role_id: UUID,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Get all effective permissions for a role (including inherited)."""
    try:
        return role_use_case.get_effective_permissions(role_id)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/hierarchy/tree", response_model=dict)
async def get_role_tree(
    organization_id: Optional[UUID] = Query(None, description="Organization ID"),
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Get role hierarchy as tree structure."""
    try:
        return role_use_case.get_role_tree(organization_id)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/hierarchy/validate", response_model=List[str])
async def validate_role_hierarchy(
    organization_id: Optional[UUID] = Query(None, description="Organization ID"),
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Validate role hierarchy for issues."""
    try:
        return role_use_case.validate_role_hierarchy(organization_id)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))


@router.get("/organization/{organization_id}", response_model=List[RoleResponseDTO])
async def get_roles_by_organization(
    organization_id: UUID,
    role_use_case: RoleUseCase = Depends(get_role_use_case),
):
    """Get all roles for an organization."""
    try:
        return role_use_case.get_roles_by_organization(organization_id)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))
from .role_routes import router as role_router

__all__ = ["role_router"]
from .routers import authorization_api_router

__all__ = ["authorization_api_router"]
from datetime import datetime
from typing import Optional, List
from uuid import UUID
from pydantic import BaseModel, Field, field_validator


class RoleCreateDTO(BaseModel):
    """DTO for creating a new role."""

    name: str = Field(..., min_length=2, max_length=50, description="Role name")
    description: str = Field(..., max_length=500, description="Role description")
    organization_id: Optional[UUID] = Field(
        None, description="Organization ID (None for global roles)"
    )
    parent_role_id: Optional[UUID] = Field(
        None, description="Parent role ID for inheritance"
    )
    permission_ids: List[UUID] = Field(
        default_factory=list, description="Initial permissions to assign"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Role name cannot be empty")
        # Convert to lowercase with underscores
        return v.strip().lower().replace(" ", "_").replace("-", "_")


class RoleUpdateDTO(BaseModel):
    """DTO for updating an existing role."""

    description: Optional[str] = Field(
        None, max_length=500, description="Role description"
    )
    permission_ids: Optional[List[UUID]] = Field(
        None, description="Permissions to assign (replaces current)"
    )


class RolePermissionAssignDTO(BaseModel):
    """DTO for assigning permissions to a role."""

    permission_ids: List[UUID] = Field(..., description="Permission IDs to assign")


class RolePermissionRemoveDTO(BaseModel):
    """DTO for removing permissions from a role."""

    permission_ids: List[UUID] = Field(..., description="Permission IDs to remove")


class RoleInheritanceDTO(BaseModel):
    """DTO for setting role inheritance."""

    parent_role_id: UUID = Field(..., description="Parent role ID")


class RoleHierarchyResponseDTO(BaseModel):
    """DTO for role hierarchy response."""

    roles: List["RoleResponseDTO"]
    hierarchy_tree: dict
    validation_errors: List[str] = Field(default_factory=list)


class RoleResponseDTO(BaseModel):
    """DTO for role response data."""

    id: UUID
    name: str
    description: str
    organization_id: Optional[UUID] = None
    parent_role_id: Optional[UUID] = None
    created_by: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool
    is_system_role: bool
    permission_count: int
    assignment_count: int
    has_children: bool = False
    inheritance_level: int = 0

    model_config = {"from_attributes": True}


class RoleDetailResponseDTO(RoleResponseDTO):
    """DTO for detailed role response with permissions."""

    permissions: List["PermissionResponseDTO"]


class RoleListResponseDTO(BaseModel):
    """DTO for paginated role list response."""

    roles: List[RoleResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


# Forward reference import
from .permission_dto import PermissionResponseDTO

RoleDetailResponseDTO.model_rebuild()
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field


class AuthorizationRequestDTO(BaseModel):
    """DTO for authorization request."""
    user_id: UUID = Field(..., description="User ID")
    resource_type: str = Field(..., description="Resource type")
    action: str = Field(..., description="Action to perform")
    organization_id: Optional[UUID] = Field(None, description="Organization ID")
    resource_id: Optional[UUID] = Field(None, description="Specific resource ID")
    user_attributes: Dict[str, Any] = Field(default_factory=dict, description="User attributes")
    resource_attributes: Dict[str, Any] = Field(default_factory=dict, description="Resource attributes")
    environment_attributes: Dict[str, Any] = Field(default_factory=dict, description="Environment attributes")


class AuthorizationResponseDTO(BaseModel):
    """DTO for authorization response."""
    user_id: UUID
    resource_type: str
    action: str
    is_authorized: bool
    decision_reason: str
    rbac_result: Optional[bool] = None
    abac_result: Optional[bool] = None
    applicable_roles: List[str] = Field(default_factory=list)
    applicable_policies: List[str] = Field(default_factory=list)
    evaluation_time_ms: float
    evaluated_at: datetime


class BulkAuthorizationRequestDTO(BaseModel):
    """DTO for bulk authorization request."""
    requests: List[AuthorizationRequestDTO] = Field(..., description="List of authorization requests")


class BulkAuthorizationResponseDTO(BaseModel):
    """DTO for bulk authorization response."""
    results: List[AuthorizationResponseDTO]
    total_requests: int
    authorized_count: int
    denied_count: int
    total_evaluation_time_ms: float


class UserPermissionsResponseDTO(BaseModel):
    """DTO for user permissions response."""
    user_id: UUID
    organization_id: Optional[UUID] = None
    resource_type: Optional[str] = None
    roles: List[str]
    permissions: List[Dict[str, Any]]
    permission_count: int


class RoleAssignmentDTO(BaseModel):
    """DTO for role assignment."""
    user_id: UUID = Field(..., description="User ID")
    role_id: UUID = Field(..., description="Role ID")
    organization_id: Optional[UUID] = Field(None, description="Organization ID")
    assigned_by: UUID = Field(..., description="User who assigned the role")
    expires_at: Optional[datetime] = Field(None, description="Role expiration date")
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from enum import Enum


class PolicyEffectEnum(str, Enum):
    ALLOW = "allow"
    DENY = "deny"


class PolicyConditionDTO(BaseModel):
    """DTO for policy condition."""

    attribute: str = Field(..., description="Attribute name")
    operator: str = Field(..., description="Comparison operator")
    value: Any = Field(..., description="Expected value")

    @field_validator("operator")
    @classmethod
    def validate_operator(cls, v: str) -> str:
        valid_operators = [
            "eq",
            "ne",
            "gt",
            "lt",
            "gte",
            "lte",
            "in",
            "not_in",
            "contains",
        ]
        if v not in valid_operators:
            raise ValueError(
                f"Invalid operator. Must be one of: {', '.join(valid_operators)}"
            )
        return v


class PolicyCreateDTO(BaseModel):
    """DTO for creating a new policy."""

    name: str = Field(..., min_length=2, max_length=100, description="Policy name")
    description: str = Field(..., max_length=500, description="Policy description")
    effect: PolicyEffectEnum = Field(..., description="Policy effect (allow/deny)")
    resource_type: str = Field(..., description="Resource type")
    action: str = Field(..., description="Action")
    conditions: List[PolicyConditionDTO] = Field(
        default_factory=list, description="Policy conditions"
    )
    organization_id: Optional[UUID] = Field(
        None, description="Organization ID (None for global policies)"
    )
    priority: int = Field(
        0, ge=0, le=1000, description="Policy priority (higher = more important)"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Policy name cannot be empty")
        return v.strip()


class PolicyUpdateDTO(BaseModel):
    """DTO for updating an existing policy."""

    description: Optional[str] = Field(
        None, max_length=500, description="Policy description"
    )
    effect: Optional[PolicyEffectEnum] = Field(None, description="Policy effect")
    conditions: Optional[List[PolicyConditionDTO]] = Field(
        None, description="Policy conditions"
    )
    priority: Optional[int] = Field(None, ge=0, le=1000, description="Policy priority")


class PolicyResponseDTO(BaseModel):
    """DTO for policy response data."""

    id: UUID
    name: str
    description: str
    effect: str
    resource_type: str
    action: str
    conditions: List[Dict[str, Any]]
    organization_id: Optional[UUID] = None
    created_by: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool
    priority: int

    model_config = {"from_attributes": True}


class PolicyListResponseDTO(BaseModel):
    """DTO for paginated policy list response."""

    policies: List[PolicyResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class PolicyEvaluationRequestDTO(BaseModel):
    """DTO for policy evaluation request."""

    user_id: UUID = Field(..., description="User ID")
    resource_type: str = Field(..., description="Resource type")
    action: str = Field(..., description="Action")
    organization_id: Optional[UUID] = Field(None, description="Organization ID")
    resource_id: Optional[UUID] = Field(None, description="Resource ID")
    user_attributes: Dict[str, Any] = Field(
        default_factory=dict, description="User attributes"
    )
    resource_attributes: Dict[str, Any] = Field(
        default_factory=dict, description="Resource attributes"
    )
    environment_attributes: Dict[str, Any] = Field(
        default_factory=dict, description="Environment attributes"
    )


class PolicyEvaluationResponseDTO(BaseModel):
    """DTO for policy evaluation response."""

    policy_id: UUID
    policy_name: str
    result: Optional[bool]  # None if not applicable
    conditions_met: bool
    condition_results: List[Dict[str, Any]]
    evaluation_time_ms: float
from datetime import datetime
from typing import List, Optional
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from enum import Enum


class PermissionActionEnum(str, Enum):
    CREATE = "create"
    READ = "read"
    UPDATE = "update"
    DELETE = "delete"
    EXECUTE = "execute"
    MANAGE = "manage"


class PermissionCreateDTO(BaseModel):
    """DTO for creating a new permission."""

    name: str = Field(..., min_length=3, max_length=100, description="Permission name")
    description: str = Field(..., max_length=500, description="Permission description")
    action: PermissionActionEnum = Field(..., description="Permission action")
    resource_type: str = Field(
        ..., min_length=2, max_length=50, description="Resource type"
    )

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Permission name cannot be empty")
        # Convert to lowercase with underscores/colons
        return v.strip().lower().replace(" ", "_").replace("-", "_")

    @field_validator("resource_type")
    @classmethod
    def validate_resource_type(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Resource type cannot be empty")
        return v.strip().lower().replace(" ", "_").replace("-", "_")


class PermissionResponseDTO(BaseModel):
    """DTO for permission response data."""

    id: UUID
    name: str
    description: str
    action: str
    resource_type: str
    full_name: str  # resource_type:action
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool
    is_system_permission: bool
    role_count: int  # Number of roles that have this permission

    model_config = {"from_attributes": True}


class PermissionListResponseDTO(BaseModel):
    """DTO for paginated permission list response."""

    permissions: List[PermissionResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class PermissionSearchDTO(BaseModel):
    """DTO for permission search criteria."""

    query: Optional[str] = Field(None, description="Search query")
    resource_type: Optional[str] = Field(None, description="Filter by resource type")
    action: Optional[PermissionActionEnum] = Field(
        None, description="Filter by permission action"
    )
    is_active: Optional[bool] = Field(None, description="Filter by active status")
from .role_dto import (
    RoleCreateDTO, RoleUpdateDTO, RoleResponseDTO, RoleDetailResponseDTO,
    RoleListResponseDTO, RolePermissionAssignDTO, RolePermissionRemoveDTO
)
from .permission_dto import (
    PermissionCreateDTO, PermissionResponseDTO, PermissionListResponseDTO,
    PermissionSearchDTO
)
from .policy_dto import (
    PolicyCreateDTO, PolicyUpdateDTO, PolicyResponseDTO, PolicyListResponseDTO,
    PolicyEvaluationRequestDTO, PolicyEvaluationResponseDTO
)
from .authorization_dto import (
    AuthorizationRequestDTO, AuthorizationResponseDTO,
    BulkAuthorizationRequestDTO, BulkAuthorizationResponseDTO,
    UserPermissionsResponseDTO, RoleAssignmentDTO
)

__all__ = [
    # Role DTOs
    "RoleCreateDTO", "RoleUpdateDTO", "RoleResponseDTO", "RoleDetailResponseDTO",
    "RoleListResponseDTO", "RolePermissionAssignDTO", "RolePermissionRemoveDTO",
    
    # Permission DTOs
    "PermissionCreateDTO", "PermissionResponseDTO", "PermissionListResponseDTO",
    "PermissionSearchDTO",
    
    # Policy DTOs
    "PolicyCreateDTO", "PolicyUpdateDTO", "PolicyResponseDTO", "PolicyListResponseDTO",
    "PolicyEvaluationRequestDTO", "PolicyEvaluationResponseDTO",
    
    # Authorization DTOs
    "AuthorizationRequestDTO", "AuthorizationResponseDTO",
    "BulkAuthorizationRequestDTO", "BulkAuthorizationResponseDTO",
    "UserPermissionsResponseDTO", "RoleAssignmentDTO"
]
from .dtos import (
    # Role DTOs
    RoleCreateDTO, RoleUpdateDTO, RoleResponseDTO, RoleDetailResponseDTO,
    RoleListResponseDTO, RolePermissionAssignDTO, RolePermissionRemoveDTO,
    
    # Permission DTOs
    PermissionCreateDTO, PermissionResponseDTO, PermissionListResponseDTO,
    PermissionSearchDTO,
    
    # Policy DTOs
    PolicyCreateDTO, PolicyUpdateDTO, PolicyResponseDTO, PolicyListResponseDTO,
    PolicyEvaluationRequestDTO, PolicyEvaluationResponseDTO,
    
    # Authorization DTOs
    AuthorizationRequestDTO, AuthorizationResponseDTO,
    BulkAuthorizationRequestDTO, BulkAuthorizationResponseDTO,
    UserPermissionsResponseDTO, RoleAssignmentDTO
)
from .use_cases import (
    AuthorizationUseCase, RoleUseCase, PermissionUseCase, PolicyUseCase
)

__all__ = [
    # DTOs
    "RoleCreateDTO", "RoleUpdateDTO", "RoleResponseDTO", "RoleDetailResponseDTO",
    "RoleListResponseDTO", "RolePermissionAssignDTO", "RolePermissionRemoveDTO",
    "PermissionCreateDTO", "PermissionResponseDTO", "PermissionListResponseDTO",
    "PermissionSearchDTO",
    "PolicyCreateDTO", "PolicyUpdateDTO", "PolicyResponseDTO", "PolicyListResponseDTO",
    "PolicyEvaluationRequestDTO", "PolicyEvaluationResponseDTO",
    "AuthorizationRequestDTO", "AuthorizationResponseDTO",
    "BulkAuthorizationRequestDTO", "BulkAuthorizationResponseDTO",
    "UserPermissionsResponseDTO", "RoleAssignmentDTO",
    
    # Use Cases
    "AuthorizationUseCase", "RoleUseCase", "PermissionUseCase", "PolicyUseCase"
]
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID

from ...domain.entities.role import Role
from ...domain.repositories.role_repository import RoleRepository
from ...domain.repositories.permission_repository import PermissionRepository
from ...domain.services.role_inheritance_service import RoleInheritanceService
from ..dtos.role_dto import (
    RoleCreateDTO,
    RoleUpdateDTO,
    RoleResponseDTO,
    RoleDetailResponseDTO,
    RoleListResponseDTO,
    RolePermissionAssignDTO,
    RolePermissionRemoveDTO,
)
from ..dtos.permission_dto import PermissionResponseDTO


class RoleUseCase:
    """Use case for role management operations."""

    def __init__(
        self,
        role_repository: RoleRepository,
        permission_repository: PermissionRepository,
    ):
        self.role_repository = role_repository
        self.permission_repository = permission_repository
        self.role_inheritance_service = RoleInheritanceService()

    def create_role(self, dto: RoleCreateDTO, created_by: UUID) -> RoleResponseDTO:
        """Create a new role."""
        # Validate parent role if provided
        if hasattr(dto, 'parent_role_id') and dto.parent_role_id:
            parent_role = self.role_repository.get_by_id(dto.parent_role_id)
            if not parent_role:
                raise ValueError("Parent role not found")
            
            # Validate inheritance rules
            temp_role = Role.create(
                name=dto.name,
                description=dto.description,
                created_by=created_by,
                organization_id=dto.organization_id,
                parent_role_id=dto.parent_role_id
            )
            
            all_roles = self.role_repository.get_role_hierarchy(dto.organization_id)
            can_inherit, reason = self.role_inheritance_service.can_role_inherit_from(
                temp_role, parent_role, all_roles
            )
            
            if not can_inherit:
                raise ValueError(f"Invalid inheritance: {reason}")

        # Validate permissions exist
        if hasattr(dto, 'permission_ids') and dto.permission_ids:
            permissions = self.permission_repository.find_by_ids(dto.permission_ids)
            if len(permissions) != len(dto.permission_ids):
                raise ValueError("One or more permissions not found")

        # Create role entity
        role = Role.create(
            name=dto.name,
            description=dto.description,
            created_by=created_by,
            organization_id=dto.organization_id,
            parent_role_id=getattr(dto, 'parent_role_id', None)
        )

        # Save role
        saved_role = self.role_repository.save(role)

        # Assign permissions if provided
        if hasattr(dto, 'permission_ids') and dto.permission_ids:
            self.role_repository.assign_permissions(saved_role.id, dto.permission_ids)

        return self._build_role_response(saved_role)

    def get_role_by_id(self, role_id: UUID) -> Optional[RoleDetailResponseDTO]:
        """Get role by ID with permissions."""
        role = self.role_repository.get_by_id(role_id)
        if not role:
            return None

        return self._build_role_detail_response(role)

    def update_role(
        self, role_id: UUID, dto: RoleUpdateDTO
    ) -> Optional[RoleResponseDTO]:
        """Update an existing role."""
        role = self.role_repository.get_by_id(role_id)
        if not role:
            return None

        # Update fields
        if dto.description is not None:
            role.description = dto.description

        role.updated_at = datetime.now(timezone.utc)

        # Save role
        updated_role = self.role_repository.save(role)

        # Update permissions if provided
        if dto.permission_ids is not None:
            # Validate permissions exist
            if dto.permission_ids:
                permissions = self.permission_repository.find_by_ids(dto.permission_ids)
                if len(permissions) != len(dto.permission_ids):
                    raise ValueError("One or more permissions not found")

            self.role_repository.replace_permissions(role_id, dto.permission_ids)

        return self._build_role_response(updated_role)

    def delete_role(self, role_id: UUID) -> bool:
        """Delete a role (soft delete)."""
        role = self.role_repository.get_by_id(role_id)
        if not role:
            return False

        # Check if role is system role
        if role.is_system_role:
            raise ValueError("Cannot delete system role")

        # Check if role has assignments
        assignment_count = self.role_repository.get_assignment_count(role_id)
        if assignment_count > 0:
            raise ValueError("Cannot delete role with active assignments")

        role.is_active = False
        role.updated_at = datetime.now(timezone.utc)
        self.role_repository.save(role)

        return True

    def list_roles(
        self,
        organization_id: Optional[UUID] = None,
        page: int = 1,
        page_size: int = 20,
        include_system: bool = True,
    ) -> RoleListResponseDTO:
        """List roles with pagination."""
        offset = (page - 1) * page_size

        roles, total = self.role_repository.find_paginated(
            organization_id=organization_id,
            include_system=include_system,
            offset=offset,
            limit=page_size,
        )

        role_responses = []
        for role in roles:
            role_responses.append(self._build_role_response(role))

        total_pages = (total + page_size - 1) // page_size

        return RoleListResponseDTO(
            roles=role_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def assign_permissions(
        self, role_id: UUID, dto: RolePermissionAssignDTO
    ) -> Optional[RoleDetailResponseDTO]:
        """Assign permissions to a role."""
        role = self.role_repository.get_by_id(role_id)
        if not role:
            return None

        # Validate permissions exist
        permissions = self.permission_repository.find_by_ids(dto.permission_ids)
        if len(permissions) != len(dto.permission_ids):
            raise ValueError("One or more permissions not found")

        self.role_repository.assign_permissions(role_id, dto.permission_ids)

        return self._build_role_detail_response(role)

    def remove_permissions(
        self, role_id: UUID, dto: RolePermissionRemoveDTO
    ) -> Optional[RoleDetailResponseDTO]:
        """Remove permissions from a role."""
        role = self.role_repository.get_by_id(role_id)
        if not role:
            return None

        self.role_repository.remove_permissions(role_id, dto.permission_ids)

        return self._build_role_detail_response(role)

    def get_roles_by_organization(self, organization_id: UUID) -> List[RoleResponseDTO]:
        """Get all roles for an organization."""
        roles = self.role_repository.get_organization_roles(organization_id)

        role_responses = []
        for role in roles:
            role_responses.append(self._build_role_response(role))

        return role_responses

    def set_role_parent(self, role_id: UUID, parent_role_id: UUID) -> Optional[RoleResponseDTO]:
        """Set parent role for inheritance."""
        role = self.role_repository.get_by_id(role_id)
        if not role:
            raise ValueError("Role not found")
        
        parent_role = self.role_repository.get_by_id(parent_role_id)
        if not parent_role:
            raise ValueError("Parent role not found")
        
        # Validate inheritance rules
        all_roles = self.role_repository.get_role_hierarchy(role.organization_id)
        can_inherit, reason = self.role_inheritance_service.can_role_inherit_from(
            role, parent_role, all_roles
        )
        
        if not can_inherit:
            raise ValueError(f"Invalid inheritance: {reason}")
        
        # Update role
        updated_role = role.set_parent_role(parent_role_id)
        saved_role = self.role_repository.save(updated_role)
        
        return self._build_role_response(saved_role)

    def remove_role_parent(self, role_id: UUID) -> Optional[RoleResponseDTO]:
        """Remove parent role inheritance."""
        role = self.role_repository.get_by_id(role_id)
        if not role:
            raise ValueError("Role not found")
        
        # Update role
        updated_role = role.remove_parent_role()
        saved_role = self.role_repository.save(updated_role)
        
        return self._build_role_response(saved_role)

    def get_role_hierarchy(self, organization_id: Optional[UUID] = None) -> List[RoleResponseDTO]:
        """Get role hierarchy for an organization."""
        roles = self.role_repository.get_role_hierarchy(organization_id)
        
        role_responses = []
        for role in roles:
            role_responses.append(self._build_role_response(role))
        
        return role_responses

    def get_role_children(self, role_id: UUID) -> List[RoleResponseDTO]:
        """Get direct child roles of a role."""
        child_roles = self.role_repository.get_child_roles(role_id)
        
        role_responses = []
        for role in child_roles:
            role_responses.append(self._build_role_response(role))
        
        return role_responses

    def get_effective_permissions(self, role_id: UUID) -> List[PermissionResponseDTO]:
        """Get all effective permissions for a role (including inherited)."""
        role = self.role_repository.get_by_id(role_id)
        if not role:
            raise ValueError("Role not found")
        
        # Get all roles for hierarchy calculation
        all_roles = self.role_repository.get_role_hierarchy(role.organization_id)
        
        # Get role permissions mapping
        role_permissions = {}
        for r in all_roles:
            permissions = self.role_repository.get_role_permissions(r.id)
            role_permissions[r.id] = permissions
        
        # Calculate inherited permissions
        effective_permissions = self.role_inheritance_service.calculate_inherited_permissions(
            role, all_roles, role_permissions
        )
        
        # Convert to DTOs
        permission_responses = []
        for perm in effective_permissions:
            permission_responses.append(
                PermissionResponseDTO(
                    id=perm.id,
                    name=perm.name,
                    description=perm.description,
                    permission_type=perm.permission_type,
                    resource_type=perm.resource_type,
                    full_name=perm.full_name,
                    created_at=perm.created_at,
                    updated_at=perm.updated_at,
                    is_active=perm.is_active,
                    is_system_permission=perm.is_system_permission,
                    role_count=0,
                )
            )
        
        return permission_responses

    def validate_role_hierarchy(self, organization_id: Optional[UUID] = None) -> List[str]:
        """Validate role hierarchy for issues."""
        roles = self.role_repository.get_role_hierarchy(organization_id)
        return self.role_inheritance_service.validate_role_hierarchy(roles)

    def get_role_tree(self, organization_id: Optional[UUID] = None) -> dict:
        """Get role hierarchy as tree structure."""
        roles = self.role_repository.get_role_hierarchy(organization_id)
        tree = self.role_inheritance_service.build_role_tree(roles)
        
        # Convert to response DTOs
        response_tree = {}
        for parent_id, child_roles in tree.items():
            parent_key = str(parent_id) if parent_id != "root" else "root"
            response_tree[parent_key] = [
                self._build_role_response(role) for role in child_roles
            ]
        
        return response_tree

    def _build_role_response(self, role: Role) -> RoleResponseDTO:
        """Build role response DTO."""
        permission_count = self.role_repository.get_permission_count(role.id)
        assignment_count = self.role_repository.get_assignment_count(role.id)
        has_children = self.role_repository.has_child_roles(role.id)
        
        # Calculate inheritance level
        inheritance_level = 0
        if role.has_parent():
            all_roles = self.role_repository.get_role_hierarchy(role.organization_id)
            hierarchy_path = role.get_role_hierarchy_path(all_roles)
            inheritance_level = len(hierarchy_path) - 1

        return RoleResponseDTO(
            id=role.id,
            name=role.name.value,
            description=role.description,
            organization_id=role.organization_id,
            parent_role_id=role.parent_role_id,
            created_by=role.created_by,
            created_at=role.created_at,
            updated_at=role.updated_at,
            is_active=role.is_active,
            is_system_role=role.is_system_role,
            permission_count=permission_count,
            assignment_count=assignment_count,
            has_children=has_children,
            inheritance_level=inheritance_level,
        )

    def _build_role_detail_response(self, role: Role) -> RoleDetailResponseDTO:
        """Build detailed role response DTO with permissions."""
        role_response = self._build_role_response(role)

        # Get permissions
        permissions = self.role_repository.get_role_permissions(role.id)
        permission_responses = [
            PermissionResponseDTO(
                id=perm.id,
                name=perm.name,
                description=perm.description,
                permission_type=perm.permission_type,
                resource_type=perm.resource_type,
                full_name=perm.full_name,
                created_at=perm.created_at,
                updated_at=perm.updated_at,
                is_active=perm.is_active,
                is_system_permission=perm.is_system_permission,
                role_count=0,  # Not needed in this context
            )
            for perm in permissions
        ]

        return RoleDetailResponseDTO(
            **role_response.model_dump(), permissions=permission_responses
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID

from ...domain.entities.permission import Permission
from ...domain.repositories.permission_repository import PermissionRepository
from ..dtos.permission_dto import (
    PermissionCreateDTO,
    PermissionResponseDTO,
    PermissionListResponseDTO,
    PermissionSearchDTO,
)


class PermissionUseCase:
    """Use case for permission management operations."""

    def __init__(self, permission_repository: PermissionRepository):
        self.permission_repository = permission_repository

    def create_permission(self, dto: PermissionCreateDTO) -> PermissionResponseDTO:
        """Create a new permission."""
        # Check if permission already exists
        existing = self.permission_repository.find_by_name_and_resource(
            dto.name, dto.resource_type
        )
        if existing:
            raise ValueError(
                f"Permission {dto.name}:{dto.resource_type} already exists"
            )

        # Create permission entity
        permission = Permission(
            name=dto.name,
            description=dto.description,
            action=dto.action,
            resource_type=dto.resource_type,
            created_at=datetime.now(timezone.utc),
        )

        # Save permission
        saved_permission = self.permission_repository.save(permission)

        return self._build_permission_response(saved_permission)

    def get_permission_by_id(
        self, permission_id: UUID
    ) -> Optional[PermissionResponseDTO]:
        """Get permission by ID."""
        permission = self.permission_repository.find_by_id(permission_id)
        if not permission:
            return None

        return self._build_permission_response(permission)

    def list_permissions(
        self, page: int = 1, page_size: int = 20, include_system: bool = True
    ) -> PermissionListResponseDTO:
        """List permissions with pagination."""
        offset = (page - 1) * page_size

        permissions, total = self.permission_repository.find_paginated(
            include_system=include_system, offset=offset, limit=page_size
        )

        permission_responses = []
        for permission in permissions:
            permission_responses.append(self._build_permission_response(permission))

        total_pages = (total + page_size - 1) // page_size

        return PermissionListResponseDTO(
            permissions=permission_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def search_permissions(
        self, search_dto: PermissionSearchDTO, page: int = 1, page_size: int = 20
    ) -> PermissionListResponseDTO:
        """Search permissions with filters."""
        offset = (page - 1) * page_size

        permissions, total = self.permission_repository.search(
            query=search_dto.query,
            resource_type=search_dto.resource_type,
            action=search_dto.action,
            is_active=search_dto.is_active,
            offset=offset,
            limit=page_size,
        )

        permission_responses = []
        for permission in permissions:
            permission_responses.append(self._build_permission_response(permission))

        total_pages = (total + page_size - 1) // page_size

        return PermissionListResponseDTO(
            permissions=permission_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_permissions_by_resource_type(
        self, resource_type: str
    ) -> List[PermissionResponseDTO]:
        """Get all permissions for a specific resource type."""
        permissions = self.permission_repository.find_by_resource_type(resource_type)

        permission_responses = []
        for permission in permissions:
            permission_responses.append(self._build_permission_response(permission))

        return permission_responses

    def delete_permission(self, permission_id: UUID) -> bool:
        """Delete a permission (soft delete)."""
        permission = self.permission_repository.find_by_id(permission_id)
        if not permission:
            return False

        # Check if permission is system permission
        if permission.is_system_permission:
            raise ValueError("Cannot delete system permission")

        # Check if permission is assigned to any roles
        role_count = self.permission_repository.get_role_count(permission_id)
        if role_count > 0:
            raise ValueError("Cannot delete permission assigned to roles")

        permission.is_active = False
        permission.updated_at = datetime.now(timezone.utc)
        self.permission_repository.save(permission)

        return True

    def get_system_permissions(self) -> List[PermissionResponseDTO]:
        """Get all system permissions."""
        permissions = self.permission_repository.find_system_permissions()

        permission_responses = []
        for permission in permissions:
            permission_responses.append(self._build_permission_response(permission))

        return permission_responses

    def bulk_create_permissions(
        self, dtos: List[PermissionCreateDTO]
    ) -> List[PermissionResponseDTO]:
        """Create multiple permissions in bulk."""
        permissions = []

        for dto in dtos:
            # Check if permission already exists
            existing = self.permission_repository.find_by_name_and_resource(
                dto.name, dto.resource_type
            )
            if existing:
                continue  # Skip existing permissions

            # Create permission entity
            permission = Permission(
                name=dto.name,
                description=dto.description,
                action=dto.action,
                resource_type=dto.resource_type,
                created_at=datetime.now(timezone.utc),
            )
            permissions.append(permission)

        # Bulk save
        if permissions:
            saved_permissions = self.permission_repository.bulk_save(permissions)

            permission_responses = []
            for permission in saved_permissions:
                permission_responses.append(self._build_permission_response(permission))

            return permission_responses

        return []

    def _build_permission_response(
        self, permission: Permission
    ) -> PermissionResponseDTO:
        """Build permission response DTO."""
        role_count = self.permission_repository.get_role_count(permission.id)

        return PermissionResponseDTO(
            id=permission.id,
            name=permission.name,
            description=permission.description,
            action=permission.action,
            resource_type=permission.resource_type,
            full_name=permission.get_full_name(),
            created_at=permission.created_at,
            updated_at=permission.updated_at,
            is_active=permission.is_active,
            is_system_permission=permission.is_system_permission,
            role_count=role_count,
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict
from uuid import UUID

from ...domain.entities.policy import Policy
from ...domain.entities.authorization_context import AuthorizationContext
from ...domain.repositories.policy_repository import PolicyRepository
from ...domain.services.abac_service import AbacService
from ..dtos.policy_dto import (
    PolicyCreateDTO,
    PolicyUpdateDTO,
    PolicyResponseDTO,
    PolicyListResponseDTO,
    PolicyEvaluationRequestDTO,
    PolicyEvaluationResponseDTO,
)


class PolicyUseCase:
    """Use case for policy management operations."""

    def __init__(self, policy_repository: PolicyRepository, abac_service: AbacService):
        self.policy_repository = policy_repository
        self.abac_service = abac_service

    def create_policy(
        self, dto: PolicyCreateDTO, created_by: UUID
    ) -> PolicyResponseDTO:
        """Create a new policy."""
        # Create policy entity
        policy = Policy(
            name=dto.name,
            description=dto.description,
            effect=dto.effect,
            resource_type=dto.resource_type,
            action=dto.action,
            conditions=dto.conditions,
            organization_id=dto.organization_id,
            created_by=created_by,
            priority=dto.priority,
            created_at=datetime.now(timezone.utc),
        )

        # Save policy
        saved_policy = self.policy_repository.save(policy)

        return self._build_policy_response(saved_policy)

    def get_policy_by_id(self, policy_id: UUID) -> Optional[PolicyResponseDTO]:
        """Get policy by ID."""
        policy = self.policy_repository.find_by_id(policy_id)
        if not policy:
            return None

        return self._build_policy_response(policy)

    def update_policy(
        self, policy_id: UUID, dto: PolicyUpdateDTO
    ) -> Optional[PolicyResponseDTO]:
        """Update an existing policy."""
        policy = self.policy_repository.find_by_id(policy_id)
        if not policy:
            return None

        # Update fields
        if dto.description is not None:
            policy.description = dto.description
        if dto.effect is not None:
            policy.effect = dto.effect
        if dto.conditions is not None:
            policy.conditions = dto.conditions
        if dto.priority is not None:
            policy.priority = dto.priority

        policy.updated_at = datetime.now(timezone.utc)

        # Save policy
        updated_policy = self.policy_repository.save(policy)

        return self._build_policy_response(updated_policy)

    def delete_policy(self, policy_id: UUID) -> bool:
        """Delete a policy (soft delete)."""
        policy = self.policy_repository.find_by_id(policy_id)
        if not policy:
            return False

        policy.is_active = False
        policy.updated_at = datetime.now(timezone.utc)
        self.policy_repository.save(policy)

        return True

    def list_policies(
        self,
        organization_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
        action: Optional[str] = None,
        page: int = 1,
        page_size: int = 20,
    ) -> PolicyListResponseDTO:
        """List policies with pagination and filters."""
        offset = (page - 1) * page_size

        policies, total = self.policy_repository.find_paginated(
            organization_id=organization_id,
            resource_type=resource_type,
            action=action,
            offset=offset,
            limit=page_size,
        )

        policy_responses = [self._build_policy_response(policy) for policy in policies]

        total_pages = (total + page_size - 1) // page_size

        return PolicyListResponseDTO(
            policies=policy_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_policies_by_resource_and_action(
        self, resource_type: str, action: str, organization_id: Optional[UUID] = None
    ) -> List[PolicyResponseDTO]:
        """Get policies for specific resource type and action."""
        policies = self.policy_repository.find_by_resource_and_action(
            resource_type, action, organization_id
        )

        return [self._build_policy_response(policy) for policy in policies]

    def evaluate_policies(
        self, request_dto: PolicyEvaluationRequestDTO
    ) -> List[PolicyEvaluationResponseDTO]:
        """Evaluate policies for a specific request."""
        # Get applicable policies
        policies = self.policy_repository.find_by_resource_and_action(
            request_dto.resource_type, request_dto.action, request_dto.organization_id
        )

        # Create authorization context
        context = AuthorizationContext(
            user_id=request_dto.user_id,
            organization_id=request_dto.organization_id,
            resource_id=request_dto.resource_id,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            user_attributes=request_dto.user_attributes,
            resource_attributes=request_dto.resource_attributes,
            environment_attributes=request_dto.environment_attributes,
        )

        # Evaluate each policy
        evaluation_results = []

        for policy in policies:
            start_time = datetime.now(timezone.utc)

            # Evaluate policy conditions
            (
                conditions_met,
                condition_results,
            ) = self.abac_service.evaluate_policy_conditions(policy, context)

            # Determine result based on conditions
            result = None
            if conditions_met:
                result = policy.effect == "allow"

            end_time = datetime.now(timezone.utc)
            evaluation_time_ms = (end_time - start_time).total_seconds() * 1000

            evaluation_results.append(
                PolicyEvaluationResponseDTO(
                    policy_id=policy.id,
                    policy_name=policy.name,
                    result=result,
                    conditions_met=conditions_met,
                    condition_results=condition_results,
                    evaluation_time_ms=evaluation_time_ms,
                )
            )

        return evaluation_results

    def get_organization_policies(
        self, organization_id: UUID
    ) -> List[PolicyResponseDTO]:
        """Get all policies for an organization."""
        policies = self.policy_repository.find_by_organization(organization_id)
        return [self._build_policy_response(policy) for policy in policies]

    def get_global_policies(self) -> List[PolicyResponseDTO]:
        """Get all global policies."""
        policies = self.policy_repository.find_global_policies()
        return [self._build_policy_response(policy) for policy in policies]

    def duplicate_policy(
        self,
        policy_id: UUID,
        new_name: str,
        created_by: UUID,
        organization_id: Optional[UUID] = None,
    ) -> Optional[PolicyResponseDTO]:
        """Duplicate an existing policy with a new name."""
        original_policy = self.policy_repository.find_by_id(policy_id)
        if not original_policy:
            return None

        # Create new policy with same configuration but different name
        new_policy = Policy(
            name=new_name,
            description=f"Copy of {original_policy.description}",
            effect=original_policy.effect,
            resource_type=original_policy.resource_type,
            action=original_policy.action,
            conditions=original_policy.conditions.copy(),
            organization_id=organization_id or original_policy.organization_id,
            created_by=created_by,
            priority=original_policy.priority,
            created_at=datetime.now(timezone.utc),
        )

        saved_policy = self.policy_repository.save(new_policy)
        return self._build_policy_response(saved_policy)

    def bulk_update_priority(
        self, policy_priorities: Dict[UUID, int]
    ) -> List[PolicyResponseDTO]:
        """Update priorities for multiple policies."""
        updated_policies = []

        for policy_id, new_priority in policy_priorities.items():
            policy = self.policy_repository.find_by_id(policy_id)
            if policy:
                policy.priority = new_priority
                policy.updated_at = datetime.now(timezone.utc)
                updated_policy = self.policy_repository.save(policy)
                updated_policies.append(updated_policy)

        return [self._build_policy_response(policy) for policy in updated_policies]

    def _build_policy_response(self, policy: Policy) -> PolicyResponseDTO:
        """Build policy response DTO."""
        return PolicyResponseDTO(
            id=policy.id,
            name=policy.name,
            description=policy.description,
            effect=policy.effect,
            resource_type=policy.resource_type,
            action=policy.action,
            conditions=[condition.model_dump() for condition in policy.conditions],
            organization_id=policy.organization_id,
            created_by=policy.created_by,
            created_at=policy.created_at,
            updated_at=policy.updated_at,
            is_active=policy.is_active,
            priority=policy.priority,
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID

from ...domain.entities.authorization_context import AuthorizationContext
from ...domain.services.authorization_service import AuthorizationService
from ...domain.repositories.role_repository import RoleRepository
from ...domain.repositories.policy_repository import PolicyRepository
from ..dtos.authorization_dto import (
    AuthorizationRequestDTO,
    AuthorizationResponseDTO,
    BulkAuthorizationRequestDTO,
    BulkAuthorizationResponseDTO,
    UserPermissionsResponseDTO,
    RoleAssignmentDTO,
)


class AuthorizationUseCase:
    """Use case for authorization operations."""

    def __init__(
        self,
        authorization_service: AuthorizationService,
        role_repository: RoleRepository,
        policy_repository: PolicyRepository,
    ):
        self.authorization_service = authorization_service
        self.role_repository = role_repository
        self.policy_repository = policy_repository

    def check_authorization(
        self, request_dto: AuthorizationRequestDTO
    ) -> AuthorizationResponseDTO:
        """Check if a user is authorized to perform an action."""
        start_time = datetime.now(timezone.utc)

        # Create authorization context
        context = AuthorizationContext(
            user_id=request_dto.user_id,
            organization_id=request_dto.organization_id,
            resource_id=request_dto.resource_id,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            user_attributes=request_dto.user_attributes,
            resource_attributes=request_dto.resource_attributes,
            environment_attributes=request_dto.environment_attributes,
        )

        # Perform authorization check
        is_authorized, decision_info = self.authorization_service.is_authorized(context)

        end_time = datetime.now(timezone.utc)
        evaluation_time_ms = (end_time - start_time).total_seconds() * 1000

        return AuthorizationResponseDTO(
            user_id=request_dto.user_id,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            is_authorized=is_authorized,
            decision_reason=decision_info.get("reason", ""),
            rbac_result=decision_info.get("rbac_result"),
            abac_result=decision_info.get("abac_result"),
            applicable_roles=decision_info.get("roles", []),
            applicable_policies=decision_info.get("policies", []),
            evaluation_time_ms=evaluation_time_ms,
            evaluated_at=end_time,
        )

    def bulk_check_authorization(
        self, request_dto: BulkAuthorizationRequestDTO
    ) -> BulkAuthorizationResponseDTO:
        """Check authorization for multiple requests."""
        results = []

        for request in request_dto.requests:
            result = self.check_authorization(request)
            results.append(result)

        # Calculate summary statistics
        authorized_count = sum(1 for r in results if r.is_authorized)
        total_evaluation_time = sum(r.evaluation_time_ms for r in results)

        return BulkAuthorizationResponseDTO(
            results=results,
            total_requests=len(results),
            authorized_count=authorized_count,
            denied_count=len(results) - authorized_count,
            total_evaluation_time_ms=total_evaluation_time,
        )

    def get_user_permissions(
        self,
        user_id: UUID,
        organization_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
    ) -> UserPermissionsResponseDTO:
        """Get all permissions for a user."""
        # Get user roles
        user_roles = self.role_repository.find_user_roles(user_id, organization_id)

        # Get permissions from roles
        all_permissions = []
        role_names = []

        for role in user_roles:
            role_names.append(role.name)
            role_permissions = self.role_repository.get_role_permissions(role.id)

            for permission in role_permissions:
                if resource_type is None or permission.resource_type == resource_type:
                    all_permissions.append(
                        {
                            "id": str(permission.id),
                            "name": permission.name,
                            "resource_type": permission.resource_type,
                            "permission_type": permission.permission_type,
                            "full_name": permission.full_name,
                            "source_role": role.name,
                        }
                    )

        # Remove duplicates while preserving source role info
        unique_permissions = {}
        for perm in all_permissions:
            key = f"{perm['resource_type']}:{perm['permission_type']}"
            if key not in unique_permissions:
                unique_permissions[key] = perm
            else:
                # Merge source roles
                existing_roles = unique_permissions[key].get(
                    "source_roles", [unique_permissions[key]["source_role"]]
                )
                if perm["source_role"] not in existing_roles:
                    existing_roles.append(perm["source_role"])
                unique_permissions[key]["source_roles"] = existing_roles
                del unique_permissions[key]["source_role"]

        return UserPermissionsResponseDTO(
            user_id=user_id,
            organization_id=organization_id,
            resource_type=resource_type,
            roles=role_names,
            permissions=list(unique_permissions.values()),
            permission_count=len(unique_permissions),
        )

    def assign_role_to_user(self, assignment_dto: RoleAssignmentDTO) -> bool:
        """Assign a role to a user."""
        # Validate role exists
        role = self.role_repository.find_by_id(assignment_dto.role_id)
        if not role:
            raise ValueError("Role not found")

        # Check organization scope
        if (
            role.organization_id
            and role.organization_id != assignment_dto.organization_id
        ):
            raise ValueError("Role does not belong to the specified organization")

        # Assign role
        self.role_repository.assign_role_to_user(
            user_id=assignment_dto.user_id,
            role_id=assignment_dto.role_id,
            organization_id=assignment_dto.organization_id,
            assigned_by=assignment_dto.assigned_by,
            expires_at=assignment_dto.expires_at,
        )

        return True

    def remove_role_from_user(
        self, user_id: UUID, role_id: UUID, organization_id: Optional[UUID] = None
    ) -> bool:
        """Remove a role from a user."""
        return self.role_repository.remove_role_from_user(
            user_id=user_id, role_id=role_id, organization_id=organization_id
        )

    def get_user_roles(
        self, user_id: UUID, organization_id: Optional[UUID] = None
    ) -> List[Dict[str, Any]]:
        """Get all roles assigned to a user."""
        roles = self.role_repository.find_user_roles(user_id, organization_id)

        return [
            {
                "id": str(role.id),
                "name": role.name,
                "description": role.description,
                "organization_id": str(role.organization_id)
                if role.organization_id
                else None,
                "is_system_role": role.is_system_role,
                "created_at": role.created_at.isoformat(),
            }
            for role in roles
        ]

    def check_user_has_permission(
        self,
        user_id: UUID,
        permission_name: str,
        resource_type: str,
        organization_id: Optional[UUID] = None,
    ) -> bool:
        """Check if a user has a specific permission."""
        context = AuthorizationContext(
            user_id=user_id,
            organization_id=organization_id,
            resource_type=resource_type,
            action=permission_name,
        )

        is_authorized, _ = self.authorization_service.authorize(context)
        return is_authorized

    def get_resource_policies(
        self,
        resource_type: str,
        action: Optional[str] = None,
        organization_id: Optional[UUID] = None,
    ) -> List[Dict[str, Any]]:
        """Get all policies applicable to a resource type."""
        if action:
            policies = self.policy_repository.find_by_resource_and_action(
                resource_type, action, organization_id
            )
        else:
            policies = self.policy_repository.find_by_resource_type(
                resource_type, organization_id
            )

        return [
            {
                "id": str(policy.id),
                "name": policy.name,
                "description": policy.description,
                "effect": policy.effect,
                "resource_type": policy.resource_type,
                "action": policy.action,
                "conditions": [
                    condition.model_dump() for condition in policy.conditions
                ],
                "priority": policy.priority,
                "is_active": policy.is_active,
            }
            for policy in policies
        ]
from .authorization_use_cases import AuthorizationUseCase
from .role_use_cases import RoleUseCase
from .permission_use_cases import PermissionUseCase
from .policy_use_cases import PolicyUseCase

__all__ = [
    "AuthorizationUseCase",
    "RoleUseCase", 
    "PermissionUseCase",
    "PolicyUseCase"
]
from sqlalchemy import (
    Column,
    DateTime,
    String,
    Boolean,
    ForeignKey,
    Text,
    Enum,
    Integer,
    Table,
    UniqueConstraint,
    Index,
)
from sqlalchemy.dialects.postgresql import UUID, JSON
from sqlalchemy.sql import func
import enum

from shared.infrastructure.database.base import BaseModel, Base


class PermissionActionEnum(str, enum.Enum):
    CREATE = "create"
    READ = "read"
    UPDATE = "update"
    DELETE = "delete"
    EXECUTE = "execute"
    MANAGE = "manage"


class PolicyEffectEnum(str, enum.Enum):
    ALLOW = "allow"
    DENY = "deny"


# Association table for role-permission many-to-many relationship
role_permission_association = Table(
    "role_permissions",
    Base.metadata,
    Column(
        "role_id",
        UUID(as_uuid=True),
        ForeignKey("authorization_roles.id"),
        primary_key=True,
    ),
    Column(
        "permission_id",
        UUID(as_uuid=True),
        ForeignKey("authorization_permissions.id"),
        primary_key=True,
    ),
    Column(
        "assigned_at",
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    ),
)


# Association table for user-role assignments
user_role_assignment = Table(
    "user_role_assignments",
    Base.metadata,
    Column("user_id", UUID(as_uuid=True), ForeignKey("users.id"), primary_key=True),
    Column(
        "role_id",
        UUID(as_uuid=True),
        ForeignKey("authorization_roles.id"),
        primary_key=True,
    ),
    Column(
        "organization_id",
        UUID(as_uuid=True),
        ForeignKey("organizations.id"),
        nullable=True,
    ),
    Column("assigned_by", UUID(as_uuid=True), ForeignKey("users.id"), nullable=False),
    Column(
        "assigned_at",
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    ),
    Column("expires_at", DateTime(timezone=True), nullable=True),
    Column("is_active", Boolean, default=True, nullable=False),
)


class RoleModel(BaseModel):
    """SQLAlchemy model for Role entity."""

    __tablename__ = "authorization_roles"

    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=False)
    organization_id = Column(
        UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=True, index=True
    )
    parent_role_id = Column(
        UUID(as_uuid=True),
        ForeignKey("authorization_roles.id"),
        nullable=True,
        index=True,
    )
    created_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    is_system_role = Column(Boolean, default=False, nullable=False)

    # Ensure unique role names within organization scope (null for global roles)
    __table_args__ = (UniqueConstraint("name", "organization_id"),)


class PermissionModel(BaseModel):
    """SQLAlchemy model for Permission entity."""

    __tablename__ = "authorization_permissions"

    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=False)
    action = Column(Enum(PermissionActionEnum), nullable=False, index=True)
    resource_type = Column(String(50), nullable=False, index=True)
    is_active = Column(Boolean, default=True, nullable=False)
    is_system_permission = Column(Boolean, default=False, nullable=False)

    # Ensure unique permission names within resource type
    __table_args__ = (UniqueConstraint("name", "resource_type"),)


class PolicyModel(BaseModel):
    """SQLAlchemy model for Policy entity."""

    __tablename__ = "authorization_policies"

    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=False)
    effect = Column(Enum(PolicyEffectEnum), nullable=False, index=True)
    resource_type = Column(String(50), nullable=False, index=True)
    action = Column(String(50), nullable=False, index=True)
    conditions = Column(JSON, nullable=False, default=[])  # List of policy conditions
    organization_id = Column(
        UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=True, index=True
    )
    created_by = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    priority = Column(Integer, default=0, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)

    # Index for efficient policy lookup
    __table_args__ = (
        Index("ix_policy_lookup", "resource_type", "action", "organization_id"),
    )


class ResourceModel(BaseModel):
    """SQLAlchemy model for Resource entity."""

    __tablename__ = "authorization_resources"

    resource_type = Column(String(50), nullable=False, index=True)
    resource_id = Column(UUID(as_uuid=True), nullable=False, index=True)
    owner_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    organization_id = Column(
        UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=True, index=True
    )
    attributes = Column(JSON, nullable=False, default={})
    is_active = Column(Boolean, default=True, nullable=False)

    # Unique constraint for resource type and resource ID combination
    __table_args__ = (UniqueConstraint("resource_type", "resource_id"),)
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, delete, and_
from sqlalchemy.exc import IntegrityError

from ...domain.entities.policy import Policy, PolicyCondition
from ...domain.repositories.policy_repository import PolicyRepository
from ...infrastructure.database.models import (
    PolicyModel,
    PolicyEffectEnum,
)


class SqlAlchemyPolicyRepository(PolicyRepository):
    """SQLAlchemy implementation of PolicyRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, policy: Policy) -> Policy:
        """Save a policy entity."""
        try:
            # Check if policy exists
            existing = self.session.get(PolicyModel, policy.id)

            if existing:
                # Update existing policy
                existing.name = policy.name
                existing.description = policy.description
                existing.effect = PolicyEffectEnum(policy.effect)
                existing.resource_type = policy.resource_type
                existing.action = policy.action
                existing.conditions = [
                    condition.to_dict() for condition in policy.conditions
                ]
                existing.organization_id = policy.organization_id
                existing.created_by = policy.created_by
                existing.priority = policy.priority
                existing.is_active = policy.is_active
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new policy
                policy_model = PolicyModel(
                    id=policy.id,
                    name=policy.name,
                    description=policy.description,
                    effect=PolicyEffectEnum(policy.effect),
                    resource_type=policy.resource_type,
                    action=policy.action,
                    conditions=[condition.model_dump() for condition in policy.conditions],
                    organization_id=policy.organization_id,
                    created_by=policy.created_by,
                    priority=policy.priority,
                    is_active=policy.is_active,
                    created_at=policy.created_at,
                    updated_at=policy.updated_at,
                )

                self.session.add(policy_model)
                self.session.flush()
                return self._to_domain_entity(policy_model)

        except IntegrityError as e:
            self.session.rollback()
            raise e

    def find_by_id(self, policy_id: UUID) -> Optional[Policy]:
        """Find a policy by ID."""
        result = self.session.execute(
            select(PolicyModel).where(PolicyModel.id == policy_id)
        )
        policy_model = result.scalar_one_or_none()

        if policy_model:
            return self._to_domain_entity(policy_model)
        return None

    def find_by_name(
        self, name: str, organization_id: Optional[UUID] = None
    ) -> Optional[Policy]:
        """Find a policy by name within organization scope."""
        result = self.session.execute(
            select(PolicyModel).where(
                and_(
                    PolicyModel.name == name,
                    PolicyModel.organization_id == organization_id,
                )
            )
        )
        policy_model = result.scalar_one_or_none()

        if policy_model:
            return self._to_domain_entity(policy_model)
        return None

    def find_by_resource_and_action(
        self, resource_type: str, action: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Find policies for specific resource type and action."""
        query_conditions = [
            PolicyModel.resource_type == resource_type,
            PolicyModel.action == action,
            PolicyModel.is_active,
        ]

        # Include both organization-specific and global policies
        if organization_id:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            query_conditions.append(org_condition)
        else:
            query_conditions.append(PolicyModel.organization_id.is_(None))

        result = self.session.execute(
            select(PolicyModel)
            .where(and_(*query_conditions))
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_by_resource_type(
        self, resource_type: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Find policies for a specific resource type."""
        query_conditions = [
            PolicyModel.resource_type == resource_type,
            PolicyModel.is_active,
        ]

        if organization_id:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            query_conditions.append(org_condition)
        else:
            query_conditions.append(PolicyModel.organization_id.is_(None))

        result = self.session.execute(
            select(PolicyModel)
            .where(and_(*query_conditions))
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_by_organization(self, organization_id: UUID) -> List[Policy]:
        """Find policies for an organization."""
        result = self.session.execute(
            select(PolicyModel)
            .where(
                and_(
                    PolicyModel.organization_id == organization_id,
                    PolicyModel.is_active,
                )
            )
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_global_policies(self) -> List[Policy]:
        """Find all global policies."""
        result = self.session.execute(
            select(PolicyModel)
            .where(and_(PolicyModel.organization_id.is_(None), PolicyModel.is_active))
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_by_effect(
        self, effect: str, organization_id: Optional[UUID] = None
    ) -> List[Policy]:
        """Find policies by effect (allow/deny)."""
        query_conditions = [
            PolicyModel.effect == PolicyEffectEnum(effect),
            PolicyModel.is_active,
        ]

        if organization_id:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            query_conditions.append(org_condition)

        result = self.session.execute(
            select(PolicyModel)
            .where(and_(*query_conditions))
            .order_by(PolicyModel.priority.desc())
        )
        policy_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in policy_models]

    def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
        action: Optional[str] = None,
        effect: Optional[str] = None,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Policy], int]:
        """Find policies with pagination and filters."""
        query = select(PolicyModel)
        count_query = select(PolicyModel)

        # Apply filters
        if organization_id is not None:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            query = query.where(org_condition)
            count_query = count_query.where(org_condition)

        if resource_type:
            query = query.where(PolicyModel.resource_type == resource_type)
            count_query = count_query.where(PolicyModel.resource_type == resource_type)

        if action:
            query = query.where(PolicyModel.action == action)
            count_query = count_query.where(PolicyModel.action == action)

        if effect:
            query = query.where(PolicyModel.effect == PolicyEffectEnum(effect))
            count_query = count_query.where(
                PolicyModel.effect == PolicyEffectEnum(effect)
            )

        if is_active is not None:
            query = query.where(PolicyModel.is_active == is_active)
            count_query = count_query.where(PolicyModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(PolicyModel.priority.desc(), PolicyModel.created_at.desc())
        )
        result = self.session.execute(query)
        policy_models = result.scalars().all()

        policies = [self._to_domain_entity(model) for model in policy_models]
        return policies, total

    def delete(self, policy_id: UUID) -> bool:
        """Delete a policy (hard delete)."""
        result = self.session.execute(
            delete(PolicyModel).where(PolicyModel.id == policy_id)
        )
        return result.rowcount > 0

    def search(
        self,
        query: Optional[str] = None,
        organization_id: Optional[UUID] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Policy], int]:
        """Search policies with text query."""
        db_query = select(PolicyModel)
        count_query = select(PolicyModel)

        # Apply text search
        if query:
            search_filter = (
                PolicyModel.name.ilike(f"%{query}%")
                | PolicyModel.description.ilike(f"%{query}%")
                | PolicyModel.resource_type.ilike(f"%{query}%")
                | PolicyModel.action.ilike(f"%{query}%")
            )
            db_query = db_query.where(search_filter)
            count_query = count_query.where(search_filter)

        # Apply organization filter
        if organization_id is not None:
            org_condition = (PolicyModel.organization_id == organization_id) | (
                PolicyModel.organization_id.is_(None)
            )
            db_query = db_query.where(org_condition)
            count_query = count_query.where(org_condition)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        db_query = (
            db_query.offset(offset)
            .limit(limit)
            .order_by(PolicyModel.priority.desc(), PolicyModel.created_at.desc())
        )
        result = self.session.execute(db_query)
        policy_models = result.scalars().all()

        policies = [self._to_domain_entity(model) for model in policy_models]
        return policies, total

    def get_resource_types(self) -> List[str]:
        """Get all unique resource types."""
        result = self.session.execute(select(PolicyModel.resource_type).distinct())
        return [row[0] for row in result.fetchall()]

    def get_actions(self) -> List[str]:
        """Get all unique actions."""
        result = self.session.execute(select(PolicyModel.action).distinct())
        return [row[0] for row in result.fetchall()]

    def count_policies_by_organization(self, organization_id: UUID) -> int:
        """Count policies for an organization."""
        result = self.session.execute(
            select(PolicyModel).where(
                and_(
                    PolicyModel.organization_id == organization_id,
                    PolicyModel.is_active,
                )
            )
        )
        return len(result.scalars().all())

    def _to_domain_entity(self, policy_model: PolicyModel) -> Policy:
        """Convert SQLAlchemy model to domain entity."""
        conditions = [
            PolicyCondition.from_dict(condition_dict)
            for condition_dict in policy_model.conditions
        ]

        return Policy(
            id=policy_model.id,
            name=policy_model.name,
            description=policy_model.description,
            effect=policy_model.effect.value,
            resource_type=policy_model.resource_type,
            action=policy_model.action,
            conditions=conditions,
            organization_id=policy_model.organization_id,
            created_by=policy_model.created_by,
            priority=policy_model.priority,
            is_active=policy_model.is_active,
            created_at=policy_model.created_at,
            updated_at=policy_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy import select, delete, and_
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from ...domain.entities.resource import Resource
from ...domain.repositories.resource_repository import ResourceRepository
from ...infrastructure.database.models import ResourceModel


class SqlAlchemyResourceRepository(ResourceRepository):
    """SQLAlchemy implementation of ResourceRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, resource: Resource) -> Resource:
        """Save or update a resource."""
        try:
            # Check if resource exists
            existing = self.session.get(ResourceModel, resource.id)

            if existing:
                # Update existing resource
                existing.resource_type = resource.resource_type
                existing.resource_id = resource.resource_id
                existing.owner_id = resource.owner_id
                existing.organization_id = resource.organization_id
                existing.attributes = resource.attributes
                existing.is_active = resource.is_active
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new resource
                resource_model = ResourceModel(
                    id=resource.id,
                    resource_type=resource.resource_type,
                    resource_id=resource.resource_id,
                    owner_id=resource.owner_id,
                    organization_id=resource.organization_id,
                    attributes=resource.attributes,
                    is_active=resource.is_active,
                    created_at=resource.created_at,
                    updated_at=resource.updated_at,
                )

                self.session.add(resource_model)
                self.session.flush()
                return self._to_domain_entity(resource_model)

        except IntegrityError as e:
            self.session.rollback()
            if "resource_type" in str(e) and "resource_id" in str(e):
                raise ValueError(
                    f"Resource '{resource.resource_type}:{resource.resource_id}' already exists"
                )
            raise e

    def get_by_id(self, resource_id: UUID) -> Optional[Resource]:
        """Get resource by ID."""
        result = self.session.execute(
            select(ResourceModel).where(ResourceModel.id == resource_id)
        )
        resource_model = result.scalar_one_or_none()

        if resource_model:
            return self._to_domain_entity(resource_model)
        return None

    def get_by_resource_id(
        self, resource_type: str, resource_id: UUID
    ) -> Optional[Resource]:
        """Get resource by type and actual resource ID."""
        result = self.session.execute(
            select(ResourceModel).where(
                and_(
                    ResourceModel.resource_type == resource_type,
                    ResourceModel.resource_id == resource_id,
                    ResourceModel.is_active == True,
                )
            )
        )
        resource_model = result.scalar_one_or_none()

        if resource_model:
            return self._to_domain_entity(resource_model)
        return None

    def get_by_owner_id(self, owner_id: UUID) -> List[Resource]:
        """Get all resources owned by a user."""
        result = self.session.execute(
            select(ResourceModel).where(
                and_(
                    ResourceModel.owner_id == owner_id,
                    ResourceModel.is_active == True,
                )
            ).order_by(ResourceModel.created_at.desc())
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def get_by_organization_id(self, organization_id: UUID) -> List[Resource]:
        """Get all resources belonging to an organization."""
        result = self.session.execute(
            select(ResourceModel).where(
                and_(
                    ResourceModel.organization_id == organization_id,
                    ResourceModel.is_active == True,
                )
            ).order_by(ResourceModel.created_at.desc())
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def get_by_type(self, resource_type: str) -> List[Resource]:
        """Get all resources of a specific type."""
        result = self.session.execute(
            select(ResourceModel).where(
                and_(
                    ResourceModel.resource_type == resource_type,
                    ResourceModel.is_active == True,
                )
            ).order_by(ResourceModel.created_at.desc())
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def find_by_attributes(
        self, resource_type: str, attributes: Dict[str, Any]
    ) -> List[Resource]:
        """Find resources by attributes."""
        query = select(ResourceModel).where(
            and_(
                ResourceModel.resource_type == resource_type,
                ResourceModel.is_active == True,
            )
        )

        # Filter by attributes using JSON contains operations
        for key, value in attributes.items():
            # Use PostgreSQL JSON contains operator
            query = query.where(ResourceModel.attributes[key].astext == str(value))

        result = self.session.execute(query.order_by(ResourceModel.created_at.desc()))
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def delete(self, resource_id: UUID) -> bool:
        """Delete resource by ID."""
        result = self.session.execute(
            delete(ResourceModel).where(ResourceModel.id == resource_id)
        )
        return result.rowcount > 0

    def delete_by_resource_id(self, resource_type: str, resource_id: UUID) -> bool:
        """Delete resource by type and actual resource ID."""
        result = self.session.execute(
            delete(ResourceModel).where(
                and_(
                    ResourceModel.resource_type == resource_type,
                    ResourceModel.resource_id == resource_id,
                )
            )
        )
        return result.rowcount > 0

    def list_active_resources(
        self, resource_type: Optional[str] = None, limit: int = 100, offset: int = 0
    ) -> List[Resource]:
        """List active resources with pagination."""
        query = select(ResourceModel).where(ResourceModel.is_active == True)

        if resource_type:
            query = query.where(ResourceModel.resource_type == resource_type)

        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(ResourceModel.created_at.desc())
        )

        result = self.session.execute(query)
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def count_user_resources(
        self, user_id: UUID, resource_type: Optional[str] = None
    ) -> int:
        """Count resources owned by a user."""
        query = select(ResourceModel).where(
            and_(
                ResourceModel.owner_id == user_id,
                ResourceModel.is_active == True,
            )
        )

        if resource_type:
            query = query.where(ResourceModel.resource_type == resource_type)

        result = self.session.execute(query)
        return len(result.scalars().all())

    def transfer_ownership(
        self, resource_type: str, resource_id: UUID, new_owner_id: UUID
    ) -> bool:
        """Transfer resource ownership."""
        resource_model = self.session.execute(
            select(ResourceModel).where(
                and_(
                    ResourceModel.resource_type == resource_type,
                    ResourceModel.resource_id == resource_id,
                    ResourceModel.is_active == True,
                )
            )
        ).scalar_one_or_none()

        if resource_model:
            resource_model.owner_id = new_owner_id
            resource_model.updated_at = datetime.now(timezone.utc)
            self.session.flush()
            return True

        return False

    def _to_domain_entity(self, resource_model: ResourceModel) -> Resource:
        """Convert SQLAlchemy model to domain entity."""
        return Resource(
            id=resource_model.id,
            resource_type=resource_model.resource_type,
            resource_id=resource_model.resource_id,
            owner_id=resource_model.owner_id,
            organization_id=resource_model.organization_id,
            attributes=resource_model.attributes,
            created_at=resource_model.created_at,
            updated_at=resource_model.updated_at,
            is_active=resource_model.is_active,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, delete, and_, text
from sqlalchemy.exc import IntegrityError

from ...domain.entities.role import Role
from ...domain.entities.permission import Permission
from ...domain.repositories.role_repository import RoleRepository
from ...infrastructure.database.models import (
    RoleModel,
    PermissionModel,
    role_permission_association,
    user_role_assignment,
)


class SqlAlchemyRoleRepository(RoleRepository):
    """SQLAlchemy implementation of RoleRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, role: Role) -> Role:
        """Save a role entity."""
        # Check if role exists
        existing = self.session.get(RoleModel, role.id)

        if existing:
            # Update existing role
            existing.name = role.name
            existing.description = role.description
            existing.organization_id = role.organization_id
            existing.parent_role_id = role.parent_role_id
            existing.created_by = role.created_by
            existing.is_active = role.is_active
            existing.is_system_role = role.is_system_role
            existing.updated_at = datetime.now(timezone.utc)

            self.session.flush()
            return self._to_domain_entity(existing)
        else:
            # Create new role
            role_model = RoleModel(
                id=role.id,
                name=role.name,
                description=role.description,
                organization_id=role.organization_id,
                parent_role_id=role.parent_role_id,
                created_by=role.created_by,
                is_active=role.is_active,
                is_system_role=role.is_system_role,
                created_at=role.created_at,
                updated_at=role.updated_at,
            )

            self.session.add(role_model)
            self.session.flush()
            return self._to_domain_entity(role_model)

    def get_by_id(self, role_id: UUID) -> Optional[Role]:
        """Get role by ID."""
        result = self.session.execute(select(RoleModel).where(RoleModel.id == role_id))
        role_model = result.scalar_one_or_none()

        if role_model:
            return self._to_domain_entity(role_model)
        return None

    def get_by_name(
        self, name, organization_id: Optional[UUID] = None
    ) -> Optional[Role]:
        """Get role by name within organization scope."""
        result = self.session.execute(
            select(RoleModel).where(
                and_(
                    RoleModel.name == name.value,
                    RoleModel.organization_id == organization_id,
                )
            )
        )
        role_model = result.scalar_one_or_none()

        if role_model:
            return self._to_domain_entity(role_model)
        return None

    def get_organization_roles(self, organization_id: UUID) -> List[Role]:
        """Get all roles for an organization."""
        result = self.session.execute(
            select(RoleModel).where(
                and_(
                    RoleModel.organization_id == organization_id,
                    RoleModel.is_active,
                )
            )
        )
        role_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in role_models]

    def get_system_roles(self) -> List[Role]:
        """Get all system roles."""
        result = self.session.execute(
            select(RoleModel).where(and_(RoleModel.is_system_role, RoleModel.is_active))
        )
        role_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in role_models]

    def get_user_roles(
        self, user_id: UUID, organization_id: Optional[UUID] = None
    ) -> List[Role]:
        """Get roles assigned to a user."""
        query = (
            select(RoleModel)
            .select_from(RoleModel.join(user_role_assignment))
            .where(
                and_(
                    user_role_assignment.c.user_id == user_id,
                    user_role_assignment.c.is_active,
                    RoleModel.is_active,
                )
            )
        )

        if organization_id:
            query = query.where(
                user_role_assignment.c.organization_id == organization_id
            )

        result = self.session.execute(query)
        role_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in role_models]

    def exists_by_name(self, name, organization_id: Optional[UUID] = None) -> bool:
        """Check if role exists by name within organization scope."""
        result = self.session.execute(
            select(RoleModel.id)
            .where(
                and_(
                    RoleModel.name == name.value,
                    RoleModel.organization_id == organization_id,
                )
            )
            .limit(1)
        )
        return result.first() is not None

    def list_active_roles(
        self, organization_id: Optional[UUID] = None, limit: int = 100, offset: int = 0
    ) -> List[Role]:
        """List active roles with pagination."""
        query = select(RoleModel).where(RoleModel.is_active)

        if organization_id is not None:
            query = query.where(RoleModel.organization_id == organization_id)

        query = query.offset(offset).limit(limit).order_by(RoleModel.name.asc())
        result = self.session.execute(query)
        role_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in role_models]

    def count_role_assignments(self, role_id: UUID) -> int:
        """Count how many users have this role assigned."""
        return self.get_assignment_count(role_id)

    def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        include_system: bool = True,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Role], int]:
        """Find roles with pagination and filters."""
        query = select(RoleModel)
        count_query = select(RoleModel)

        # Apply filters
        if organization_id is not None:
            query = query.where(RoleModel.organization_id == organization_id)
            count_query = count_query.where(
                RoleModel.organization_id == organization_id
            )

        if not include_system:
            query = query.where(not RoleModel.is_system_role)
            count_query = count_query.where(not RoleModel.is_system_role)

        if is_active is not None:
            query = query.where(RoleModel.is_active == is_active)
            count_query = count_query.where(RoleModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(RoleModel.created_at.desc())
        result = self.session.execute(query)
        role_models = result.scalars().all()

        roles = [self._to_domain_entity(model) for model in role_models]
        return roles, total

    def delete(self, role_id: UUID) -> bool:
        """Delete a role (hard delete)."""
        result = self.session.execute(delete(RoleModel).where(RoleModel.id == role_id))
        return result.rowcount > 0

    def assign_permissions(self, role_id: UUID, permission_ids: List[UUID]) -> bool:
        """Assign permissions to a role."""
        # Remove existing permissions first
        self.session.execute(
            text("DELETE FROM role_permissions WHERE role_id = :role_id").bindparam(
                role_id=role_id
            )
        )

        # Add new permissions
        for permission_id in permission_ids:
            self.session.execute(
                text(
                    "INSERT INTO role_permissions (role_id, permission_id) VALUES (:role_id, :permission_id)"
                ).bindparam(role_id=role_id, permission_id=permission_id)
            )

        return True

    def remove_permissions(self, role_id: UUID, permission_ids: List[UUID]) -> bool:
        """Remove specific permissions from a role."""
        for permission_id in permission_ids:
            self.session.execute(
                text(
                    "DELETE FROM role_permissions WHERE role_id = :role_id AND permission_id = :permission_id"
                ).bindparam(role_id=role_id, permission_id=permission_id)
            )

        return True

    def replace_permissions(self, role_id: UUID, permission_ids: List[UUID]) -> bool:
        """Replace all role permissions with new ones."""
        return self.assign_permissions(role_id, permission_ids)

    def get_role_permissions(self, role_id: UUID) -> List[Permission]:
        """Get all permissions for a role."""
        result = self.session.execute(
            select(PermissionModel)
            .select_from(PermissionModel.join(role_permission_association))
            .where(role_permission_association.c.role_id == role_id)
        )
        permission_models = result.scalars().all()

        return [self._permission_to_domain_entity(model) for model in permission_models]

    def assign_role_to_user(
        self,
        user_id: UUID,
        role_id: UUID,
        organization_id: Optional[UUID],
        assigned_by: UUID,
        expires_at: Optional[datetime] = None,
    ) -> bool:
        """Assign a role to a user."""
        self.session.execute(
            text("""
                INSERT INTO user_role_assignments 
                (user_id, role_id, organization_id, assigned_by, expires_at) 
                VALUES (:user_id, :role_id, :organization_id, :assigned_by, :expires_at)
            """).bindparam(
                user_id=user_id,
                role_id=role_id,
                organization_id=organization_id,
                assigned_by=assigned_by,
                expires_at=expires_at,
            )
        )
        return True

    def remove_role_from_user(
        self, user_id: UUID, role_id: UUID, organization_id: Optional[UUID] = None
    ) -> bool:
        """Remove a role from a user."""
        query = """
            UPDATE user_role_assignments 
            SET is_active = false 
            WHERE user_id = :user_id AND role_id = :role_id
        """
        params = {"user_id": user_id, "role_id": role_id}

        if organization_id:
            query += " AND organization_id = :organization_id"
            params["organization_id"] = organization_id

        result = self.session.execute(text(query).bindparam(**params))
        return result.rowcount > 0

    def get_permission_count(self, role_id: UUID) -> int:
        """Get the number of permissions assigned to a role."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM role_permissions WHERE role_id = :role_id"
            ).bindparam(role_id=role_id)
        )
        return result.scalar() or 0

    def get_assignment_count(self, role_id: UUID) -> int:
        """Get the number of users assigned to a role."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM user_role_assignments WHERE role_id = :role_id AND is_active = true"
            ).bindparam(role_id=role_id)
        )
        return result.scalar() or 0

    def get_child_roles(self, parent_role_id: UUID) -> List[Role]:
        """Get all direct child roles of a parent role."""
        result = self.session.execute(
            select(RoleModel).where(
                and_(RoleModel.parent_role_id == parent_role_id, RoleModel.is_active)
            )
        )
        role_models = result.scalars().all()
        return [self._to_domain_entity(model) for model in role_models]

    def get_roles_by_parent(self, parent_role_id: Optional[UUID]) -> List[Role]:
        """Get all roles with the specified parent (None for root roles)."""
        if parent_role_id is None:
            # Get root roles (roles with no parent)
            result = self.session.execute(
                select(RoleModel).where(
                    and_(RoleModel.parent_role_id.is_(None), RoleModel.is_active)
                )
            )
        else:
            # Get roles with specific parent
            result = self.session.execute(
                select(RoleModel).where(
                    and_(
                        RoleModel.parent_role_id == parent_role_id, RoleModel.is_active
                    )
                )
            )

        role_models = result.scalars().all()
        return [self._to_domain_entity(model) for model in role_models]

    def get_role_hierarchy(self, organization_id: Optional[UUID] = None) -> List[Role]:
        """Get all roles in hierarchical order for an organization."""
        query = select(RoleModel).where(RoleModel.is_active)

        if organization_id is not None:
            query = query.where(RoleModel.organization_id == organization_id)

        # Order by parent_role_id nulls first (root roles first), then by name
        query = query.order_by(
            RoleModel.parent_role_id.asc().nulls_first(), RoleModel.name.asc()
        )

        result = self.session.execute(query)
        role_models = result.scalars().all()
        return [self._to_domain_entity(model) for model in role_models]

    def has_child_roles(self, role_id: UUID) -> bool:
        """Check if role has any child roles."""
        result = self.session.execute(
            select(RoleModel.id)
            .where(and_(RoleModel.parent_role_id == role_id, RoleModel.is_active))
            .limit(1)
        )
        return result.first() is not None

    def get_root_roles(self, organization_id: Optional[UUID] = None) -> List[Role]:
        """Get all root roles (roles with no parent) for an organization."""
        query = select(RoleModel).where(
            and_(RoleModel.parent_role_id.is_(None), RoleModel.is_active)
        )

        if organization_id is not None:
            query = query.where(RoleModel.organization_id == organization_id)

        result = self.session.execute(query)
        role_models = result.scalars().all()
        return [self._to_domain_entity(model) for model in role_models]

    def _to_domain_entity(self, role_model: RoleModel) -> Role:
        """Convert SQLAlchemy model to domain entity."""
        return Role(
            id=role_model.id,
            name=role_model.name,
            description=role_model.description,
            organization_id=role_model.organization_id,
            parent_role_id=role_model.parent_role_id,
            created_by=role_model.created_by,
            is_active=role_model.is_active,
            is_system_role=role_model.is_system_role,
            created_at=role_model.created_at,
            updated_at=role_model.updated_at,
        )

    def _permission_to_domain_entity(
        self, permission_model: PermissionModel
    ) -> Permission:
        """Convert SQLAlchemy permission model to domain entity."""
        return Permission(
            id=permission_model.id,
            name=permission_model.name,
            description=permission_model.description,
            permission_type=permission_model.permission_type.value,
            resource_type=permission_model.resource_type,
            is_active=permission_model.is_active,
            is_system_permission=permission_model.is_system_permission,
            created_at=permission_model.created_at,
            updated_at=permission_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy import select, delete, and_, text, join
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError

from ...domain.entities.permission import Permission, PermissionAction
from ...domain.repositories.permission_repository import PermissionRepository
from ...infrastructure.database.models import (
    PermissionModel,
    PermissionActionEnum,
    role_permission_association,
    user_role_assignment,
)


class SqlAlchemyPermissionRepository(PermissionRepository):
    """SQLAlchemy implementation of PermissionRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, permission: Permission) -> Permission:
        """Save a permission entity."""
        # Check if permission exists
        existing = self.session.get(PermissionModel, permission.id)

        if existing:
            # Update existing permission
            existing.name = permission.name
            existing.description = permission.description
            existing.action = PermissionActionEnum(permission.action)
            existing.resource_type = permission.resource_type
            existing.is_active = permission.is_active
            existing.is_system_permission = permission.is_system_permission
            existing.updated_at = datetime.now(timezone.utc)

            self.session.flush()
            return self._to_domain_entity(existing)
        else:
            # Create new permission
            permission_model = PermissionModel(
                id=permission.id,
                name=permission.name,
                description=permission.description,
                action=PermissionActionEnum(permission.action),
                resource_type=permission.resource_type,
                is_active=permission.is_active,
                is_system_permission=permission.is_system_permission,
                created_at=permission.created_at,
                updated_at=permission.updated_at,
            )

            self.session.add(permission_model)
            self.session.flush()
            return self._to_domain_entity(permission_model)

    def find_by_id(self, permission_id: UUID) -> Optional[Permission]:
        """Find a permission by ID."""
        result = self.session.execute(
            select(PermissionModel).where(PermissionModel.id == permission_id)
        )
        permission_model = result.scalar_one_or_none()

        if permission_model:
            return self._to_domain_entity(permission_model)
        return None

    def find_by_name_and_resource(
        self, name: str, resource_type: str
    ) -> Optional[Permission]:
        """Find a permission by name and resource type."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.name == name,
                    PermissionModel.resource_type == resource_type,
                )
            )
        )
        permission_model = result.scalar_one_or_none()

        if permission_model:
            return self._to_domain_entity(permission_model)
        return None

    def find_by_resource_type(self, resource_type: str) -> List[Permission]:
        """Find permissions for a specific resource type."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.resource_type == resource_type,
                    PermissionModel.is_active,
                )
            )
        )
        permission_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in permission_models]

    def find_by_action(self, action: str) -> List[Permission]:
        """Find permissions by action."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.action == PermissionActionEnum(action),
                    PermissionModel.is_active,
                )
            )
        )
        permission_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in permission_models]

    def find_system_permissions(self) -> List[Permission]:
        """Find all system permissions."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.is_system_permission,
                    PermissionModel.is_active,
                )
            )
        )
        permission_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in permission_models]

    def find_by_ids(self, permission_ids: List[UUID]) -> List[Permission]:
        """Find permissions by list of IDs."""
        result = self.session.execute(
            select(PermissionModel).where(PermissionModel.id.in_(permission_ids))
        )
        permission_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in permission_models]

    def find_paginated(
        self,
        include_system: bool = True,
        is_active: Optional[bool] = None,
        resource_type: Optional[str] = None,
        action: Optional[str] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Permission], int]:
        """Find permissions with pagination and filters."""
        query = select(PermissionModel)
        count_query = select(PermissionModel)

        # Apply filters
        if not include_system:
            query = query.where(not PermissionModel.is_system_permission)
            count_query = count_query.where(not PermissionModel.is_system_permission)

        if is_active is not None:
            query = query.where(PermissionModel.is_active == is_active)
            count_query = count_query.where(PermissionModel.is_active == is_active)

        if resource_type:
            query = query.where(PermissionModel.resource_type == resource_type)
            count_query = count_query.where(
                PermissionModel.resource_type == resource_type
            )

        if action:
            query = query.where(PermissionModel.action == PermissionActionEnum(action))
            count_query = count_query.where(
                PermissionModel.action == PermissionActionEnum(action)
            )

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(PermissionModel.created_at.desc())
        )
        result = self.session.execute(query)
        permission_models = result.scalars().all()

        permissions = [self._to_domain_entity(model) for model in permission_models]
        return permissions, total

    def search(
        self,
        query: Optional[str] = None,
        resource_type: Optional[str] = None,
        action: Optional[str] = None,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Permission], int]:
        """Search permissions with text query and filters."""
        db_query = select(PermissionModel)
        count_query = select(PermissionModel)

        # Apply text search
        if query:
            search_filter = PermissionModel.name.ilike(
                f"%{query}%"
            ) | PermissionModel.description.ilike(f"%{query}%")
            db_query = db_query.where(search_filter)
            count_query = count_query.where(search_filter)

        # Apply filters
        if resource_type:
            db_query = db_query.where(PermissionModel.resource_type == resource_type)
            count_query = count_query.where(
                PermissionModel.resource_type == resource_type
            )

        if action:
            db_query = db_query.where(
                PermissionModel.action == PermissionActionEnum(action)
            )
            count_query = count_query.where(
                PermissionModel.action == PermissionActionEnum(action)
            )

        if is_active is not None:
            db_query = db_query.where(PermissionModel.is_active == is_active)
            count_query = count_query.where(PermissionModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        db_query = (
            db_query.offset(offset)
            .limit(limit)
            .order_by(PermissionModel.created_at.desc())
        )
        result = self.session.execute(db_query)
        permission_models = result.scalars().all()

        permissions = [self._to_domain_entity(model) for model in permission_models]
        return permissions, total

    def delete(self, permission_id: UUID) -> bool:
        """Delete a permission (hard delete)."""
        result = self.session.execute(
            delete(PermissionModel).where(PermissionModel.id == permission_id)
        )
        return result.rowcount > 0

    def bulk_save(self, permissions: List[Permission]) -> List[Permission]:
        """Save multiple permissions in bulk."""
        saved_permissions = []

        for permission in permissions:
            # Check if permission exists
            existing = self.find_by_name_and_resource(
                permission.name, permission.resource_type
            )
            if existing:
                continue  # Skip existing permissions

            permission_model = PermissionModel(
                id=permission.id,
                name=permission.name,
                description=permission.description,
                action=PermissionActionEnum(permission.action),
                resource_type=permission.resource_type,
                is_active=permission.is_active,
                is_system_permission=permission.is_system_permission,
                created_at=permission.created_at,
                updated_at=permission.updated_at,
            )

            self.session.add(permission_model)
            saved_permissions.append(permission)

        self.session.flush()
        return saved_permissions

    def get_role_count(self, permission_id: UUID) -> int:
        """Get the number of roles that have this permission."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM role_permissions WHERE permission_id = :permission_id"
            ).bindparam(permission_id=permission_id)
        )
        return result.scalar() or 0

    def get_resource_types(self) -> List[str]:
        """Get all unique resource types."""
        result = self.session.execute(select(PermissionModel.resource_type).distinct())
        return [row[0] for row in result.fetchall()]

    def get_actions(self) -> List[str]:
        """Get all permission actions."""
        return [pt.value for pt in PermissionActionEnum]

    def get_role_permissions(self, role_id: UUID) -> List[Permission]:
        """Get all permissions assigned to a role."""
        result = self.session.execute(
            select(PermissionModel)
            .join(role_permission_association, PermissionModel.id == role_permission_association.c.permission_id)
            .where(
                and_(
                    role_permission_association.c.role_id == role_id,
                    PermissionModel.is_active
                )
            )
            .order_by(PermissionModel.created_at.desc())
        )
        permission_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in permission_models]

    def get_by_resource_and_type(self, resource_type: str, action: PermissionAction) -> List[Permission]:
        """Get permissions by resource type and action."""
        result = self.session.execute(
            select(PermissionModel).where(
                and_(
                    PermissionModel.resource_type == resource_type,
                    PermissionModel.action == PermissionActionEnum(action),
                    PermissionModel.is_active
                )
            )
            .order_by(PermissionModel.created_at.desc())
        )
        permission_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in permission_models]

    def get_user_permissions(self, user_id: UUID, organization_id: Optional[UUID] = None) -> List[Permission]:
        """Get all permissions for a user (through roles)."""
        query = (
            select(PermissionModel)
            .join(role_permission_association, PermissionModel.id == role_permission_association.c.permission_id)
            .join(user_role_assignment, role_permission_association.c.role_id == user_role_assignment.c.role_id)
            .where(
                and_(
                    user_role_assignment.c.user_id == user_id,
                    user_role_assignment.c.is_active,
                    PermissionModel.is_active
                )
            )
        )
        
        # Add organization filter if provided
        if organization_id is not None:
            query = query.where(
                user_role_assignment.c.organization_id == organization_id
            )
        
        query = query.distinct().order_by(PermissionModel.created_at.desc())
        
        result = self.session.execute(query)
        permission_models = result.scalars().all()
        
        return [self._to_domain_entity(model) for model in permission_models]

    def exists_by_name(self, name) -> bool:
        """Check if permission exists by name."""
        # Handle both string and PermissionName value object
        name_value = name.value if hasattr(name, 'value') else str(name)
        
        result = self.session.execute(
            select(PermissionModel.id)
            .where(PermissionModel.name == name_value)
            .limit(1)
        )
        return result.scalar() is not None

    def _to_domain_entity(self, permission_model: PermissionModel) -> Permission:
        """Convert SQLAlchemy model to domain entity."""
        return Permission(
            id=permission_model.id,
            name=permission_model.name,
            description=permission_model.description,
            action=permission_model.action.value,
            resource_type=permission_model.resource_type,
            is_active=permission_model.is_active,
            is_system_permission=permission_model.is_system_permission,
            created_at=permission_model.created_at,
            updated_at=permission_model.updated_at,
        )
from .sqlalchemy_role_repository import SqlAlchemyRoleRepository
from .sqlalchemy_permission_repository import SqlAlchemyPermissionRepository
from .sqlalchemy_policy_repository import SqlAlchemyPolicyRepository

__all__ = [
    "SqlAlchemyRoleRepository",
    "SqlAlchemyPermissionRepository", 
    "SqlAlchemyPolicyRepository"
]
from .repositories import (
    SqlAlchemyRoleRepository, SqlAlchemyPermissionRepository, SqlAlchemyPolicyRepository
)

__all__ = [
    "SqlAlchemyRoleRepository",
    "SqlAlchemyPermissionRepository", 
    "SqlAlchemyPolicyRepository"
]
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from pydantic import BaseModel, Field

from ..value_objects.email import Email
from ..value_objects.password import Password


class User(BaseModel):
    """Entidade de domnio do Usurio."""
    id: UUID
    email: Email
    name: str
    password: Password
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True
    is_verified: bool = True
    last_login_at: Optional[datetime] = None
    model_config = {"arbitrary_types_allowed": True}

    @classmethod
    def create(cls, email: str, name: str, password: str) -> "User":
        """Cria uma nova instncia de Usurio."""
        return cls(
            id=uuid4(),
            email=Email(value=email),
            name=name,
            password=Password.create(password),
            created_at=datetime.utcnow(),
            is_active=True,
            is_verified=True,
        )

    def update_name(self, name: str) -> "User":
        """Atualiza o nome do usurio."""
        return self.model_copy(update={"name": name, "updated_at": datetime.utcnow()})

    def deactivate(self) -> "User":
        """Desativa a conta do usurio."""
        return self.model_copy(
            update={"is_active": False, "updated_at": datetime.utcnow()}
        )

    def activate(self) -> "User":
        """Ativa a conta do usurio."""
        return self.model_copy(
            update={"is_active": True, "updated_at": datetime.utcnow()}
        )

    def change_password(self, new_password: str) -> "User":
        """Altera a senha do usurio."""
        return self.model_copy(
            update={
                "password": Password.create(new_password),
                "updated_at": datetime.utcnow(),
            }
        )

    def verify_password(self, plain_password: str) -> bool:
        """Verifica se a senha fornecida corresponde  senha hash do usurio."""
        return self.password.verify(plain_password)

    def update_last_login(self, login_time: datetime) -> "User":
        """Atualiza o timestamp do ltimo login do usurio."""
        return self.model_copy(
            update={"last_login_at": login_time, "updated_at": datetime.utcnow()}
        )

    def can_access_organization(self, organization_id: UUID) -> bool:
        """Regra de domnio: O usurio pode acessar a organizao  qual pertence."""
        return self.is_active
from datetime import datetime
from uuid import UUID, uuid4
from typing import Any, Optional
from pydantic import BaseModel
from enum import Enum


class SessionStatus(str, Enum):
    ACTIVE = "active"
    EXPIRED = "expired"
    LOGGED_OUT = "logged_out"
    REVOKED = "revoked"


class UserSession(BaseModel):
    """Entidade de domnio da Sesso do Usurio."""
    id: UUID
    user_id: UUID
    session_token: str
    status: SessionStatus
    login_at: datetime
    logout_at: Optional[datetime] = None
    expires_at: datetime
    metadata: dict[str, Any] | None = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls,
        user_id: UUID,
        session_token: str,
        expires_at: datetime,
        metadata: dict[str, Any] | None = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> "UserSession":
        """Cria uma nova instncia de Sesso do Usurio."""
        now = datetime.utcnow()
        return cls(
            id=uuid4(),
            user_id=user_id,
            session_token=session_token,
            status=SessionStatus.ACTIVE,
            login_at=now,
            metadata=metadata,
            expires_at=expires_at,
            ip_address=ip_address,
            user_agent=user_agent,
            created_at=now,
        )

    def logout(self) -> "UserSession":
        """Marca a sesso como desconectada."""
        return self.model_copy(
            update={
                "status": SessionStatus.LOGGED_OUT,
                "logout_at": datetime.utcnow(),
                "updated_at": datetime.utcnow(),
            }
        )

    def expire(self) -> "UserSession":
        """Marca a sesso como expirada."""
        return self.model_copy(
            update={"status": SessionStatus.EXPIRED, "updated_at": datetime.utcnow()}
        )

    def revoke(self) -> "UserSession":
        """Marca a sesso como revogada (ao do administrador)."""
        return self.model_copy(
            update={
                "status": SessionStatus.REVOKED,
                "logout_at": datetime.utcnow(),
                "updated_at": datetime.utcnow(),
            }
        )

    def is_active(self) -> bool:
        """Verifica se a sesso est atualmente ativa."""
        if self.status != SessionStatus.ACTIVE:
            return False

        return datetime.utcnow() < self.expires_at

    def is_expired(self) -> bool:
        """Verifica se a sesso expirou."""
        return datetime.utcnow() >= self.expires_at

    def is_valid(self) -> bool:
        """Verifica se a sesso  vlida (ativa e no expirada)."""
        return self.is_active()

    def get_session_duration(self) -> Optional[int]:
        """Obtm a durao da sesso em segundos. Retorna None se ainda estiver ativa."""
        if not self.logout_at:
            return None

        duration = self.logout_at - self.login_at
        return int(duration.total_seconds())

    def extend_session(self, new_expires_at: datetime) -> "UserSession":
        """Estende o tempo de expirao da sesso."""
        if self.status != SessionStatus.ACTIVE:
            raise ValueError("Cannot extend inactive session")

        return self.model_copy(
            update={"expires_at": new_expires_at, "updated_at": datetime.utcnow()}
        )

    def extend(self, hours: int) -> "UserSession":
        """Estende a sesso por um nmero especificado de horas."""
        from datetime import timedelta
        new_expires_at = datetime.utcnow() + timedelta(hours=hours)
        return self.extend_session(new_expires_at)
# Este diretrio contm as entidades de domnio para o contexto delimitado de Usurio.
# As entidades representam os principais conceitos de negcio e suas regras.
from typing import Optional
from uuid import UUID

from shared.domain.repositories.unit_of_work import UnitOfWork

from ..entities.user import User
from ..value_objects.email import Email
from ..repositories.user_repository import UserRepository


class UserDomainService:
    """Servio de domnio para lgica de negcios especfica do usurio."""

    def __init__(self, uow: UnitOfWork):
        self._user_repository: UserRepository = uow.get_repository("user")
        self._uow = uow

    def is_email_available(
        self, email: Email, excluding_user_id: Optional[UUID] = None
    ) -> bool:
        """Verifica se o email est disponvel para registro ou atualizao."""
        existing_user = self._user_repository.get_by_email(email)

        if not existing_user:
            return True

        # If excluding a specific user (for updates), check if it's the same user
        if excluding_user_id and existing_user.id == excluding_user_id:
            return True

        return False

    def can_user_be_deleted(self, user_id: UUID) -> tuple[bool, str]:
        """Verifica se o usurio pode ser excludo com segurana e retorna o motivo, se no."""
        user = self._user_repository.get_by_id(user_id)

        if not user:
            return False, "User not found"

        # Add business rules for user deletion
        # For example: check if user is the only admin of an organization

        return True, "Can be deleted"

    def validate_user_activation(self, user: User) -> tuple[bool, str]:
        """Valida se o usurio pode ser ativado."""
        if user.is_active:
            return False, "User is already active"

        # Add more business rules as needed
        return True, "Can be activated"

    def validate_user_deactivation(self, user: User) -> tuple[bool, str]:
        """Valida se o usurio pode ser desativado."""
        if not user.is_active:
            return False, "User is already inactive"

        # Add business rules (e.g., check if user is sole admin of organizations)
        return True, "Can be deactivated"
from typing import Optional

from shared.domain.repositories.unit_of_work import UnitOfWork
from user.domain.repositories.user_repository import UserRepository
from user.domain.repositories.user_session_repository import UserSessionRepository

from ..entities.user import User
from ..entities.user_session import UserSession
from ..value_objects.email import Email


class AuthenticationService:
    """Servio de domnio para lgica de autenticao."""

    def __init__(self, uow: UnitOfWork):
        self._user_repository: UserRepository = uow.get_repository("user")
        self._session_repository: UserSessionRepository = uow.get_repository(
            "user_session"
        )
        self._uow = uow

    def authenticate(self, email: str, password: str) -> Optional[User]:
        """Autentica um usurio com email e senha."""
        try:
            email_vo = Email(value=email)
            user = self._user_repository.get_by_email(email_vo)

            if not user:
                return None

            if not user.is_active:
                return None

            if not user.verify_password(password):
                return None

            return user

        except ValueError:
            # Invalid email format
            return None

    def create_session(
        self,
        user: User,
        token: str,
        duration_hours: int = 24,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None,
    ) -> UserSession:
        """Cria uma nova sesso de usurio."""
        from datetime import datetime, timedelta
        
        expires_at = datetime.utcnow() + timedelta(hours=duration_hours)
        
        session = UserSession.create(
            user_id=user.id,
            session_token=token,
            expires_at=expires_at,
            user_agent=user_agent,
            ip_address=ip_address,
        )

        return self._session_repository.save(session)

    def validate_session(self, token: str) -> Optional[User]:
        """Valida o token da sesso e retorna o usurio se for vlido."""
        session = self._session_repository.get_by_token(token)

        if not session or not session.is_valid():
            return None

        user = self._user_repository.get_by_id(session.user_id)

        if not user or not user.is_active:
            return None

        return user

    def revoke_session(self, token: str) -> bool:
        """Revoga uma sesso especfica."""
        session = self._session_repository.get_by_token(token)

        if not session:
            return False

        revoked_session = session.revoke()
        self._session_repository.save(revoked_session)

        return True

    def revoke_all_user_sessions(self, user_id) -> int:
        """Revoga todas as sesses de um usurio."""
        return self._session_repository.revoke_all_user_sessions(user_id)
# Este diretrio contm os servios de domnio para o contexto delimitado de Usurio.
# Os servios de domnio encapsulam a lgica de negcio que no pertence a uma nica entidade.
import re
from typing import Any
from pydantic import BaseModel, field_validator


class Email(BaseModel):
    """Objeto de valor para Email."""

    value: str

    model_config = {"frozen": True}

    @field_validator("value")
    def validate_email(cls, v: str) -> str:
        if not cls._is_valid_email(v):
            raise ValueError(f"Invalid email format: {v}")
        return v.lower().strip()

    @staticmethod
    def _is_valid_email(email: str) -> bool:
        pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        return re.match(pattern, email) is not None

    def domain(self) -> str:
        """Retorna o domnio do email."""
        return self.value.split("@")[1]

    def local_part(self) -> str:
        """Retorna a parte local do email."""
        return self.value.split("@")[0]

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, Email):
            return self.value == other.value
        return False
import re
from typing import Any
import bcrypt
from pydantic import BaseModel


class Password(BaseModel, frozen=True):
    """Objeto de valor para Senha com criptografia bcrypt e regras de validao."""

    hashed_value: str

    @classmethod
    def create(cls, plain_password: str) -> "Password":
        """Cria uma nova senha fazendo hash do texto simples."""
        cls._validate_password_strength(plain_password)

        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
        return cls(hashed_value=hashed.decode("utf-8"))

    @classmethod
    def from_hash(cls, hashed_password: str) -> "Password":
        """Cria um objeto de senha a partir de um hash existente."""
        return cls(hashed_value=hashed_password)

    @staticmethod
    def _validate_password_strength(password: str) -> None:
        """Valida a fora da senha de acordo com as regras de negcio."""
        if not password or len(password.strip()) == 0:
            raise ValueError("Password cannot be empty")

        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters long")

        if len(password) > 128:
            raise ValueError("Password cannot exceed 128 characters")

        if not re.search(r"[A-Z]", password):
            raise ValueError("Password must contain at least one uppercase letter")

        if not re.search(r"[a-z]", password):
            raise ValueError("Password must contain at least one lowercase letter")

        if not re.search(r"\d", password):
            raise ValueError("Password must contain at least one digit")

    def verify(self, plain_password: str) -> bool:
        """Verifica uma senha simples em relao a esta senha hash."""
        return bcrypt.checkpw(
            plain_password.encode("utf-8"), self.hashed_value.encode("utf-8")
        )

    def __str__(self) -> str:
        return "[PROTECTED]"

    def __repr__(self) -> str:
        return "Password([PROTECTED])"

    def __hash__(self) -> int:
        return hash(self.hashed_value)

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Password):
            return False
        return self.hashed_value == other.hashed_value
# Este diretrio contm os objetos de valor para o contexto delimitado de Usurio.
# Os objetos de valor representam conceitos descritivos sem identidade conceitual.
from abc import ABC, abstractmethod
from typing import List, Optional
from uuid import UUID

from user.domain.entities.user_session import UserSession


class UserSessionRepository(ABC):
    """Interface do repositrio de sesso de usurio para o contexto delimitado de Usurio."""

    @abstractmethod
    def save(self, session: UserSession) -> UserSession:
        """Salva ou atualiza uma sesso de usurio."""
        pass

    @abstractmethod
    def get_by_id(self, session_id: UUID) -> Optional[UserSession]:
        """Obtm uma sesso pelo ID."""
        pass

    @abstractmethod
    def get_by_token(self, token: str) -> Optional[UserSession]:
        """Obtm uma sesso pelo token."""
        pass

    @abstractmethod
    def get_active_by_user_id(self, user_id: UUID) -> List[UserSession]:
        """Obtm todas as sesses ativas para um usurio."""
        pass

    @abstractmethod
    def revoke_all_user_sessions(self, user_id: UUID) -> int:
        """Revoga todas as sesses de um usurio. Retorna a contagem de sesses revogadas."""
        pass

    @abstractmethod
    def cleanup_expired_sessions(self) -> int:
        """Limpa sesses expiradas. Retorna a contagem de sesses limpas."""
        pass

    @abstractmethod
    def delete(self, session_id: UUID) -> bool:
        """Exclui uma sesso pelo ID."""
        pass
from abc import ABC, abstractmethod
from typing import List, Optional
from uuid import UUID

from user.domain.entities.user import User
from user.domain.value_objects.email import Email


class UserRepository(ABC):
    """Interface do repositrio de usurios para o contexto delimitado de Usurio."""

    @abstractmethod
    def save(self, user: User) -> User:
        """Salva ou atualiza um usurio."""
        pass

    @abstractmethod
    def get_by_id(self, user_id: UUID) -> Optional[User]:
        """Obtm um usurio pelo ID."""
        pass

    @abstractmethod
    def get_by_email(self, email: Email) -> Optional[User]:
        """Obtm um usurio pelo email."""
        pass

    @abstractmethod
    def exists_by_email(self, email: Email) -> bool:
        """Verifica se o usurio existe pelo email."""
        pass

    @abstractmethod
    def delete(self, user_id: UUID) -> bool:
        """Exclui um usurio pelo ID."""
        pass

    @abstractmethod
    def list_active_users(self, limit: int = 100, offset: int = 0) -> List[User]:
        """Lista usurios ativos com paginao."""
        pass

    @abstractmethod
    def count_active_users(self) -> int:
        """Conta o total de usurios ativos."""
        pass
# Este diretrio contm as interfaces de repositrio para o contexto delimitado de Usurio.
# As interfaces definem os contratos para acesso a dados, independentemente da implementao.
# Este diretrio contm a camada de domnio do contexto delimitado de Usurio.
# Ele define as entidades, objetos de valor, repositrios e servios de domnio.
from fastapi import APIRouter

from .routes.auth_routes import router as auth_router
from .routes.user_routes import router as user_router
from .routes.session_routes import router as session_router

# Cria o roteador principal do usurio
user_api_router = APIRouter(prefix="/api/v1/user", tags=["Contexto do Usurio"])

# Inclui todos os sub-roteadores
user_api_router.include_router(auth_router)
user_api_router.include_router(user_router)
user_api_router.include_router(session_router)

__all__ = ["user_api_router"]
from fastapi import Depends
from sqlalchemy.orm import Session

from shared.infrastructure.database.connection import get_db
from user.application.use_cases.auth_use_cases import AuthUseCase
from user.application.use_cases.user_use_cases import UserUseCase
from user.application.use_cases.session_use_cases import SessionUseCase
from user.infrastructure.user_unit_of_work import UserUnitOfWork


def get_user_uow(db: Session = Depends(get_db)) -> UserUnitOfWork:
    """Obtm uma instncia de UserUnitOfWork com repositrios de usurio e sesso de usurio."""
    return UserUnitOfWork(db, ["user", "user_session"])


def get_auth_use_case(uow: UserUnitOfWork = Depends(get_user_uow)) -> AuthUseCase:
    """Obtm AuthUseCase com a dependncia UnitOfWork apropriada."""
    return AuthUseCase(uow)


def get_user_use_case(uow: UserUnitOfWork = Depends(get_user_uow)) -> UserUseCase:
    """Obtm UserUseCase com a dependncia UnitOfWork apropriada."""
    return UserUseCase(uow)


def get_session_use_case(uow: UserUnitOfWork = Depends(get_user_uow)) -> SessionUseCase:
    """Obtm SessionUseCase com a dependncia UnitOfWork apropriada."""
    return SessionUseCase(uow)
from fastapi import APIRouter, Depends, HTTPException, Query, status
from typing import Optional
from uuid import UUID

from ..dependencies import get_user_use_case
from ...application.dtos.user_dto import (
    UserCreateDTO,
    UserUpdateDTO,
    UserChangePasswordDTO,
    UserResponseDTO,
    UserListResponseDTO,
)
from ...application.use_cases.user_use_cases import UserUseCase

router = APIRouter(prefix="/users", tags=["Usurios"])


@router.post("/", response_model=UserResponseDTO, status_code=status.HTTP_201_CREATED)
async def create_user(
    dto: UserCreateDTO,
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Cria um novo usurio."""
    try:
        return use_case.create_user(dto)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{user_id}", response_model=UserResponseDTO)
async def get_user_by_id(
    user_id: UUID,
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Obtm um usurio pelo ID."""
    try:
        user = use_case.get_user_by_id(user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found",
            )
        return user
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/", response_model=UserListResponseDTO)
async def list_users(
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(100, ge=1, le=1000, description="Items per page"),
    active_only: bool = Query(True, description="Show only active users"),
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Lista usurios com paginao."""
    try:
        return use_case.list_users(page=page, page_size=page_size, active_only=active_only)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/by-email/{email}", response_model=UserResponseDTO)
async def get_user_by_email(
    email: str,
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Obtm um usurio pelo email."""
    try:
        user = use_case.get_user_by_email(email)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found",
            )
        return user
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.put("/{user_id}", response_model=UserResponseDTO)
async def update_user(
    user_id: UUID,
    dto: UserUpdateDTO,
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Atualiza as informaes do usurio."""
    try:
        return use_case.update_user(user_id, dto)
    except ValueError as e:
        if "not found" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=str(e),
            )
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{user_id}/change-password")
async def change_password(
    user_id: UUID,
    dto: UserChangePasswordDTO,
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Altera a senha do usurio."""
    try:
        use_case.change_password(user_id, dto)
        return {"message": "Password changed successfully"}
    except ValueError as e:
        if "not found" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=str(e),
            )
        if "incorrect" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=str(e),
            )
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{user_id}/activate", response_model=UserResponseDTO)
async def activate_user(
    user_id: UUID,
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Ativa a conta do usurio."""
    try:
        return use_case.activate_user(user_id)
    except ValueError as e:
        if "not found" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=str(e),
            )
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{user_id}/deactivate", response_model=UserResponseDTO)
async def deactivate_user(
    user_id: UUID,
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Desativa a conta do usurio."""
    try:
        return use_case.deactivate_user(user_id)
    except ValueError as e:
        if "not found" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=str(e),
            )
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{user_id}")
async def delete_user(
    user_id: UUID,
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Exclui a conta do usurio."""
    try:
        success = use_case.delete_user(user_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found",
            )
        return {"message": "User deleted successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/check-email/{email}")
async def check_email_availability(
    email: str,
    excluding_user_id: Optional[UUID] = Query(None, description="Exclude this user ID from check"),
    use_case: UserUseCase = Depends(get_user_use_case),
):
    """Verifica se o email est disponvel para uso."""
    try:
        available = use_case.check_email_availability(email, excluding_user_id)
        return {"email": email, "available": available}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
from fastapi import APIRouter, Depends, HTTPException, Request, status, Query
from typing import List
from uuid import UUID

from ..dependencies import get_session_use_case
from ...application.dtos.session_dto import (
    SessionCreateDTO,
    SessionResponseDTO,
    SessionListResponseDTO,
)
from ...application.use_cases.session_use_cases import SessionUseCase

router = APIRouter(prefix="/sessions", tags=["Sesses"])


def get_auth_token(request: Request) -> str:
    """Extrai e valida o token de autorizao da requisio."""
    auth_header = request.headers.get("authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authorization header required",
        )
    return auth_header.split(" ")[1]


@router.post("/", response_model=SessionResponseDTO, status_code=status.HTTP_201_CREATED)
async def create_session(
    dto: SessionCreateDTO,
    request: Request,
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Cria uma nova sesso de usurio."""
    try:
        # Add client info to DTO
        dto.user_agent = request.headers.get("user-agent")
        dto.ip_address = request.client.host if request.client else None
        
        return use_case.create_session(dto)
    except ValueError as e:
        if "not found" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=str(e),
            )
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{session_id}", response_model=SessionResponseDTO)
async def get_session_by_id(
    session_id: UUID,
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Obtm uma sesso pelo ID."""
    try:
        session = use_case.get_session_by_id(session_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Session not found",
            )
        return session
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/by-token/{token}", response_model=SessionResponseDTO)
async def get_session_by_token(
    token: str,
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Obtm uma sesso pelo token."""
    try:
        session = use_case.get_session_by_token(token)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Session not found",
            )
        return session
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/user/{user_id}", response_model=SessionListResponseDTO)
async def get_user_sessions(
    user_id: UUID,
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Obtm todas as sesses de um usurio."""
    try:
        return use_case.get_user_sessions(user_id)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{session_id}")
async def revoke_session(
    session_id: UUID,
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Revoga uma sesso especfica."""
    try:
        success = use_case.revoke_session(session_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Session not found",
            )
        return {"message": "Session revoked successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/by-token/{token}")
async def revoke_session_by_token(
    token: str,
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Revoga uma sesso pelo token."""
    try:
        success = use_case.revoke_session_by_token(token)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Session not found",
            )
        return {"message": "Session revoked successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/user/{user_id}/all")
async def revoke_all_user_sessions(
    user_id: UUID,
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Revoga todas as sesses de um usurio."""
    try:
        count = use_case.revoke_all_user_sessions(user_id)
        return {"message": f"Revoked {count} sessions"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.put("/{session_id}/extend", response_model=SessionResponseDTO)
async def extend_session(
    session_id: UUID,
    hours: int = Query(24, ge=1, le=720, description="Hours to extend session"),
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Estende a durao da sesso."""
    try:
        session = use_case.extend_session(session_id, hours)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Session not found or invalid",
            )
        return session
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/cleanup")
async def cleanup_expired_sessions(
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Limpa sesses expiradas."""
    try:
        count = use_case.cleanup_expired_sessions()
        return {"message": f"Cleaned up {count} expired sessions"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/validate/{token}")
async def validate_session_access(
    token: str,
    permissions: List[str] = Query(None, description="Required permissions"),
    use_case: SessionUseCase = Depends(get_session_use_case),
):
    """Valida a sesso e permisses opcionais."""
    try:
        valid = use_case.validate_session_access(token, permissions)
        return {"valid": valid, "token": token}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
from fastapi import APIRouter, Depends, HTTPException, Request, status
from typing import Optional

from ..dependencies import get_auth_use_case
from ...application.dtos.auth_dto import (
    LoginDTO,
    AuthResponseDTO,
    LogoutDTO,
    PasswordResetRequestDTO,
    PasswordResetConfirmDTO,
)
from ...application.use_cases.auth_use_cases import AuthUseCase

router = APIRouter(prefix="/auth", tags=["Autenticao"])


def get_client_info(request: Request) -> tuple[Optional[str], Optional[str]]:
    """Extrai informaes do cliente da requisio."""
    user_agent = request.headers.get("user-agent")
    ip_address = request.client.host if request.client else None
    return user_agent, ip_address


@router.post("/login", response_model=AuthResponseDTO)
async def login(
    dto: LoginDTO,
    request: Request,
    use_case: AuthUseCase = Depends(get_auth_use_case),
):
    """Autentica o usurio e cria uma sesso."""
    try:
        user_agent, ip_address = get_client_info(request)
        dto.user_agent = user_agent
        dto.ip_address = ip_address
        return use_case.login(dto)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=str(e))


@router.post("/logout")
async def logout(
    dto: LogoutDTO,
    request: Request,
    use_case: AuthUseCase = Depends(get_auth_use_case),
):
    """Realiza o logout do usurio, revogando a(s) sesso(es)."""
    try:
        # Extract token from Authorization header
        auth_header = request.headers.get("authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Authorization header required",
            )
        
        token = auth_header.split(" ")[1]
        success = use_case.logout(token, dto)
        
        if not success:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid session",
            )
        
        return {"message": "Logged out successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/refresh", response_model=AuthResponseDTO)
async def refresh_session(
    request: Request,
    use_case: AuthUseCase = Depends(get_auth_use_case),
):
    """Atualiza o token da sesso."""
    try:
        # Extract token from Authorization header
        auth_header = request.headers.get("authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Authorization header required",
            )
        
        token = auth_header.split(" ")[1]
        result = use_case.refresh_session(token)
        
        if not result:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired session",
            )
        
        return result
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/validate")
async def validate_session(
    request: Request,
    use_case: AuthUseCase = Depends(get_auth_use_case),
):
    """Valida o token da sesso e retorna as informaes do usurio."""
    try:
        # Extract token from Authorization header
        auth_header = request.headers.get("authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Authorization header required",
            )
        
        token = auth_header.split(" ")[1]
        user = use_case.validate_session(token)
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired session",
            )
        
        return {"user": user}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/password-reset/request")
async def request_password_reset(
    dto: PasswordResetRequestDTO,
    use_case: AuthUseCase = Depends(get_auth_use_case),
):
    """Solicita a redefinio de senha para o usurio."""
    try:
        use_case.request_password_reset(dto)
        return {"message": "Password reset email sent if account exists"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/password-reset/confirm")
async def confirm_password_reset(
    dto: PasswordResetConfirmDTO,
    use_case: AuthUseCase = Depends(get_auth_use_case),
):
    """Confirma a redefinio de senha com o token."""
    try:
        success = use_case.confirm_password_reset(dto)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid or expired reset token",
            )
        
        return {"message": "Password reset successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))

from .auth_routes import router as auth_routes
from .user_routes import router as user_routes
from .session_routes import router as session_routes

__all__ = ["auth_routes", "user_routes", "session_routes"]
# from .routes import user_api_router

# __all__ = ["user_api_router"]
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field
from .user_dto import UserResponseDTO
from .session_dto import SessionResponseDTO


class LoginDTO(BaseModel):
    """DTO para login de usurio."""

    email: str = Field(..., description="Endereo de email do usurio")
    password: str = Field(..., description="Senha do usurio")
    remember_me: bool = Field(False, description="Durao estendida da sesso")
    user_agent: Optional[str] = Field(
        None, max_length=500, description="String do user agent"
    )
    ip_address: Optional[str] = Field(None, max_length=45, description="Endereo IP")


class AuthResponseDTO(BaseModel):
    """DTO para resposta de autenticao."""

    user: UserResponseDTO
    session: SessionResponseDTO
    access_token: str
    token_type: str = "bearer"
    expires_in: int  # segundos


class LogoutDTO2(BaseModel):
    session_id: UUID
    user_id: UUID


class LogoutDTO(BaseModel):
    """DTO para logout de usurio."""

    revoke_all_sessions: bool = Field(False, description="Revogar todas as sesses do usurio")


class LogoutResponseDTO(BaseModel):
    success: bool = True
    message: str = "Sesso encerrada com sucesso"


class RefreshTokenDTO(BaseModel):
    """DTO para atualizao de token."""

    refresh_token: str = Field(..., description="Token de atualizao")


class PasswordResetRequestDTO(BaseModel):
    """DTO para solicitao de redefinio de senha."""

    email: str = Field(..., description="Endereo de email do usurio")


class PasswordResetConfirmDTO(BaseModel):
    """DTO para confirmao de redefinio de senha."""

    token: str = Field(..., description="Token de redefinio de senha")
    new_password: str = Field(..., min_length=8, description="Nova senha")
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field, field_validator


class UserCreateDTO(BaseModel):
    """DTO para criao de um novo usurio."""
    email: str = Field(..., description="Endereo de email do usurio")
    name: str = Field(..., min_length=2, max_length=100, description="Nome completo do usurio")
    password: str = Field(..., min_length=8, description="Senha do usurio")
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v: str) -> str:
        if '@' not in v or '.' not in v.split('@')[-1]:
            raise ValueError('Invalid email format')
        return v.lower().strip()
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip()


class UserUpdateDTO(BaseModel):
    """DTO para atualizao de um usurio existente."""
    name: Optional[str] = Field(None, min_length=2, max_length=100, description="Nome completo do usurio")
    is_active: Optional[bool] = Field(None, description="Status de atividade do usurio")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: Optional[str]) -> Optional[str]:
        if v is not None and not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip() if v else None


class UserChangePasswordDTO(BaseModel):
    """DTO para alterao da senha do usurio."""
    current_password: str = Field(..., description="Senha atual")
    new_password: str = Field(..., min_length=8, description="Nova senha")


class UserResponseDTO(BaseModel):
    """DTO para dados de resposta do usurio."""
    id: UUID
    email: str
    name: str
    is_active: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    model_config = {"from_attributes": True}


class UserListResponseDTO(BaseModel):
    """DTO para lista paginada de usurios."""
    users: list[UserResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int
# Este diretrio contm os DTOs (Data Transfer Objects) para o contexto delimitado de Usurio.
# Os DTOs so usados para transferir dados entre as camadas da aplicao.
from datetime import datetime
from typing import Optional
from uuid import UUID
from pydantic import BaseModel, Field


class SessionCreateDTO(BaseModel):
    """DTO para criao de uma nova sesso de usurio."""
    user_id: UUID = Field(..., description="ID do Usurio")
    duration_hours: int = Field(24, ge=1, le=720, description="Durao da sesso em horas")
    user_agent: Optional[str] = Field(None, max_length=500, description="String do user agent")
    ip_address: Optional[str] = Field(None, max_length=45, description="Endereo IP")


class SessionResponseDTO(BaseModel):
    """DTO para dados de resposta da sesso."""
    id: UUID
    user_id: UUID
    token: str
    expires_at: datetime
    created_at: datetime
    is_active: bool
    user_agent: Optional[str] = None
    ip_address: Optional[str] = None
    is_expired: bool
    is_valid: bool
    
    model_config = {"from_attributes": True}


class SessionListResponseDTO(BaseModel):
    """DTO para lista paginada de sesses de usurio."""
    sessions: list[SessionResponseDTO]
    total: int
    active_count: int
# Este diretrio contm a camada de aplicao do contexto delimitado de Usurio.
# Ele orquestra a lgica de domnio para casos de uso e define os DTOs (Data Transfer Objects).
from typing import Optional
from uuid import UUID

from shared.domain.repositories.unit_of_work import UnitOfWork
from user.domain.repositories.user_repository import UserRepository
from user.domain.repositories.user_session_repository import UserSessionRepository

from ..dtos.auth_dto import (
    LoginDTO,
    AuthResponseDTO,
    LogoutDTO,
    PasswordResetRequestDTO,
    PasswordResetConfirmDTO,
)
from ..dtos.user_dto import UserResponseDTO
from ..dtos.session_dto import SessionResponseDTO
from ...domain.services.authentication_service import AuthenticationService


class AuthUseCase:
    """Casos de uso para autenticao e autorizao."""

    def __init__(self, uow: UnitOfWork):
        self._user_repository: UserRepository = uow.get_repository("user")
        self._session_repository: UserSessionRepository = uow.get_repository(
            "user_session"
        )
        self._auth_service = AuthenticationService(uow)
        self._uow = uow

    def login(self, dto: LoginDTO) -> AuthResponseDTO:
        """Autentica um usurio e cria uma sesso."""
        with self._uow:
            # Authenticate user
            user = self._auth_service.authenticate(dto.email, dto.password)

            if not user:
                raise ValueError("Invalid email or password")

            # Determine session duration
            duration_hours = 720 if dto.remember_me else 24  # 30 days vs 1 day

            # Generate session token
            session_token = self._generate_session_token()

            # Create session
            session = self._auth_service.create_session(
                user=user,
                token=session_token,
                duration_hours=duration_hours,
                user_agent=dto.user_agent,
                ip_address=dto.ip_address,
            )

        # Create response DTOs
        user_dto = UserResponseDTO.model_validate(user)
        session_dto = SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

        return AuthResponseDTO(
            user=user_dto,
            session=session_dto,
            access_token=session_token,
            expires_in=int(duration_hours * 3600),  # Convert to seconds
        )

    def logout(self, token: str, dto: LogoutDTO) -> bool:
        """Realiza o logout do usurio, revogando a(s) sesso(es)."""
        with self._uow:
            # Get session to find user
            session = self._session_repository.get_by_token(token)

            if not session:
                return False

            if dto.revoke_all_sessions:
                # Revoke all user sessions
                self._auth_service.revoke_all_user_sessions(session.user_id)
            else:
                # Revoke only current session
                self._auth_service.revoke_session(token)

        return True

    def validate_session(self, token: str) -> Optional[UserResponseDTO]:
        """Valida o token da sesso e retorna o usurio."""

        user = self._auth_service.validate_session(token)

        if not user:
            return None

        return UserResponseDTO.model_validate(user)

    def refresh_session(self, token: str) -> Optional[AuthResponseDTO]:
        """Atualiza a sesso se for vlida."""
        with self._uow:
            # Validate current session
            user = self._auth_service.validate_session(token)

            if not user:
                return None

            # Get current session
            session = self._session_repository.get_by_token(token)

            if not session or not session.is_valid():
                return None

            # Generate new token
            new_token = self._generate_session_token()

            # Create new session with same duration
            original_duration = int(
                (session.expires_at - session.created_at).total_seconds() / 3600
            )

            new_session = self._auth_service.create_session(
                user=user,
                token=new_token,
                duration_hours=original_duration,
                user_agent=session.user_agent,
                ip_address=session.ip_address,
            )

            # Revoke old session
            self._auth_service.revoke_session(token)

        # Create response DTOs
        user_dto = UserResponseDTO.model_validate(user)
        session_dto = SessionResponseDTO.model_validate(
            {
                **new_session.model_dump(),
                "is_expired": new_session.is_expired(),
                "is_valid": new_session.is_valid(),
            }
        )

        return AuthResponseDTO(
            user=user_dto,
            session=session_dto,
            access_token=new_token,
            expires_in=int(original_duration * 3600),
        )

    def request_password_reset(self, dto: PasswordResetRequestDTO) -> bool:
        """Solicita a redefinio de senha para o usurio."""
        from ...domain.value_objects.email import Email

        # Check if user exists
        email_vo = Email(value=dto.email)
        user = self._user_repository.get_by_email(email_vo)

        if not user or not user.is_active:
            # Don't reveal if email exists or not
            return True

        # Generate reset token (in real implementation, this would be sent via email)
        reset_token = self._generate_reset_token()

        # Store reset token (this would typically be in a separate table/cache)
        # For now, just return success

        return True

    def confirm_password_reset(self, dto: PasswordResetConfirmDTO) -> bool:
        """Confirma a redefinio de senha com o token."""

        # In real implementation, validate reset token and get associated user
        # For now, this is a placeholder implementation

        # Validate token format
        if len(dto.token) < 32:
            raise ValueError("Invalid reset token")

        # Here you would:
        # 1. Validate token exists and is not expired
        # 2. Get associated user
        # 3. Update user password
        # 4. Revoke all user sessions
        # 5. Delete/mark token as used

        return True

    def change_password_with_current(
        self, user_id: UUID, current_password: str, new_password: str
    ) -> bool:
        """Altera a senha com a verificao da senha atual."""
        with self._uow:
            user = self._user_repository.get_by_id(user_id)

            if not user:
                raise ValueError("User not found")

            # Verify current password
            if not user.verify_password(current_password):
                raise ValueError("Current password is incorrect")

            # Update password
            updated_user = user.change_password(new_password)
            self._user_repository.save(updated_user)

            # Revoke all sessions to force re-login
            self._auth_service.revoke_all_user_sessions(user_id)

        return True

    def _generate_session_token(self) -> str:
        """Gera um token de sesso seguro."""
        import secrets

        return secrets.token_urlsafe(32)

    def _generate_reset_token(self) -> str:
        """Gera um token de redefinio de senha seguro."""
        import secrets

        return secrets.token_urlsafe(32)
from typing import Optional
from uuid import UUID
import math

from shared.domain.repositories.unit_of_work import UnitOfWork

from ..dtos.user_dto import (
    UserCreateDTO,
    UserUpdateDTO,
    UserChangePasswordDTO,
    UserResponseDTO,
    UserListResponseDTO,
)
from ...domain.entities.user import User
from ...domain.repositories.user_repository import UserRepository
from ...domain.services.user_domain_service import UserDomainService
from ...domain.value_objects.email import Email


class UserUseCase:
    """Casos de uso para gerenciamento de usurios."""

    def __init__(self, uow: UnitOfWork):
        self._user_repository: UserRepository = uow.get_repository("user")
        self._user_domain_service = UserDomainService(uow)
        self._uow = uow

    def create_user(self, dto: UserCreateDTO) -> UserResponseDTO:
        """Cria um novo usurio."""
        with self._uow:
            # Check if email is available
            email_vo = Email(value=dto.email)
            is_available = self._user_domain_service.is_email_available(email_vo)

            if not is_available:
                raise ValueError(f"Email {dto.email} is already in use")

            # Create user entity
            user = User.create(email=dto.email, name=dto.name, password=dto.password)

            # Save user
            saved_user = self._user_repository.save(user)

        return UserResponseDTO.model_validate(saved_user)

    def get_user_by_id(self, user_id: UUID) -> Optional[UserResponseDTO]:
        """Obtm um usurio pelo ID."""
        user = self._user_repository.get_by_id(user_id)

        if not user:
            return None

        return UserResponseDTO.model_validate(user)

    def get_user_by_email(self, email: str) -> Optional[UserResponseDTO]:
        """Obtm um usurio pelo email."""
        email_vo = Email(value=email)
        user = self._user_repository.get_by_email(email_vo)

        if not user:
            return None

        return UserResponseDTO.model_validate(user)

    def update_user(self, user_id: UUID, dto: UserUpdateDTO) -> UserResponseDTO:
        """Atualiza as informaes do usurio."""
        with self._uow:
            user = self._user_repository.get_by_id(user_id)

            if not user:
                raise ValueError("User not found")

            updated_user = user

            # Update name if provided
            if dto.name is not None:
                updated_user = updated_user.update_name(dto.name)

            # Update active status if provided
            if dto.is_active is not None:
                if dto.is_active and not user.is_active:
                    can_activate, reason = (
                        self._user_domain_service.validate_user_activation(user)
                    )
                    if not can_activate:
                        raise ValueError(f"Cannot activate user: {reason}")
                    updated_user = updated_user.activate()
                elif not dto.is_active and user.is_active:
                    can_deactivate, reason = (
                        self._user_domain_service.validate_user_deactivation(user)
                    )
                    if not can_deactivate:
                        raise ValueError(f"Cannot deactivate user: {reason}")
                    updated_user = updated_user.deactivate()

            # Save updated user
            saved_user = self._user_repository.save(updated_user)

        return UserResponseDTO.model_validate(saved_user)

    def change_password(self, user_id: UUID, dto: UserChangePasswordDTO) -> bool:
        """Altera a senha do usurio."""
        with self._uow:
            user = self._user_repository.get_by_id(user_id)

            if not user:
                raise ValueError("User not found")

            # Verify current password
            if not user.verify_password(dto.current_password):
                raise ValueError("Current password is incorrect")

            # Update password
            updated_user = user.change_password(dto.new_password)
            self._user_repository.save(updated_user)

        return True

    def deactivate_user(self, user_id: UUID) -> UserResponseDTO:
        """Desativa a conta do usurio."""
        with self._uow:
            user = self._user_repository.get_by_id(user_id)

            if not user:
                raise ValueError("User not found")

            can_deactivate, reason = self._user_domain_service.validate_user_deactivation(
                user
            )
            if not can_deactivate:
                raise ValueError(f"Cannot deactivate user: {reason}")

            updated_user = user.deactivate()
            saved_user = self._user_repository.save(updated_user)

        return UserResponseDTO.model_validate(saved_user)

    def activate_user(self, user_id: UUID) -> UserResponseDTO:
        """Ativa a conta do usurio."""
        with self._uow:
            user = self._user_repository.get_by_id(user_id)

            if not user:
                raise ValueError("User not found")

            can_activate, reason = self._user_domain_service.validate_user_activation(user)
            if not can_activate:
                raise ValueError(f"Cannot activate user: {reason}")

            updated_user = user.activate()
            saved_user = self._user_repository.save(updated_user)

        return UserResponseDTO.model_validate(saved_user)

    def delete_user(self, user_id: UUID) -> bool:
        """Exclui a conta do usurio."""
        with self._uow:
            can_delete, reason = self._user_domain_service.can_user_be_deleted(user_id)

            if not can_delete:
                raise ValueError(f"Cannot delete user: {reason}")

            result = self._user_repository.delete(user_id)

        return result

    def list_users(
        self, page: int = 1, page_size: int = 100, active_only: bool = True
    ) -> UserListResponseDTO:
        """Lista usurios com paginao."""

        if page < 1:
            page = 1

        if page_size < 1 or page_size > 1000:
            page_size = 100

        offset = (page - 1) * page_size

        # Get users
        users = self._user_repository.list_active_users(limit=page_size, offset=offset)

        # Get total count
        total = self._user_repository.count_active_users()

        # Convert to DTOs
        user_dtos = [UserResponseDTO.model_validate(user) for user in users]

        total_pages = math.ceil(total / page_size)

        return UserListResponseDTO(
            users=user_dtos,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def check_email_availability(
        self, email: str, excluding_user_id: Optional[UUID] = None
    ) -> bool:
        """Verifica se o email est disponvel para uso."""
        email_vo = Email(value=email)
        return self._user_domain_service.is_email_available(email_vo, excluding_user_id)

from typing import Optional
from uuid import UUID

from shared.domain.repositories.unit_of_work import UnitOfWork

from ..dtos.session_dto import (
    SessionCreateDTO,
    SessionResponseDTO,
    SessionListResponseDTO,
)
from ...domain.entities.user_session import UserSession
from ...domain.repositories.user_repository import UserRepository
from ...domain.repositories.user_session_repository import UserSessionRepository
from ...domain.services.authentication_service import AuthenticationService


class SessionUseCase:
    """Casos de uso para gerenciamento de sesses."""

    def __init__(self, uow: UnitOfWork):
        self._user_repository: UserRepository = uow.get_repository("user")
        self._session_repository: UserSessionRepository = uow.get_repository(
            "user_session"
        )
        self._auth_service = AuthenticationService(uow)
        self._uow = uow

    def create_session(self, dto: SessionCreateDTO) -> SessionResponseDTO:
        """Cria uma nova sesso de usurio."""
        with self._uow:
            # Verify user exists and is active
            user = self._user_repository.get_by_id(dto.user_id)

            if not user:
                raise ValueError("User not found")

            if not user.is_active:
                raise ValueError("User account is not active")

            # Generate session token
            session_token = self._generate_session_token()

            # Create session
            session = self._auth_service.create_session(
                user=user,
                token=session_token,
                duration_hours=dto.duration_hours,
                user_agent=dto.user_agent,
                ip_address=dto.ip_address,
            )

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

    def get_session_by_id(self, session_id: UUID) -> Optional[SessionResponseDTO]:
        """Obtm uma sesso pelo ID."""
        session = self._session_repository.get_by_id(session_id)

        if not session:
            return None

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

    def get_session_by_token(self, token: str) -> Optional[SessionResponseDTO]:
        """Obtm uma sesso pelo token."""
        session = self._session_repository.get_by_token(token)

        if not session:
            return None

        return SessionResponseDTO.model_validate(
            {
                **session.model_dump(),
                "is_expired": session.is_expired(),
                "is_valid": session.is_valid(),
            }
        )

    def get_user_sessions(self, user_id: UUID) -> SessionListResponseDTO:
        """Obtm todas as sesses de um usurio."""

        # Get active sessions
        sessions = self._session_repository.get_active_by_user_id(user_id)

        # Convert to DTOs
        session_dtos = []
        active_count = 0

        for session in sessions:
            session_dto = SessionResponseDTO.model_validate(
                {
                    **session.model_dump(),
                    "is_expired": session.is_expired(),
                    "is_valid": session.is_valid(),
                }
            )
            session_dtos.append(session_dto)

            if session_dto.is_valid:
                active_count += 1

        return SessionListResponseDTO(
            sessions=session_dtos, total=len(session_dtos), active_count=active_count
        )

    def revoke_session(self, session_id: UUID) -> bool:
        """Revoga uma sesso especfica."""
        with self._uow:
            session = self._session_repository.get_by_id(session_id)

            if not session:
                return False

            result = self._auth_service.revoke_session(session.session_token)

        return result

    def revoke_session_by_token(self, token: str) -> bool:
        """Revoga uma sesso pelo token."""
        with self._uow:
            result = self._auth_service.revoke_session(token)
        return result

    def revoke_all_user_sessions(self, user_id: UUID) -> int:
        """Revoga todas as sesses de um usurio."""
        with self._uow:
            result = self._auth_service.revoke_all_user_sessions(user_id)
        return result

    def extend_session(
        self, session_id: UUID, hours: int = 24
    ) -> Optional[SessionResponseDTO]:
        """Estende a durao de uma sesso."""
        with self._uow:
            session = self._session_repository.get_by_id(session_id)

            if not session or not session.is_valid():
                return None

            # Extend session
            extended_session = session.extend(hours)
            saved_session = self._session_repository.save(extended_session)

        return SessionResponseDTO.model_validate(
            {
                **saved_session.model_dump(),
                "is_expired": saved_session.is_expired(),
                "is_valid": saved_session.is_valid(),
            }
        )

    def cleanup_expired_sessions(self) -> int:
        """Limpa sesses expiradas."""
        with self._uow:
            result = self._session_repository.cleanup_expired_sessions()
        return result

    def validate_session_access(
        self, token: str, required_permissions: list[str] = None
    ) -> bool:
        """Valida a sesso e permisses opcionais."""

        # Validate session
        user = self._auth_service.validate_session(token)

        if not user:
            return False

        # If no specific permissions required, just return session validity
        if not required_permissions:
            return True

        # Here you would integrate with authorization service to check permissions
        # For now, assume all authenticated users have basic permissions

        return True

    def _generate_session_token(self) -> str:
        """Gera um token de sesso seguro."""
        import secrets

        return secrets.token_urlsafe(32)
# Este diretrio contm os casos de uso (Use Cases) para o contexto delimitado de Usurio.
# Os casos de uso orquestram a lgica de domnio para realizar operaes especficas.
from shared.infrastructure.repositories.sqlalchemy_unit_of_work import (
    SQLAlchemyUnitOfWork,
)
from user.infrastructure.repositories.sqlalchemy_user_repository import (
    SqlAlchemyUserRepository,
)

from sqlalchemy.orm import Session

from user.infrastructure.repositories.sqlalchemy_user_session_repository import (
    SqlAlchemyUserSessionRepository,
)


class UserUnitOfWork(SQLAlchemyUnitOfWork):
    """Implementao da Unidade de Trabalho para o contexto de Usurio."""

    _repositories = {}

    def __init__(self, session: Session, repositories: list[str]):
        if "user" in repositories:
            self._repositories.update({"user": SqlAlchemyUserRepository(session)})
        if "user_session" in repositories:
            self._repositories.update(
                {"user_session": SqlAlchemyUserSessionRepository(session)}
            )

        super().__init__(session)
from shared.infrastructure.database.base import BaseModel as SQLBaseModel
from sqlalchemy import Column, String, Boolean, ForeignKey, DateTime, Text, Enum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import enum


class SessionStatusEnum(enum.Enum):
    ACTIVE = "active"
    EXPIRED = "expired"
    LOGGED_OUT = "logged_out"
    REVOKED = "revoked"


class UserModel(SQLBaseModel):
    """Modelo SQLAlchemy para a entidade Usurio."""

    __tablename__ = "users"

    email = Column(String(255), unique=True, nullable=False, index=True)
    name = Column(String(255), nullable=False)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    is_verified = Column(Boolean, default=False, nullable=False)
    last_login_at = Column(DateTime(timezone=True), nullable=True)


class UserSessionModel(SQLBaseModel):
    """Modelo SQLAlchemy para a entidade UserSession."""

    __tablename__ = "user_sessions"

    user_id = Column(
        UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True
    )
    session_token = Column(String(500), nullable=False, unique=True, index=True)
    status = Column(
        Enum(SessionStatusEnum),
        nullable=False,
        default=SessionStatusEnum.ACTIVE,
        index=True,
    )
    expires_at = Column(DateTime(timezone=True), nullable=False, index=True)
    ip_address = Column(String(45), nullable=True)
    user_agent = Column(Text, nullable=True)
    last_activity_at = Column(
        DateTime(timezone=True), nullable=False, server_default=func.now()
    )
    logout_at = Column(DateTime(timezone=True), nullable=True)
    _metadata = Column(Text, nullable=True)  # JSON string for additional session data
from datetime import datetime, timezone
import select
from typing import List, Optional
from uuid import UUID

from sqlalchemy import delete, update
from sqlalchemy.orm import Session
from user.domain.entities.user_session import UserSession
from user.domain.repositories.user_session_repository import UserSessionRepository
from user.infrastructure.database.models import SessionStatusEnum, UserSessionModel


class SqlAlchemyUserSessionRepository(UserSessionRepository):
    """Implementao SQLAlchemy de UserSessionRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, session_entity: UserSession) -> UserSession:
        """Salva uma entidade de sesso de usurio."""
        # Check if session exists
        existing = self.session.get(UserSessionModel, session_entity.id)

        if existing:
            # Update existing session
            existing.user_id = session_entity.user_id
            existing.session_token = session_entity.session_token
            existing.status = SessionStatusEnum(session_entity.status)
            existing.expires_at = session_entity.expires_at
            existing.ip_address = session_entity.ip_address
            existing.user_agent = session_entity.user_agent
            existing.last_activity_at = session_entity.last_activity_at
            existing.logout_at = session_entity.logout_at
            existing.metadata = session_entity.metadata
            existing.updated_at = datetime.now(timezone.utc)

            self.session.flush()
            return self._to_domain_entity(existing)
        else:
            # Create new session
            session_model = UserSessionModel(
                id=session_entity.id,
                user_id=session_entity.user_id,
                session_token=session_entity.session_token,
                status=SessionStatusEnum(session_entity.status),
                expires_at=session_entity.expires_at,
                ip_address=session_entity.ip_address,
                user_agent=session_entity.user_agent,
                last_activity_at=session_entity.last_activity_at,
                logout_at=session_entity.logout_at,
                metadata=session_entity.metadata,
                created_at=session_entity.created_at,
                updated_at=session_entity.updated_at,
            )

            self.session.add(session_model)
            self.session.flush()
            return self._to_domain_entity(session_model)

    def find_by_id(self, session_id: UUID) -> Optional[UserSession]:
        """Encontra uma sesso pelo ID."""
        result = self.session.execute(
            select(UserSessionModel).where(UserSessionModel.id == session_id)
        )
        session_model = result.scalar_one_or_none()

        if session_model:
            return self._to_domain_entity(session_model)
        return None

    def find_by_token(self, session_token: str) -> Optional[UserSession]:
        """Encontra uma sesso pelo token."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.session_token == session_token
            )
        )
        session_model = result.scalar_one_or_none()

        if session_model:
            return self._to_domain_entity(session_model)
        return None

    def find_active_by_user(self, user_id: UUID) -> List[UserSession]:
        """Encontra todas as sesses ativas para um usurio."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.user_id == user_id,
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
                UserSessionModel.expires_at > datetime.now(timezone.utc),
            )
        )
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def find_expired_sessions(self) -> List[UserSession]:
        """Encontra todas as sesses expiradas."""
        result = self.session.execute(
            select(UserSessionModel).where(
                UserSessionModel.expires_at <= datetime.now(timezone.utc),
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
            )
        )
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def find_user_sessions(
        self, user_id: UUID, status: Optional[str] = None, limit: int = 10
    ) -> List[UserSession]:
        """Encontra sesses para um usurio com filtro de status opcional."""
        query = select(UserSessionModel).where(UserSessionModel.user_id == user_id)

        if status:
            query = query.where(UserSessionModel.status == SessionStatusEnum(status))

        query = query.order_by(UserSessionModel.last_activity_at.desc()).limit(limit)

        result = self.session.execute(query)
        session_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in session_models]

    def delete(self, session_id: UUID) -> bool:
        """Exclui uma sesso (excluso fsica)."""
        result = self.session.execute(
            delete(UserSessionModel).where(UserSessionModel.id == session_id)
        )
        return result.rowcount > 0

    def delete_user_sessions(self, user_id: UUID) -> int:
        """Exclui todas as sesses de um usurio."""
        result = self.session.execute(
            delete(UserSessionModel).where(UserSessionModel.user_id == user_id)
        )
        return result.rowcount

    def revoke_session(self, session_id: UUID) -> bool:
        """Revoga uma sesso alterando seu status."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(UserSessionModel.id == session_id)
            .values(
                status=SessionStatusEnum.REVOKED,
                logout_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc),
            )
        )
        return result.rowcount > 0

    def revoke_user_sessions(
        self, user_id: UUID, exclude_session_id: Optional[UUID] = None
    ) -> int:
        """Revoga todas as sesses de um usurio, opcionalmente excluindo uma sesso."""
        query = update(UserSessionModel).where(
            UserSessionModel.user_id == user_id,
            UserSessionModel.status == SessionStatusEnum.ACTIVE,
        )

        if exclude_session_id:
            query = query.where(UserSessionModel.id != exclude_session_id)

        query = query.values(
            status=SessionStatusEnum.REVOKED,
            logout_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc),
        )

        result = self.session.execute(query)
        return result.rowcount

    def update_activity(self, session_id: UUID, activity_time: datetime) -> bool:
        """Atualiza o horrio da ltima atividade da sesso."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(UserSessionModel.id == session_id)
            .values(
                last_activity_at=activity_time, updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount > 0

    def cleanup_expired_sessions(self) -> int:
        """Limpa sesses expiradas atualizando seu status."""
        result = self.session.execute(
            update(UserSessionModel)
            .where(
                UserSessionModel.expires_at <= datetime.now(timezone.utc),
                UserSessionModel.status == SessionStatusEnum.ACTIVE,
            )
            .values(
                status=SessionStatusEnum.EXPIRED, updated_at=datetime.now(timezone.utc)
            )
        )
        return result.rowcount

    def _to_domain_entity(self, session_model: UserSessionModel) -> UserSession:
        """Converte o modelo SQLAlchemy para a entidade de domnio."""
        return UserSession(
            id=session_model.id,
            user_id=session_model.user_id,
            session_token=session_model.session_token,
            status=session_model.status.value,
            expires_at=session_model.expires_at,
            ip_address=session_model.ip_address,
            user_agent=session_model.user_agent,
            last_activity_at=session_model.last_activity_at,
            logout_at=session_model.logout_at,
            metadata=session_model.metadata,
            created_at=session_model.created_at,
            updated_at=session_model.updated_at,
        )
from datetime import datetime, timezone
import select
from typing import List, Optional
from uuid import UUID
from sqlalchemy import delete, update
from sqlalchemy.orm import Session
from user.domain.entities.user import User
from user.domain.repositories.user_repository import UserRepository
from user.domain.value_objects.email import Email
from user.domain.value_objects.password import Password
from user.infrastructure.database.models import UserModel


class SqlAlchemyUserRepository(UserRepository):
    """Implementao SQLAlchemy de UserRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, user: User) -> User:
        """Salva uma entidade de usurio."""
        # Check if user exists
        existing = self.session.get(UserModel, user.id)

        if existing:
            # Update existing user
            existing.email = str(user.email.value)
            existing.name = user.name
            existing.password_hash = user.password.hashed_value
            existing.is_active = user.is_active
            existing.is_verified = user.is_verified
            existing.last_login_at = user.last_login_at
            existing.updated_at = datetime.now(timezone.utc)

            self.session.flush()
            return self._to_domain_entity(existing)
        else:
            # Create new user
            user_model = UserModel(
                id=user.id,
                email=str(user.email.value),
                name=user.name,
                password_hash=user.password.hash,
                is_active=user.is_active,
                is_verified=user.is_verified,
                last_login_at=user.last_login_at,
                created_at=user.created_at,
                updated_at=user.updated_at,
            )

            self.session.add(user_model)
            self.session.flush()
            return self._to_domain_entity(user_model)

    def find_by_id(self, user_id: UUID) -> Optional[User]:
        """Encontra um usurio pelo ID."""
        result = self.session.execute(select(UserModel).where(UserModel.id == user_id))
        user_model = result.scalar_one_or_none()

        if user_model:
            return self._to_domain_entity(user_model)
        return None

    def find_by_email(self, email: Email) -> Optional[User]:
        """Encontra um usurio pelo email."""
        result = self.session.execute(
            select(UserModel).where(UserModel.email == str(email.value))
        )
        user_model = result.scalar_one_or_none()

        if user_model:
            return self._to_domain_entity(user_model)
        return None

    def find_active_users(self) -> List[User]:
        """Encontra todos os usurios ativos."""
        result = self.session.execute(select(UserModel).where(UserModel.is_active))
        user_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in user_models]

    def find_paginated(
        self,
        offset: int = 0,
        limit: int = 20,
        email_filter: Optional[str] = None,
        name_filter: Optional[str] = None,
        is_active: Optional[bool] = None,
    ) -> tuple[List[User], int]:
        """Encontra usurios com paginao e filtros."""
        query = select(UserModel)
        count_query = select(UserModel)

        # Apply filters
        if email_filter:
            query = query.where(UserModel.email.ilike(f"%{email_filter}%"))
            count_query = count_query.where(UserModel.email.ilike(f"%{email_filter}%"))

        if name_filter:
            query = query.where(UserModel.name.ilike(f"%{name_filter}%"))
            count_query = count_query.where(UserModel.name.ilike(f"%{name_filter}%"))

        if is_active is not None:
            query = query.where(UserModel.is_active == is_active)
            count_query = count_query.where(UserModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(UserModel.created_at.desc())
        result = self.session.execute(query)
        user_models = result.scalars().all()

        users = [self._to_domain_entity(model) for model in user_models]
        return users, total

    def delete(self, user_id: UUID) -> bool:
        """Exclui um usurio (excluso fsica)."""
        result = self.session.execute(delete(UserModel).where(UserModel.id == user_id))
        return result.rowcount > 0

    def exists_by_email(self, email: Email) -> bool:
        """Verifica se um usurio com o email fornecido existe."""
        result = self.session.execute(
            select(UserModel.id).where(UserModel.email == str(email.value))
        )
        return result.scalar_one_or_none() is not None

    def count_active_users(self) -> int:
        """Conta usurios ativos."""
        result = self.session.execute(select(UserModel).where(UserModel.is_active))
        return len(result.scalars().all())

    def find_users_created_after(self, date: datetime) -> List[User]:
        """Encontra usurios criados aps uma data especfica."""
        result = self.session.execute(
            select(UserModel).where(UserModel.created_at >= date)
        )
        user_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in user_models]

    def update_last_login(self, user_id: UUID, login_time: datetime) -> bool:
        """Atualiza o horrio do ltimo login do usurio."""
        result = self.session.execute(
            update(UserModel)
            .where(UserModel.id == user_id)
            .values(last_login_at=login_time, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def _to_domain_entity(self, user_model: UserModel) -> User:
        """Converte o modelo SQLAlchemy para a entidade de domnio."""
        return User(
            id=user_model.id,
            email=Email(user_model.email),
            name=user_model.name,
            password=Password.from_hash(user_model.password_hash),
            is_active=user_model.is_active,
            is_verified=user_model.is_verified,
            last_login_at=user_model.last_login_at,
            created_at=user_model.created_at,
            updated_at=user_model.updated_at,
        )
from .sqlalchemy_user_repository import SqlAlchemyUserRepository
from .sqlalchemy_user_session_repository import SqlAlchemyUserSessionRepository

__all__ = [
    "SqlAlchemyUserRepository",
    "SqlAlchemyUserSessionRepository"
]
from .repositories import SqlAlchemyUserRepository, SqlAlchemyUserSessionRepository

__all__ = [
    "SqlAlchemyUserRepository",
    "SqlAlchemyUserSessionRepository"
]
# Este diretrio contm o contexto delimitado (Bounded Context) de 'Usurio'.
# Ele  responsvel por toda a lgica de negcio relacionada a usurios, autenticao e sesses.
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Any
from pydantic import BaseModel, Field
from enum import Enum


class SubscriptionStatus(str, Enum):
    """Subscription status enumeration."""
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    CANCELLED = "cancelled"
    EXPIRED = "expired"
    TRIAL = "trial"
    SUSPENDED = "suspended"


class BillingCycle(str, Enum):
    """Billing cycle enumeration."""
    MONTHLY = "monthly"
    YEARLY = "yearly"
    QUARTERLY = "quarterly"
    WEEKLY = "weekly"


class Subscription(BaseModel):
    """Subscription domain entity."""
    
    id: UUID
    organization_id: UUID
    plan_id: UUID
    status: SubscriptionStatus
    billing_cycle: BillingCycle
    starts_at: datetime
    ends_at: Optional[datetime] = None
    next_billing_date: Optional[datetime] = None
    cancelled_at: Optional[datetime] = None
    metadata: dict[str, Any] = Field(default_factory=dict)
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    model_config = {"arbitrary_types_allowed": True}
    
    @classmethod
    def create(
        cls,
        organization_id: UUID,
        plan_id: UUID,
        billing_cycle: BillingCycle,
        starts_at: Optional[datetime] = None,
        ends_at: Optional[datetime] = None,
        metadata: Optional[dict[str, Any]] = None,
    ) -> "Subscription":
        """Create a new subscription."""
        now = datetime.utcnow()
        start_date = starts_at or now
        
        return cls(
            id=uuid4(),
            organization_id=organization_id,
            plan_id=plan_id,
            status=SubscriptionStatus.PENDING,
            billing_cycle=billing_cycle,
            starts_at=start_date,
            ends_at=ends_at,
            next_billing_date=cls._calculate_next_billing_date(start_date, billing_cycle),
            metadata=metadata or {},
            created_at=now,
        )
    
    def activate(self) -> "Subscription":
        """Activate the subscription."""
        if self.status == SubscriptionStatus.ACTIVE:
            return self
            
        return self.model_copy(
            update={
                "status": SubscriptionStatus.ACTIVE,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def cancel(self, cancellation_reason: Optional[str] = None) -> "Subscription":
        """Cancel the subscription."""
        cancelled_at = datetime.utcnow()
        metadata = self.metadata.copy()
        
        if cancellation_reason:
            metadata["cancellation_reason"] = cancellation_reason
            
        return self.model_copy(
            update={
                "status": SubscriptionStatus.CANCELLED,
                "cancelled_at": cancelled_at,
                "metadata": metadata,
                "updated_at": cancelled_at,
            }
        )
    
    def suspend(self, reason: Optional[str] = None) -> "Subscription":
        """Suspend the subscription."""
        metadata = self.metadata.copy()
        if reason:
            metadata["suspension_reason"] = reason
            
        return self.model_copy(
            update={
                "status": SubscriptionStatus.SUSPENDED,
                "metadata": metadata,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def reactivate(self) -> "Subscription":
        """Reactivate a suspended subscription."""
        if self.status not in [SubscriptionStatus.SUSPENDED, SubscriptionStatus.INACTIVE]:
            raise ValueError("Can only reactivate suspended or inactive subscriptions")
            
        metadata = self.metadata.copy()
        metadata.pop("suspension_reason", None)
        
        return self.model_copy(
            update={
                "status": SubscriptionStatus.ACTIVE,
                "metadata": metadata,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def expire(self) -> "Subscription":
        """Mark subscription as expired."""
        return self.model_copy(
            update={
                "status": SubscriptionStatus.EXPIRED,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def change_plan(self, new_plan_id: UUID) -> "Subscription":
        """Change the subscription plan."""
        return self.model_copy(
            update={
                "plan_id": new_plan_id,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def change_billing_cycle(self, new_billing_cycle: BillingCycle) -> "Subscription":
        """Change the billing cycle."""
        new_next_billing = self._calculate_next_billing_date(
            self.next_billing_date or datetime.utcnow(),
            new_billing_cycle
        )
        
        return self.model_copy(
            update={
                "billing_cycle": new_billing_cycle,
                "next_billing_date": new_next_billing,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def extend(self, new_end_date: datetime) -> "Subscription":
        """Extend the subscription end date."""
        if new_end_date <= (self.ends_at or datetime.utcnow()):
            raise ValueError("New end date must be after current end date")
            
        return self.model_copy(
            update={
                "ends_at": new_end_date,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def update_next_billing_date(self, next_billing_date: datetime) -> "Subscription":
        """Update the next billing date."""
        return self.model_copy(
            update={
                "next_billing_date": next_billing_date,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def add_metadata(self, key: str, value: Any) -> "Subscription":
        """Add or update metadata."""
        metadata = self.metadata.copy()
        metadata[key] = value
        
        return self.model_copy(
            update={
                "metadata": metadata,
                "updated_at": datetime.utcnow(),
            }
        )
    
    def is_active(self) -> bool:
        """Check if subscription is currently active."""
        if self.status != SubscriptionStatus.ACTIVE:
            return False
            
        if self.ends_at and datetime.utcnow() > self.ends_at:
            return False
            
        return True
    
    def is_expired(self) -> bool:
        """Check if subscription has expired."""
        if self.status == SubscriptionStatus.EXPIRED:
            return True
            
        if self.ends_at and datetime.utcnow() > self.ends_at:
            return True
            
        return False
    
    def is_cancelled(self) -> bool:
        """Check if subscription is cancelled."""
        return self.status == SubscriptionStatus.CANCELLED
    
    def is_trial(self) -> bool:
        """Check if subscription is a trial."""
        return self.status == SubscriptionStatus.TRIAL
    
    def days_until_expiry(self) -> Optional[int]:
        """Get days until subscription expires."""
        if not self.ends_at:
            return None
            
        delta = self.ends_at - datetime.utcnow()
        return max(0, delta.days)
    
    def days_since_created(self) -> int:
        """Get days since subscription was created."""
        delta = datetime.utcnow() - self.created_at
        return delta.days
    
    def can_be_cancelled(self) -> bool:
        """Check if subscription can be cancelled."""
        return self.status in [
            SubscriptionStatus.ACTIVE,
            SubscriptionStatus.TRIAL,
            SubscriptionStatus.SUSPENDED,
        ]
    
    def can_be_upgraded(self) -> bool:
        """Check if subscription can be upgraded."""
        return self.status in [
            SubscriptionStatus.ACTIVE,
            SubscriptionStatus.TRIAL,
        ]
    
    def can_be_downgraded(self) -> bool:
        """Check if subscription can be downgraded."""
        return self.status in [
            SubscriptionStatus.ACTIVE,
            SubscriptionStatus.TRIAL,
        ]
    
    @staticmethod
    def _calculate_next_billing_date(start_date: datetime, billing_cycle: BillingCycle) -> datetime:
        """Calculate next billing date based on billing cycle."""
        from datetime import timedelta
        
        if billing_cycle == BillingCycle.MONTHLY:
            # Approximate month as 30 days
            return start_date + timedelta(days=30)
        elif billing_cycle == BillingCycle.YEARLY:
            return start_date + timedelta(days=365)
        elif billing_cycle == BillingCycle.QUARTERLY:
            return start_date + timedelta(days=90)
        elif billing_cycle == BillingCycle.WEEKLY:
            return start_date + timedelta(weeks=1)
        else:
            raise ValueError(f"Unsupported billing cycle: {billing_cycle}")
from datetime import datetime, timezone
from uuid import UUID, uuid4
from typing import Optional, Dict, Any, List
from pydantic import BaseModel, field_validator


class PlanConfiguration(BaseModel):
    id: UUID
    plan_id: UUID
    api_keys: Dict[str, str]
    limits: Dict[str, int]
    enabled_features: List[str]
    custom_settings: Dict[str, Any]
    is_active: bool = True
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        plan_id: UUID,
        api_keys: Optional[Dict[str, str]] = None,
        limits: Optional[Dict[str, int]] = None,
        enabled_features: Optional[List[str]] = None,
        custom_settings: Optional[Dict[str, Any]] = None
    ) -> "PlanConfiguration":
        return cls(
            id=uuid4(),
            plan_id=plan_id,
            api_keys=api_keys or {},
            limits=limits or {},
            enabled_features=enabled_features or [],
            custom_settings=custom_settings or {},
            is_active=True,
            created_at=datetime.now(timezone.utc)
        )

    @classmethod
    def create_basic_configuration(cls, plan_id: UUID) -> "PlanConfiguration":
        """Create basic plan configuration."""
        return cls.create(
            plan_id=plan_id,
            limits={
                "monthly_messages": 10000,
                "monthly_api_calls": 50000,
                "storage_mb": 1000,
                "concurrent_sessions": 25
            },
            enabled_features=[
                "chat_iframe",
                "chat_whatsapp", 
                "webhook_support",
                "basic_analytics"
            ]
        )

    @classmethod
    def create_premium_configuration(cls, plan_id: UUID) -> "PlanConfiguration":
        """Create premium plan configuration."""
        return cls.create(
            plan_id=plan_id,
            api_keys={
                "whatsapp_api_key": "premium-whatsapp-key",
                "iframe_api_key": "premium-iframe-key"
            },
            limits={
                "monthly_messages": 100000,
                "monthly_api_calls": 500000,
                "storage_mb": 10000,
                "concurrent_sessions": 100,
                "webhook_endpoints": 10
            },
            enabled_features=[
                "chat_iframe",
                "chat_whatsapp",
                "custom_branding",
                "webhook_support",
                "advanced_analytics",
                "custom_css",
                "priority_support"
            ]
        )

    @classmethod
    def create_enterprise_configuration(cls, plan_id: UUID) -> "PlanConfiguration":
        """Create enterprise plan configuration."""
        return cls.create(
            plan_id=plan_id,
            api_keys={
                "whatsapp_api_key": "enterprise-whatsapp-key",
                "iframe_api_key": "enterprise-iframe-key",
                "sso_api_key": "enterprise-sso-key"
            },
            limits={
                "monthly_messages": -1,  # Unlimited
                "monthly_api_calls": -1,  # Unlimited
                "storage_mb": -1,  # Unlimited
                "concurrent_sessions": -1,  # Unlimited
                "webhook_endpoints": -1,  # Unlimited
                "custom_fields": -1  # Unlimited
            },
            enabled_features=[
                "chat_iframe",
                "chat_whatsapp",
                "custom_branding",
                "webhook_support",
                "advanced_analytics",
                "custom_css",
                "priority_support",
                "sso",
                "audit_logs",
                "white_label",
                "dedicated_support"
            ]
        )

    def update_api_key(self, key_name: str, api_key: str) -> "PlanConfiguration":
        """Update or add an API key."""
        new_api_keys = self.api_keys.copy()
        new_api_keys[key_name] = api_key
        
        return self.model_copy(update={
            "api_keys": new_api_keys,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_api_key(self, key_name: str) -> "PlanConfiguration":
        """Remove an API key."""
        new_api_keys = self.api_keys.copy()
        new_api_keys.pop(key_name, None)
        
        return self.model_copy(update={
            "api_keys": new_api_keys,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_limit(self, limit_name: str, value: int) -> "PlanConfiguration":
        """Update or add a limit."""
        new_limits = self.limits.copy()
        new_limits[limit_name] = value
        
        return self.model_copy(update={
            "limits": new_limits,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_limit(self, limit_name: str) -> "PlanConfiguration":
        """Remove a limit."""
        new_limits = self.limits.copy()
        new_limits.pop(limit_name, None)
        
        return self.model_copy(update={
            "limits": new_limits,
            "updated_at": datetime.now(timezone.utc)
        })

    def add_feature(self, feature: str) -> "PlanConfiguration":
        """Add a feature to enabled features."""
        if feature not in self.enabled_features:
            new_features = self.enabled_features.copy()
            new_features.append(feature)
            
            return self.model_copy(update={
                "enabled_features": new_features,
                "updated_at": datetime.now(timezone.utc)
            })
        
        return self

    def remove_feature(self, feature: str) -> "PlanConfiguration":
        """Remove a feature from enabled features."""
        if feature in self.enabled_features:
            new_features = self.enabled_features.copy()
            new_features.remove(feature)
            
            return self.model_copy(update={
                "enabled_features": new_features,
                "updated_at": datetime.now(timezone.utc)
            })
        
        return self

    def update_custom_setting(self, key: str, value: Any) -> "PlanConfiguration":
        """Update or add a custom setting."""
        new_settings = self.custom_settings.copy()
        new_settings[key] = value
        
        return self.model_copy(update={
            "custom_settings": new_settings,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_custom_setting(self, key: str) -> "PlanConfiguration":
        """Remove a custom setting."""
        new_settings = self.custom_settings.copy()
        new_settings.pop(key, None)
        
        return self.model_copy(update={
            "custom_settings": new_settings,
            "updated_at": datetime.now(timezone.utc)
        })

    def bulk_update(
        self,
        api_keys: Optional[Dict[str, str]] = None,
        limits: Optional[Dict[str, int]] = None,
        enabled_features: Optional[List[str]] = None,
        custom_settings: Optional[Dict[str, Any]] = None
    ) -> "PlanConfiguration":
        """Bulk update configuration."""
        updates = {"updated_at": datetime.now(timezone.utc)}
        
        if api_keys is not None:
            new_api_keys = self.api_keys.copy()
            new_api_keys.update(api_keys)
            updates["api_keys"] = new_api_keys
        
        if limits is not None:
            new_limits = self.limits.copy()
            new_limits.update(limits)
            updates["limits"] = new_limits
        
        if enabled_features is not None:
            updates["enabled_features"] = enabled_features
        
        if custom_settings is not None:
            new_settings = self.custom_settings.copy()
            new_settings.update(custom_settings)
            updates["custom_settings"] = new_settings
        
        return self.model_copy(update=updates)

    def activate(self) -> "PlanConfiguration":
        """Activate configuration."""
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.now(timezone.utc)
        })

    def deactivate(self) -> "PlanConfiguration":
        """Deactivate configuration."""
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.now(timezone.utc)
        })

    def get_api_key(self, key_name: str) -> Optional[str]:
        """Get specific API key."""
        return self.api_keys.get(key_name)

    def get_limit(self, limit_name: str) -> Optional[int]:
        """Get specific limit."""
        return self.limits.get(limit_name)

    def has_feature(self, feature: str) -> bool:
        """Check if feature is enabled."""
        return feature in self.enabled_features

    def get_custom_setting(self, key: str, default: Any = None) -> Any:
        """Get custom setting value."""
        return self.custom_settings.get(key, default)

    def is_limit_unlimited(self, limit_name: str) -> bool:
        """Check if limit is unlimited (-1)."""
        limit = self.get_limit(limit_name)
        return limit == -1 if limit is not None else False

    def has_required_api_keys_for_chat_whatsapp(self) -> bool:
        """Check if required API keys for WhatsApp are present."""
        return self.get_api_key("whatsapp_api_key") is not None

    def has_required_api_keys_for_chat_iframe(self) -> bool:
        """Check if required API keys for iframe chat are present."""
        return self.get_api_key("iframe_api_key") is not None

    def validate_configuration(self) -> tuple[bool, List[str]]:
        """Validate the configuration."""
        errors = []
        
        # Check for required API keys if features are enabled
        if self.has_feature("chat_whatsapp") and not self.has_required_api_keys_for_chat_whatsapp():
            errors.append("WhatsApp API key is required when chat_whatsapp feature is enabled")
        
        if self.has_feature("chat_iframe") and not self.has_required_api_keys_for_chat_iframe():
            errors.append("Iframe API key is required when chat_iframe feature is enabled")
        
        # Check for negative limits (except -1 for unlimited)
        for limit_name, limit_value in self.limits.items():
            if limit_value < -1:
                errors.append(f"Invalid limit value for {limit_name}: {limit_value}")
        
        return len(errors) == 0, errors

    def get_configuration_summary(self) -> Dict[str, Any]:
        """Get a summary of the configuration."""
        return {
            "id": str(self.id),
            "plan_id": str(self.plan_id),
            "api_keys_count": len(self.api_keys),
            "api_key_names": list(self.api_keys.keys()),
            "limits": self.limits,
            "enabled_features": self.enabled_features,
            "custom_settings_count": len(self.custom_settings),
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert configuration to dictionary (hiding sensitive API keys)."""
        return {
            "id": str(self.id),
            "plan_id": str(self.plan_id),
            "api_keys": {k: "***" for k in self.api_keys.keys()},  # Hide actual keys
            "limits": self.limits,
            "enabled_features": self.enabled_features,
            "custom_settings": self.custom_settings,
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
from datetime import datetime, timezone
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum

from ..value_objects.plan_name import PlanName
from ..value_objects.pricing import Pricing


class PlanType(str, Enum):
    BASIC = "basic"
    PREMIUM = "premium"
    ENTERPRISE = "enterprise"


class PlanStatus(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    DEPRECATED = "deprecated"


class Plan(BaseModel):
    id: UUID
    name: PlanName
    description: str
    plan_type: PlanType
    pricing: Pricing
    max_users: int
    max_organizations: int
    resources: Dict[str, Any]  # Associated resources configuration
    is_active: bool = True
    status: PlanStatus
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_public: bool = True

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @classmethod
    def create(
        cls,
        name: str,
        description: str,
        plan_type: PlanType,
        pricing: Pricing,
        max_users: int = 10,
        max_organizations: int = 1,
        resources: Optional[Dict[str, Any]] = None,
        is_public: bool = True
    ) -> "Plan":
        return cls(
            id=uuid4(),
            name=PlanName(value=name),
            description=description,
            plan_type=plan_type,
            pricing=pricing,
            max_users=max_users,
            max_organizations=max_organizations,
            resources=resources or cls._get_default_resources(plan_type),
            is_active=True,
            status=PlanStatus.ACTIVE,
            created_at=datetime.now(timezone.utc),
            is_public=is_public
        )

    @staticmethod
    def _get_default_resources(plan_type: PlanType) -> Dict[str, Any]:
        """Get default resources configuration based on plan type."""
        if plan_type == PlanType.BASIC:
            return {
                "chat_iframe": {
                    "enabled": True,
                    "api_keys": {"iframe_api_key": "basic-iframe-key"},
                    "limits": {"concurrent_sessions": 25, "domains_allowed": 3},
                    "enabled_features": ["basic_chat", "emoji_support"]
                },
                "chat_whatsapp": {
                    "enabled": True,
                    "api_keys": {"whatsapp_api_key": "basic-whatsapp-key"},
                    "limits": {"messages_per_day": 1000},
                    "enabled_features": ["auto_reply", "business_hours"]
                }
            }
        
        elif plan_type == PlanType.PREMIUM:
            return {
                "chat_iframe": {
                    "enabled": True,
                    "api_keys": {"iframe_api_key": "premium-iframe-key"},
                    "limits": {"concurrent_sessions": 100, "domains_allowed": 10},
                    "enabled_features": ["basic_chat", "emoji_support", "custom_css", "file_upload"]
                },
                "chat_whatsapp": {
                    "enabled": True,
                    "api_keys": {"whatsapp_api_key": "premium-whatsapp-key"},
                    "limits": {"messages_per_day": 5000},
                    "enabled_features": ["auto_reply", "business_hours", "template_messages", "media_messages"]
                }
            }
        
        elif plan_type == PlanType.ENTERPRISE:
            return {
                "chat_iframe": {
                    "enabled": True,
                    "api_keys": {"iframe_api_key": "enterprise-iframe-key"},
                    "limits": {"concurrent_sessions": -1, "domains_allowed": -1},  # Unlimited
                    "enabled_features": ["basic_chat", "emoji_support", "custom_css", "file_upload", "custom_branding", "white_label"]
                },
                "chat_whatsapp": {
                    "enabled": True,
                    "api_keys": {"whatsapp_api_key": "enterprise-whatsapp-key"},
                    "limits": {"messages_per_day": -1},  # Unlimited
                    "enabled_features": ["auto_reply", "business_hours", "template_messages", "media_messages", "bulk_messaging", "analytics"]
                }
            }
        
        return {}

    def update_description(self, description: str) -> "Plan":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_pricing(self, pricing: Pricing) -> "Plan":
        return self.model_copy(update={
            "pricing": pricing,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_resource(self, resource_type: str, config: Dict[str, Any]) -> "Plan":
        new_resources = self.resources.copy()
        new_resources[resource_type] = config
        
        return self.model_copy(update={
            "resources": new_resources,
            "updated_at": datetime.now(timezone.utc)
        })

    def enable_resource(self, resource_type: str) -> "Plan":
        new_resources = self.resources.copy()
        if resource_type in new_resources:
            new_resources[resource_type]["enabled"] = True
        
        return self.model_copy(update={
            "resources": new_resources,
            "updated_at": datetime.now(timezone.utc)
        })

    def disable_resource(self, resource_type: str) -> "Plan":
        new_resources = self.resources.copy()
        if resource_type in new_resources:
            new_resources[resource_type]["enabled"] = False
        
        return self.model_copy(update={
            "resources": new_resources,
            "updated_at": datetime.now(timezone.utc)
        })

    def deactivate(self) -> "Plan":
        return self.model_copy(update={
            "is_active": False,
            "status": PlanStatus.INACTIVE,
            "updated_at": datetime.now(timezone.utc)
        })

    def activate(self) -> "Plan":
        return self.model_copy(update={
            "is_active": True,
            "status": PlanStatus.ACTIVE,
            "updated_at": datetime.now(timezone.utc)
        })

    def deprecate(self) -> "Plan":
        return self.model_copy(update={
            "is_active": False,
            "status": PlanStatus.DEPRECATED,
            "is_public": False,
            "updated_at": datetime.now(timezone.utc)
        })

    def has_resource(self, resource_type: str) -> bool:
        resource = self.resources.get(resource_type, {})
        return resource.get("enabled", False)

    def get_resource_config(self, resource_type: str) -> Dict[str, Any]:
        return self.resources.get(resource_type, {})

    def get_resource_api_key(self, resource_type: str, key_name: str) -> Optional[str]:
        resource = self.get_resource_config(resource_type)
        api_keys = resource.get("api_keys", {})
        return api_keys.get(key_name)

    def get_resource_limit(self, resource_type: str, limit_name: str) -> Optional[int]:
        resource = self.get_resource_config(resource_type)
        limits = resource.get("limits", {})
        return limits.get(limit_name)

    def get_resource_features(self, resource_type: str) -> list:
        resource = self.get_resource_config(resource_type)
        return resource.get("enabled_features", [])

    def can_support_users(self, user_count: int) -> bool:
        return user_count <= self.max_users

    def can_support_organizations(self, org_count: int) -> bool:
        return org_count <= self.max_organizations

    def has_chat_whatsapp(self) -> bool:
        return self.has_resource("chat_whatsapp")

    def has_chat_iframe(self) -> bool:
        return self.has_resource("chat_iframe")

    def is_available_for_signup(self) -> bool:
        return self.status == PlanStatus.ACTIVE and self.is_public and self.is_active

    def validate_resource_requirements(self, resource_type: str) -> tuple[bool, list[str]]:
        """Validate if resource has required configuration."""
        errors = []
        resource = self.get_resource_config(resource_type)
        
        if not resource:
            errors.append(f"Resource {resource_type} not configured")
            return False, errors
        
        if not resource.get("enabled", False):
            errors.append(f"Resource {resource_type} is not enabled")
        
        # Validate required API keys
        api_keys = resource.get("api_keys", {})
        if resource_type == "chat_whatsapp" and not api_keys.get("whatsapp_api_key"):
            errors.append("WhatsApp API key is required")
        
        if resource_type == "chat_iframe" and not api_keys.get("iframe_api_key"):
            errors.append("Iframe API key is required")
        
        return len(errors) == 0, errors
from datetime import datetime, timedelta
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class UsagePeriod(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    YEARLY = "yearly"


class FeatureUsage(BaseModel):
    id: UUID
    organization_id: UUID
    feature_name: str
    usage_period: UsagePeriod
    period_start: datetime
    period_end: datetime
    current_usage: int
    limit_value: int  # -1 for unlimited
    metadata: Dict[str, Any]  # Additional usage data
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        organization_id: UUID,
        feature_name: str,
        usage_period: UsagePeriod,
        limit_value: int,
        current_usage: int = 0,
        metadata: Optional[Dict[str, Any]] = None
    ) -> "FeatureUsage":
        now = datetime.utcnow()
        period_start, period_end = cls._calculate_period_boundaries(now, usage_period)
        
        return cls(
            id=uuid4(),
            organization_id=organization_id,
            feature_name=feature_name,
            usage_period=usage_period,
            period_start=period_start,
            period_end=period_end,
            current_usage=current_usage,
            limit_value=limit_value,
            metadata=metadata or {},
            created_at=now
        )

    @staticmethod
    def _calculate_period_boundaries(date: datetime, period: UsagePeriod) -> tuple[datetime, datetime]:
        """Calculate period start and end dates."""
        if period == UsagePeriod.DAILY:
            start = date.replace(hour=0, minute=0, second=0, microsecond=0)
            end = start + timedelta(days=1) - timedelta(microseconds=1)
        
        elif period == UsagePeriod.WEEKLY:
            # Start on Monday
            days_since_monday = date.weekday()
            start = (date - timedelta(days=days_since_monday)).replace(
                hour=0, minute=0, second=0, microsecond=0
            )
            end = start + timedelta(days=7) - timedelta(microseconds=1)
        
        elif period == UsagePeriod.MONTHLY:
            start = date.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            if start.month == 12:
                end = start.replace(year=start.year + 1, month=1) - timedelta(microseconds=1)
            else:
                end = start.replace(month=start.month + 1) - timedelta(microseconds=1)
        
        elif period == UsagePeriod.YEARLY:
            start = date.replace(month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
            end = start.replace(year=start.year + 1) - timedelta(microseconds=1)
        
        else:
            raise ValueError(f"Unsupported usage period: {period}")
        
        return start, end

    def increment_usage(self, amount: int = 1, metadata_update: Optional[Dict[str, Any]] = None) -> "FeatureUsage":
        """Increment usage counter."""
        new_metadata = self.metadata.copy()
        if metadata_update:
            new_metadata.update(metadata_update)
        
        return self.model_copy(update={
            "current_usage": self.current_usage + amount,
            "metadata": new_metadata,
            "updated_at": datetime.utcnow()
        })

    def reset_usage(self) -> "FeatureUsage":
        """Reset usage counter for new period."""
        now = datetime.utcnow()
        period_start, period_end = self._calculate_period_boundaries(now, self.usage_period)
        
        return self.model_copy(update={
            "current_usage": 0,
            "period_start": period_start,
            "period_end": period_end,
            "metadata": {},
            "updated_at": now
        })

    def update_limit(self, new_limit: int) -> "FeatureUsage":
        """Update usage limit."""
        return self.model_copy(update={
            "limit_value": new_limit,
            "updated_at": datetime.utcnow()
        })

    def is_unlimited(self) -> bool:
        """Check if feature has unlimited usage."""
        return self.limit_value == -1

    def is_limit_exceeded(self) -> bool:
        """Check if usage limit is exceeded."""
        if self.is_unlimited():
            return False
        
        return self.current_usage >= self.limit_value

    def is_limit_near(self, threshold_percent: float = 0.8) -> bool:
        """Check if usage is near the limit."""
        if self.is_unlimited():
            return False
        
        threshold = int(self.limit_value * threshold_percent)
        return self.current_usage >= threshold

    def get_usage_percentage(self) -> float:
        """Get usage as percentage of limit."""
        if self.is_unlimited():
            return 0.0
        
        if self.limit_value == 0:
            return 100.0 if self.current_usage > 0 else 0.0
        
        return (self.current_usage / self.limit_value) * 100

    def get_remaining_usage(self) -> int:
        """Get remaining usage before hitting limit."""
        if self.is_unlimited():
            return -1  # Unlimited
        
        return max(0, self.limit_value - self.current_usage)

    def is_current_period(self) -> bool:
        """Check if this record is for the current period."""
        now = datetime.utcnow()
        return self.period_start <= now <= self.period_end

    def is_period_expired(self) -> bool:
        """Check if the usage period has expired."""
        return datetime.utcnow() > self.period_end

    def days_until_reset(self) -> int:
        """Get days until usage resets."""
        if self.is_period_expired():
            return 0
        
        delta = self.period_end - datetime.utcnow()
        return max(0, delta.days + 1)  # +1 to include current day

    def can_use_feature(self, amount: int = 1) -> tuple[bool, str]:
        """Check if feature can be used given the amount."""
        if self.is_period_expired():
            return False, "Usage period has expired"
        
        if self.is_unlimited():
            return True, "Feature has unlimited usage"
        
        if self.current_usage + amount > self.limit_value:
            remaining = self.get_remaining_usage()
            return False, f"Would exceed limit. Remaining: {remaining}, Requested: {amount}"
        
        return True, "Usage within limits"

    def get_usage_summary(self) -> Dict[str, Any]:
        """Get comprehensive usage summary."""
        return {
            "feature_name": self.feature_name,
            "current_usage": self.current_usage,
            "limit_value": self.limit_value,
            "is_unlimited": self.is_unlimited(),
            "usage_percentage": self.get_usage_percentage(),
            "remaining_usage": self.get_remaining_usage(),
            "is_limit_exceeded": self.is_limit_exceeded(),
            "is_limit_near": self.is_limit_near(),
            "period_start": self.period_start.isoformat(),
            "period_end": self.period_end.isoformat(),
            "days_until_reset": self.days_until_reset(),
            "is_current_period": self.is_current_period()
        }
from datetime import datetime, timedelta
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class SubscriptionStatus(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    SUSPENDED = "suspended"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class BillingCycle(str, Enum):
    MONTHLY = "monthly"
    YEARLY = "yearly"
    LIFETIME = "lifetime"


class OrganizationPlan(BaseModel):
    id: UUID
    organization_id: UUID
    plan_id: UUID
    status: SubscriptionStatus
    billing_cycle: BillingCycle
    feature_overrides: Dict[str, Any]  # Custom feature configurations
    limit_overrides: Dict[str, int]    # Custom limits
    started_at: datetime
    expires_at: Optional[datetime] = None
    cancelled_at: Optional[datetime] = None
    suspended_at: Optional[datetime] = None
    trial_ends_at: Optional[datetime] = None
    auto_renew: bool = True
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        organization_id: UUID,
        plan_id: UUID,
        billing_cycle: BillingCycle = BillingCycle.MONTHLY,
        trial_days: int = 0,
        feature_overrides: Optional[Dict[str, Any]] = None,
        limit_overrides: Optional[Dict[str, int]] = None
    ) -> "OrganizationPlan":
        now = datetime.utcnow()
        
        # Calculate expiration based on billing cycle
        if billing_cycle == BillingCycle.MONTHLY:
            expires_at = now + timedelta(days=30)
        elif billing_cycle == BillingCycle.YEARLY:
            expires_at = now + timedelta(days=365)
        else:  # LIFETIME
            expires_at = None
        
        # Set trial period if specified
        trial_ends_at = None
        if trial_days > 0:
            trial_ends_at = now + timedelta(days=trial_days)
        
        return cls(
            id=uuid4(),
            organization_id=organization_id,
            plan_id=plan_id,
            status=SubscriptionStatus.ACTIVE,
            billing_cycle=billing_cycle,
            feature_overrides=feature_overrides or {},
            limit_overrides=limit_overrides or {},
            started_at=now,
            expires_at=expires_at,
            trial_ends_at=trial_ends_at,
            auto_renew=True,
            created_at=now
        )

    def renew(self, periods: int = 1) -> "OrganizationPlan":
        """Renew subscription for specified periods."""
        if self.billing_cycle == BillingCycle.LIFETIME:
            return self  # Lifetime subscriptions don't need renewal
        
        if not self.expires_at:
            raise ValueError("Cannot renew subscription without expiration date")
        
        days_per_period = 30 if self.billing_cycle == BillingCycle.MONTHLY else 365
        new_expires_at = self.expires_at + timedelta(days=days_per_period * periods)
        
        return self.model_copy(update={
            "expires_at": new_expires_at,
            "status": SubscriptionStatus.ACTIVE,
            "cancelled_at": None,
            "suspended_at": None,
            "updated_at": datetime.utcnow()
        })

    def cancel(self, immediate: bool = False) -> "OrganizationPlan":
        """Cancel subscription."""
        now = datetime.utcnow()
        
        updates = {
            "cancelled_at": now,
            "auto_renew": False,
            "updated_at": now
        }
        
        if immediate:
            updates["status"] = SubscriptionStatus.CANCELLED
            updates["expires_at"] = now
        
        return self.model_copy(update=updates)

    def suspend(self, reason: str = "") -> "OrganizationPlan":
        """Suspend subscription."""
        return self.model_copy(update={
            "status": SubscriptionStatus.SUSPENDED,
            "suspended_at": datetime.utcnow(),
            "updated_at": datetime.utcnow()
        })

    def reactivate(self) -> "OrganizationPlan":
        """Reactivate suspended subscription."""
        if self.status != SubscriptionStatus.SUSPENDED:
            raise ValueError("Can only reactivate suspended subscriptions")
        
        return self.model_copy(update={
            "status": SubscriptionStatus.ACTIVE,
            "suspended_at": None,
            "updated_at": datetime.utcnow()
        })

    def set_feature_override(self, feature_name: str, value: Any) -> "OrganizationPlan":
        """Set custom feature configuration."""
        new_overrides = self.feature_overrides.copy()
        new_overrides[feature_name] = value
        
        return self.model_copy(update={
            "feature_overrides": new_overrides,
            "updated_at": datetime.utcnow()
        })

    def remove_feature_override(self, feature_name: str) -> "OrganizationPlan":
        """Remove custom feature configuration."""
        new_overrides = self.feature_overrides.copy()
        new_overrides.pop(feature_name, None)
        
        return self.model_copy(update={
            "feature_overrides": new_overrides,
            "updated_at": datetime.utcnow()
        })

    def set_limit_override(self, limit_name: str, value: int) -> "OrganizationPlan":
        """Set custom limit."""
        new_overrides = self.limit_overrides.copy()
        new_overrides[limit_name] = value
        
        return self.model_copy(update={
            "limit_overrides": new_overrides,
            "updated_at": datetime.utcnow()
        })

    def remove_limit_override(self, limit_name: str) -> "OrganizationPlan":
        """Remove custom limit."""
        new_overrides = self.limit_overrides.copy()
        new_overrides.pop(limit_name, None)
        
        return self.model_copy(update={
            "limit_overrides": new_overrides,
            "updated_at": datetime.utcnow()
        })

    def is_active(self) -> bool:
        """Check if subscription is currently active."""
        return self.status == SubscriptionStatus.ACTIVE

    def is_expired(self) -> bool:
        """Check if subscription has expired."""
        if not self.expires_at:
            return False  # Lifetime subscriptions don't expire
        
        return datetime.utcnow() > self.expires_at

    def is_in_trial(self) -> bool:
        """Check if subscription is in trial period."""
        if not self.trial_ends_at:
            return False
        
        return datetime.utcnow() <= self.trial_ends_at

    def is_cancelled(self) -> bool:
        """Check if subscription is cancelled."""
        return self.cancelled_at is not None

    def is_suspended(self) -> bool:
        """Check if subscription is suspended."""
        return self.status == SubscriptionStatus.SUSPENDED

    def days_until_expiry(self) -> Optional[int]:
        """Get days until subscription expires."""
        if not self.expires_at:
            return None
        
        delta = self.expires_at - datetime.utcnow()
        return max(0, delta.days)

    def days_in_trial_remaining(self) -> Optional[int]:
        """Get days remaining in trial period."""
        if not self.trial_ends_at:
            return None
        
        delta = self.trial_ends_at - datetime.utcnow()
        return max(0, delta.days)

    def needs_renewal(self, days_ahead: int = 7) -> bool:
        """Check if subscription needs renewal within specified days."""
        if not self.expires_at or not self.auto_renew:
            return False
        
        renewal_date = datetime.utcnow() + timedelta(days=days_ahead)
        return renewal_date >= self.expires_at

    def get_effective_feature_value(self, feature_name: str, plan_default: Any) -> Any:
        """Get effective feature value considering overrides."""
        return self.feature_overrides.get(feature_name, plan_default)

    def get_effective_limit_value(self, limit_name: str, plan_default: int) -> int:
        """Get effective limit value considering overrides."""
        return self.limit_overrides.get(limit_name, plan_default)
from .plan import Plan, PlanType
from .plan_feature import PlanFeature
from .plan_resource import PlanResource, PlanResourceType
from .plan_configuration import PlanConfiguration
from .organization_plan import OrganizationPlan
from .feature_usage import FeatureUsage
from .subscription import Subscription, SubscriptionStatus, BillingCycle

__all__ = [
    "Plan", "PlanType",
    "PlanFeature", 
    "PlanResource", "PlanResourceType",
    "PlanConfiguration",
    "OrganizationPlan", 
    "FeatureUsage",
    "Subscription", "SubscriptionStatus", "BillingCycle"
]
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class FeatureType(str, Enum):
    BOOLEAN = "boolean"
    NUMERIC = "numeric"
    STRING = "string"
    OBJECT = "object"


class FeatureCategory(str, Enum):
    COMMUNICATION = "communication"
    INTEGRATION = "integration"
    ANALYTICS = "analytics"
    SECURITY = "security"
    CUSTOMIZATION = "customization"
    SUPPORT = "support"


class PlanFeature(BaseModel):
    id: UUID
    name: str
    display_name: str
    description: str
    feature_type: FeatureType
    category: FeatureCategory
    default_value: Any
    configuration_schema: Dict[str, Any]  # JSON schema for feature configuration
    is_system_feature: bool = False
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool = True

    model_config = {"frozen": True}

    @classmethod
    def create(
        cls,
        name: str,
        display_name: str,
        description: str,
        feature_type: FeatureType,
        category: FeatureCategory,
        default_value: Any = None,
        configuration_schema: Optional[Dict[str, Any]] = None,
        is_system_feature: bool = False
    ) -> "PlanFeature":
        return cls(
            id=uuid4(),
            name=name,
            display_name=display_name,
            description=description,
            feature_type=feature_type,
            category=category,
            default_value=default_value,
            configuration_schema=configuration_schema or {},
            is_system_feature=is_system_feature,
            created_at=datetime.utcnow(),
            is_active=True
        )

    @classmethod
    def create_chat_whatsapp_feature(cls) -> "PlanFeature":
        """Create the chat_whatsapp feature."""
        return cls.create(
            name="chat_whatsapp",
            display_name="WhatsApp Chat Integration",
            description="Enable WhatsApp chat integration for customer communication",
            feature_type=FeatureType.OBJECT,
            category=FeatureCategory.COMMUNICATION,
            default_value=False,
            configuration_schema={
                "type": "object",
                "properties": {
                    "enabled": {"type": "boolean"},
                    "phone_number": {"type": "string"},
                    "webhook_url": {"type": "string"},
                    "auto_reply": {"type": "boolean"},
                    "business_hours": {
                        "type": "object",
                        "properties": {
                            "enabled": {"type": "boolean"},
                            "start_time": {"type": "string"},
                            "end_time": {"type": "string"},
                            "timezone": {"type": "string"}
                        }
                    }
                }
            },
            is_system_feature=True
        )

    @classmethod
    def create_chat_iframe_feature(cls) -> "PlanFeature":
        """Create the chat_iframe feature."""
        return cls.create(
            name="chat_iframe",
            display_name="Embeddable Chat Widget",
            description="Embed chat widget on websites using iframe",
            feature_type=FeatureType.OBJECT,
            category=FeatureCategory.COMMUNICATION,
            default_value=False,
            configuration_schema={
                "type": "object",
                "properties": {
                    "enabled": {"type": "boolean"},
                    "theme": {
                        "type": "object",
                        "properties": {
                            "primary_color": {"type": "string"},
                            "secondary_color": {"type": "string"},
                            "font_family": {"type": "string"},
                            "border_radius": {"type": "number"}
                        }
                    },
                    "position": {
                        "type": "string",
                        "enum": ["bottom-right", "bottom-left", "top-right", "top-left"]
                    },
                    "welcome_message": {"type": "string"},
                    "offline_message": {"type": "string"},
                    "allowed_domains": {
                        "type": "array",
                        "items": {"type": "string"}
                    }
                }
            },
            is_system_feature=True
        )

    def update_description(self, description: str) -> "PlanFeature":
        return self.model_copy(update={
            "description": description,
            "updated_at": datetime.utcnow()
        })

    def update_default_value(self, default_value: Any) -> "PlanFeature":
        return self.model_copy(update={
            "default_value": default_value,
            "updated_at": datetime.utcnow()
        })

    def update_configuration_schema(self, schema: Dict[str, Any]) -> "PlanFeature":
        return self.model_copy(update={
            "configuration_schema": schema,
            "updated_at": datetime.utcnow()
        })

    def deactivate(self) -> "PlanFeature":
        if self.is_system_feature:
            raise ValueError("Cannot deactivate system features")
        
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.utcnow()
        })

    def activate(self) -> "PlanFeature":
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.utcnow()
        })

    def validate_configuration(self, config: Any) -> tuple[bool, str]:
        """Validate a configuration against the schema."""
        # Basic validation - in a real implementation, use jsonschema library
        if self.feature_type == FeatureType.BOOLEAN and not isinstance(config, bool):
            return False, "Configuration must be a boolean value"
        
        if self.feature_type == FeatureType.NUMERIC and not isinstance(config, (int, float)):
            return False, "Configuration must be a numeric value"
        
        if self.feature_type == FeatureType.STRING and not isinstance(config, str):
            return False, "Configuration must be a string value"
        
        if self.feature_type == FeatureType.OBJECT and not isinstance(config, dict):
            return False, "Configuration must be an object"
        
        return True, "Configuration is valid"

    def get_typed_default_value(self) -> Any:
        """Get default value with proper typing."""
        if self.feature_type == FeatureType.BOOLEAN:
            return bool(self.default_value) if self.default_value is not None else False
        elif self.feature_type == FeatureType.NUMERIC:
            return self.default_value if self.default_value is not None else 0
        elif self.feature_type == FeatureType.STRING:
            return str(self.default_value) if self.default_value is not None else ""
        elif self.feature_type == FeatureType.OBJECT:
            return self.default_value if self.default_value is not None else {}
        
        return self.default_value

    def is_chat_feature(self) -> bool:
        """Check if this is a chat-related feature."""
        return self.name in ["chat_whatsapp", "chat_iframe"] or self.category == FeatureCategory.COMMUNICATION
from datetime import datetime, timezone
from uuid import UUID, uuid4
from typing import Optional, Dict, Any
from pydantic import BaseModel
from enum import Enum


class PlanResourceType(str, Enum):
    CHAT_WHATSAPP = "chat_whatsapp"
    CHAT_IFRAME = "chat_iframe"
    CUSTOM = "custom"


class PlanResource(BaseModel):
    id: UUID
    plan_id: UUID
    resource_type: PlanResourceType
    configuration: Dict[str, Any]
    is_active: bool = True
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = {"frozen": True}

    @property
    def is_enabled(self) -> bool:
        """Compatibility property for is_enabled (maps to is_active)."""
        return self.is_active

    @is_enabled.setter
    def is_enabled(self, value: bool) -> None:
        """Compatibility setter for is_enabled (maps to is_active)."""
        # Note: This won't work with frozen=True, but we provide it for interface compatibility
        # The actual way to update would be through model_copy
        pass

    @classmethod
    def create(
        cls,
        plan_id: UUID,
        resource_type: PlanResourceType,
        configuration: Dict[str, Any]
    ) -> "PlanResource":
        return cls(
            id=uuid4(),
            plan_id=plan_id,
            resource_type=resource_type,
            configuration=configuration,
            is_active=True,
            created_at=datetime.now(timezone.utc)
        )

    @classmethod
    def create_resource(
        cls,
        plan_id: UUID,
        resource_type: PlanResourceType,
        configuration: Dict[str, Any],
        is_enabled: bool = True
    ) -> "PlanResource":
        """Create resource with is_enabled parameter for compatibility."""
        return cls.create(
            plan_id=plan_id,
            resource_type=resource_type,
            configuration=configuration
        ).model_copy(update={"is_active": is_enabled})

    @classmethod
    def create_whatsapp_resource(
        cls,
        plan_id: UUID,
        api_key: str,
        messages_per_day: int = 1000,
        webhook_url: Optional[str] = None,
        auto_reply: bool = True
    ) -> "PlanResource":
        """Create WhatsApp chat resource with standard configuration."""
        configuration = {
            "api_keys": {
                "whatsapp_api_key": api_key
            },
            "limits": {
                "messages_per_day": messages_per_day
            },
            "features": {
                "webhook_url": webhook_url,
                "auto_reply": auto_reply,
                "business_hours": True,
                "template_messages": True
            }
        }
        
        return cls.create(
            plan_id=plan_id,
            resource_type=PlanResourceType.CHAT_WHATSAPP,
            configuration=configuration
        )

    @classmethod
    def create_iframe_resource(
        cls,
        plan_id: UUID,
        api_key: str,
        concurrent_sessions: int = 50,
        custom_css: bool = False,
        custom_branding: bool = False
    ) -> "PlanResource":
        """Create iframe chat resource with standard configuration."""
        configuration = {
            "api_keys": {
                "iframe_api_key": api_key
            },
            "limits": {
                "concurrent_sessions": concurrent_sessions,
                "domains_allowed": 10
            },
            "enabled_features": [
                "basic_chat",
                "file_upload",
                "emoji_support"
            ]
        }
        
        if custom_css:
            configuration["enabled_features"].append("custom_css")
        
        if custom_branding:
            configuration["enabled_features"].extend(["custom_branding", "logo_upload"])
        
        return cls.create(
            plan_id=plan_id,
            resource_type=PlanResourceType.CHAT_IFRAME,
            configuration=configuration
        )

    def update_configuration(self, new_configuration: Dict[str, Any]) -> "PlanResource":
        """Update resource configuration."""
        merged_config = self.configuration.copy()
        merged_config.update(new_configuration)
        
        return self.model_copy(update={
            "configuration": merged_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_api_key(self, key_name: str, api_key: str) -> "PlanResource":
        """Update specific API key in configuration."""
        new_config = self.configuration.copy()
        if "api_keys" not in new_config:
            new_config["api_keys"] = {}
        
        new_config["api_keys"][key_name] = api_key
        
        return self.model_copy(update={
            "configuration": new_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def update_limit(self, limit_name: str, value: int) -> "PlanResource":
        """Update specific limit in configuration."""
        new_config = self.configuration.copy()
        if "limits" not in new_config:
            new_config["limits"] = {}
        
        new_config["limits"][limit_name] = value
        
        return self.model_copy(update={
            "configuration": new_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def add_enabled_feature(self, feature: str) -> "PlanResource":
        """Add feature to enabled features list."""
        new_config = self.configuration.copy()
        if "enabled_features" not in new_config:
            new_config["enabled_features"] = []
        
        if feature not in new_config["enabled_features"]:
            new_config["enabled_features"].append(feature)
        
        return self.model_copy(update={
            "configuration": new_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def remove_enabled_feature(self, feature: str) -> "PlanResource":
        """Remove feature from enabled features list."""
        new_config = self.configuration.copy()
        if "enabled_features" in new_config and feature in new_config["enabled_features"]:
            new_config["enabled_features"].remove(feature)
        
        return self.model_copy(update={
            "configuration": new_config,
            "updated_at": datetime.now(timezone.utc)
        })

    def activate(self) -> "PlanResource":
        """Activate resource."""
        return self.model_copy(update={
            "is_active": True,
            "updated_at": datetime.now(timezone.utc)
        })

    def deactivate(self) -> "PlanResource":
        """Deactivate resource."""
        return self.model_copy(update={
            "is_active": False,
            "updated_at": datetime.now(timezone.utc)
        })

    def get_api_key(self, key_name: str) -> Optional[str]:
        """Get specific API key from configuration."""
        api_keys = self.configuration.get("api_keys", {})
        return api_keys.get(key_name)

    def get_limit(self, limit_name: str) -> Optional[int]:
        """Get specific limit from configuration."""
        limits = self.configuration.get("limits", {})
        return limits.get(limit_name)

    def get_enabled_features(self) -> list[str]:
        """Get list of enabled features."""
        return self.configuration.get("enabled_features", [])

    def has_feature(self, feature: str) -> bool:
        """Check if specific feature is enabled."""
        return feature in self.get_enabled_features()

    def is_valid_configuration(self) -> tuple[bool, list[str]]:
        """Validate resource configuration."""
        errors = []
        
        # Validate based on resource type
        if self.resource_type == PlanResourceType.CHAT_WHATSAPP:
            if not self.get_api_key("whatsapp_api_key"):
                errors.append("WhatsApp API key is required")
            
            if not self.get_limit("messages_per_day"):
                errors.append("Messages per day limit is required")
        
        elif self.resource_type == PlanResourceType.CHAT_IFRAME:
            if not self.get_api_key("iframe_api_key"):
                errors.append("Iframe API key is required")
            
            if not self.get_limit("concurrent_sessions"):
                errors.append("Concurrent sessions limit is required")
        
        return len(errors) == 0, errors

    def get_resource_summary(self) -> Dict[str, Any]:
        """Get summary of resource configuration."""
        return {
            "id": str(self.id),
            "resource_type": self.resource_type.value,
            "is_active": self.is_active,
            "api_keys_count": len(self.configuration.get("api_keys", {})),
            "limits": self.configuration.get("limits", {}),
            "enabled_features": self.get_enabled_features(),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
from typing import Optional, Dict, Any, List, Tuple
from uuid import UUID

from ..entities.plan import Plan
from ..entities.plan_resource import PlanResource, PlanResourceType
from ..entities.plan_configuration import PlanConfiguration
from ..repositories.plan_repository import PlanRepository
from ..repositories.plan_resource_repository import PlanResourceRepository
from ..repositories.plan_configuration_repository import PlanConfigurationRepository
from ..repositories.organization_plan_repository import OrganizationPlanRepository


class PlanAuthorizationService:
    """Domain service for integrating plans with authorization system."""

    def __init__(
        self,
        plan_repository: PlanRepository,
        resource_repository: PlanResourceRepository,
        configuration_repository: PlanConfigurationRepository,
        org_plan_repository: OrganizationPlanRepository,
    ):
        self._plan_repository = plan_repository
        self._resource_repository = resource_repository
        self._configuration_repository = configuration_repository
        self._org_plan_repository = org_plan_repository

    def validate_organization_resource_access(
        self, organization_id: UUID, resource_type: str
    ) -> Tuple[bool, str, Optional[Dict[str, Any]]]:
        """Validate if organization has access to a specific resource type."""

        # Get organization's current plan
        org_plan = self._org_plan_repository.get_by_organization_id(organization_id)
        if not org_plan or not org_plan.is_active():
            return False, "Organization has no active plan", None

        # Get plan details
        plan = self._plan_repository.get_by_id(org_plan.plan_id)
        if not plan or not plan.is_active:
            return False, "Plan is not active", None

        # Check if plan has the resource
        if not plan.has_resource(resource_type):
            return (
                False,
                f"Resource '{resource_type}' not available in current plan",
                None,
            )

        # Get resource configuration
        resource_config = plan.get_resource_config(resource_type)

        # Validate resource configuration
        is_valid, errors = plan.validate_resource_requirements(resource_type)
        if not is_valid:
            return False, f"Resource configuration invalid: {', '.join(errors)}", None

        # Apply organization-specific overrides
        effective_config = self._apply_organization_overrides(resource_config, org_plan)

        return True, "Access granted", effective_config

    def validate_api_key_requirements(
        self, organization_id: UUID, resource_type: str
    ) -> Tuple[bool, str, Optional[str]]:
        """Validate API key requirements for resource access."""

        has_access, message, config = self.validate_organization_resource_access(
            organization_id, resource_type
        )

        if not has_access:
            return False, message, None

        # Determine required API key based on resource type
        required_key = None
        if resource_type == "chat_whatsapp":
            required_key = "whatsapp_api_key"
        elif resource_type == "chat_iframe":
            required_key = "iframe_api_key"

        if not required_key:
            return True, "No API key required", None

        # Check if API key is configured
        api_keys = config.get("api_keys", {}) if config else {}
        api_key_value = api_keys.get(required_key)

        if not api_key_value:
            return False, f"Required API key '{required_key}' not configured", None

        return True, "API key validation passed", api_key_value

    def get_organization_resource_limits(
        self, organization_id: UUID, resource_type: str
    ) -> Optional[Dict[str, int]]:
        """Get effective resource limits for organization."""

        has_access, _, config = self.validate_organization_resource_access(
            organization_id, resource_type
        )

        if not has_access or not config:
            return None

        return config.get("limits", {})

    def get_organization_enabled_features(
        self, organization_id: UUID, resource_type: str
    ) -> List[str]:
        """Get enabled features for organization's resource."""

        has_access, _, config = self.validate_organization_resource_access(
            organization_id, resource_type
        )

        if not has_access or not config:
            return []

        return config.get("enabled_features", [])

    def can_organization_use_feature(
        self, organization_id: UUID, resource_type: str, feature_name: str
    ) -> bool:
        """Check if organization can use a specific feature."""

        enabled_features = self.get_organization_enabled_features(
            organization_id, resource_type
        )

        return feature_name in enabled_features

    def validate_resource_usage_limits(
        self,
        organization_id: UUID,
        resource_type: str,
        usage_type: str,
        requested_amount: int = 1,
    ) -> Tuple[bool, str, Optional[int]]:
        """Validate if organization can use resource within limits."""

        limits = self.get_organization_resource_limits(organization_id, resource_type)

        if not limits:
            return False, "No resource limits found", None

        limit_value = limits.get(usage_type)

        if limit_value is None:
            return True, "No limit set for usage type", None

        if limit_value == -1:  # Unlimited
            return True, "Unlimited usage allowed", -1

        # Here you would typically check current usage against the limit
        # For now, we'll assume the requested amount is within limits
        if requested_amount <= limit_value:
            return True, "Within usage limits", limit_value - requested_amount

        return False, f"Would exceed limit of {limit_value}", limit_value

    def get_organization_plan_summary(
        self, organization_id: UUID
    ) -> Optional[Dict[str, Any]]:
        """Get comprehensive plan summary for organization."""

        org_plan = self._org_plan_repository.get_by_organization_id(organization_id)
        if not org_plan:
            return None

        plan = self._plan_repository.get_by_id(org_plan.plan_id)
        if not plan:
            return None

        # Get all resources for the plan
        resources_summary = {}
        for resource_type in plan.resources.keys():
            has_access, message, config = self.validate_organization_resource_access(
                organization_id, resource_type
            )

            resources_summary[resource_type] = {
                "has_access": has_access,
                "message": message,
                "configuration": config,
                "enabled_features": config.get("enabled_features", [])
                if config
                else [],
                "limits": config.get("limits", {}) if config else {},
            }

        return {
            "organization_id": str(organization_id),
            "plan": {
                "id": str(plan.id),
                "name": plan.name.value,
                "type": plan.plan_type.value,
                "is_active": plan.is_active,
            },
            "subscription": {
                "id": str(org_plan.id),
                "status": org_plan.status.value,
                "is_active": org_plan.is_active(),
                "expires_at": org_plan.expires_at.isoformat()
                if org_plan.expires_at
                else None,
            },
            "resources": resources_summary,
        }

    def _apply_organization_overrides(
        self, base_config: Dict[str, Any], org_plan
    ) -> Dict[str, Any]:
        """Apply organization-specific configuration overrides."""

        effective_config = base_config.copy()

        # Apply feature overrides from organization plan
        if org_plan.feature_overrides:
            for key, value in org_plan.feature_overrides.items():
                if key in effective_config:
                    if isinstance(value, dict) and isinstance(
                        effective_config[key], dict
                    ):
                        effective_config[key].update(value)
                    else:
                        effective_config[key] = value

        # Apply limit overrides from organization plan
        if org_plan.limit_overrides:
            if "limits" not in effective_config:
                effective_config["limits"] = {}
            effective_config["limits"].update(org_plan.limit_overrides)

        return effective_config

    def create_plan_with_resources(
        self, plan_name: str, plan_type: str, resources_config: List[Dict[str, Any]]
    ) -> Plan:
        """Create a new plan with associated resources."""
        from ..entities.plan import PlanType
        from ..value_objects.pricing import Pricing, Currency
        from decimal import Decimal

        # Create plan
        plan = Plan.create(
            name=plan_name,
            description=f"{plan_type.title()} plan with resources",
            plan_type=PlanType(plan_type),
            pricing=Pricing.create_fixed(Decimal("99.00"), Currency.USD),
            resources={},
        )

        saved_plan = self._plan_repository.save(plan)

        # Create resources
        for resource_config in resources_config:
            resource_type = PlanResourceType(resource_config["resource_type"])
            configuration = resource_config["configuration"]

            resource = PlanResource.create(
                plan_id=saved_plan.id,
                resource_type=resource_type,
                configuration=configuration,
            )

            self._resource_repository.save(resource)

        # Create configuration
        api_keys = {}
        limits = {}
        enabled_features = []

        for resource_config in resources_config:
            config = resource_config["configuration"]
            if "api_keys" in config:
                api_keys.update(config["api_keys"])
            if "limits" in config:
                limits.update(config["limits"])
            if "enabled_features" in config:
                enabled_features.extend(config["enabled_features"])

        plan_configuration = PlanConfiguration.create(
            plan_id=saved_plan.id,
            api_keys=api_keys,
            limits=limits,
            enabled_features=list(set(enabled_features)),  # Remove duplicates
        )

        self._configuration_repository.save(plan_configuration)

        return saved_plan
from typing import Optional, Dict, Any, List
from uuid import UUID

from ..entities.organization_plan import (
    OrganizationPlan,
    BillingCycle,
)
from ..entities.plan import Plan
from ..repositories.organization_plan_repository import OrganizationPlanRepository
from ..repositories.plan_repository import PlanRepository


class SubscriptionService:
    """Domain service for managing organization plan subscriptions."""

    def __init__(
        self,
        org_plan_repository: OrganizationPlanRepository,
        plan_repository: PlanRepository,
    ):
        self._org_plan_repository = org_plan_repository
        self._plan_repository = plan_repository

    def subscribe_organization_to_plan(
        self,
        organization_id: UUID,
        plan_id: UUID,
        billing_cycle: BillingCycle = BillingCycle.MONTHLY,
        trial_days: int = 0,
        feature_overrides: Optional[Dict[str, Any]] = None,
        limit_overrides: Optional[Dict[str, int]] = None,
    ) -> OrganizationPlan:
        """Subscribe organization to a plan."""

        # Validate plan exists and is available
        plan = self._plan_repository.get_by_id(plan_id)
        if not plan:
            raise ValueError("Plan not found")

        if not plan.is_available_for_signup():
            raise ValueError("Plan is not available for signup")

        # Check if organization already has an active subscription
        existing_subscription = self._org_plan_repository.get_by_organization_id(
            organization_id
        )

        if existing_subscription and existing_subscription.is_active():
            raise ValueError("Organization already has an active subscription")

        # Create new subscription
        org_plan = OrganizationPlan.create(
            organization_id=organization_id,
            plan_id=plan_id,
            billing_cycle=billing_cycle,
            trial_days=trial_days,
            feature_overrides=feature_overrides,
            limit_overrides=limit_overrides,
        )

        return self._org_plan_repository.save(org_plan)

    def upgrade_organization_plan(
        self,
        organization_id: UUID,
        new_plan_id: UUID,
        effective_immediately: bool = True,
    ) -> OrganizationPlan:
        """Upgrade organization to a different plan."""

        current_subscription = self._org_plan_repository.get_by_organization_id(
            organization_id
        )
        if not current_subscription:
            raise ValueError("Organization has no active subscription")

        if not current_subscription.is_active():
            raise ValueError("Current subscription is not active")

        new_plan = self._plan_repository.get_by_id(new_plan_id)
        if not new_plan:
            raise ValueError("New plan not found")

        if not new_plan.is_available_for_signup():
            raise ValueError("New plan is not available")

        # Cancel current subscription
        cancelled_subscription = current_subscription.cancel(
            immediate=effective_immediately
        )
        self._org_plan_repository.save(cancelled_subscription)

        # Create new subscription with same billing cycle
        new_subscription = OrganizationPlan.create(
            organization_id=organization_id,
            plan_id=new_plan_id,
            billing_cycle=current_subscription.billing_cycle,
            feature_overrides=current_subscription.feature_overrides,
            limit_overrides=current_subscription.limit_overrides,
        )

        return self._org_plan_repository.save(new_subscription)

    def cancel_subscription(
        self, organization_id: UUID, immediate: bool = False, reason: str = ""
    ) -> OrganizationPlan:
        """Cancel organization subscription."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        if subscription.is_cancelled():
            raise ValueError("Subscription is already cancelled")

        cancelled_subscription = subscription.cancel(immediate=immediate)
        return self._org_plan_repository.save(cancelled_subscription)

    def renew_subscription(
        self, organization_id: UUID, periods: int = 1
    ) -> OrganizationPlan:
        """Renew organization subscription."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        renewed_subscription = subscription.renew(periods)
        return self._org_plan_repository.save(renewed_subscription)

    def suspend_subscription(
        self, organization_id: UUID, reason: str = ""
    ) -> OrganizationPlan:
        """Suspend organization subscription."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        if not subscription.is_active():
            raise ValueError("Can only suspend active subscriptions")

        suspended_subscription = subscription.suspend(reason)
        return self._org_plan_repository.save(suspended_subscription)

    def reactivate_subscription(self, organization_id: UUID) -> OrganizationPlan:
        """Reactivate suspended subscription."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        reactivated_subscription = subscription.reactivate()
        return self._org_plan_repository.save(reactivated_subscription)

    def apply_feature_override(
        self, organization_id: UUID, feature_name: str, value: Any
    ) -> OrganizationPlan:
        """Apply custom feature configuration to organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        updated_subscription = subscription.set_feature_override(feature_name, value)
        return self._org_plan_repository.save(updated_subscription)

    def apply_limit_override(
        self, organization_id: UUID, limit_name: str, value: int
    ) -> OrganizationPlan:
        """Apply custom limit to organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("Organization has no subscription")

        updated_subscription = subscription.set_limit_override(limit_name, value)
        return self._org_plan_repository.save(updated_subscription)

    def get_organization_plan_details(
        self, organization_id: UUID
    ) -> Optional[Dict[str, Any]]:
        """Get comprehensive plan details for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            return None

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return None

        return {
            "subscription_id": str(subscription.id),
            "plan": {
                "id": str(plan.id),
                "name": plan.name.value,
                "type": plan.plan_type.value,
                "description": plan.description,
            },
            "status": subscription.status.value,
            "billing_cycle": subscription.billing_cycle.value,
            "started_at": subscription.started_at.isoformat(),
            "expires_at": subscription.expires_at.isoformat()
            if subscription.expires_at
            else None,
            "trial_ends_at": subscription.trial_ends_at.isoformat()
            if subscription.trial_ends_at
            else None,
            "auto_renew": subscription.auto_renew,
            "is_active": subscription.is_active(),
            "is_expired": subscription.is_expired(),
            "is_in_trial": subscription.is_in_trial(),
            "is_cancelled": subscription.is_cancelled(),
            "days_until_expiry": subscription.days_until_expiry(),
            "days_in_trial_remaining": subscription.days_in_trial_remaining(),
            "needs_renewal": subscription.needs_renewal(),
            "feature_overrides": subscription.feature_overrides,
            "limit_overrides": subscription.limit_overrides,
            "effective_features": self._get_effective_features(plan, subscription),
            "effective_limits": self._get_effective_limits(plan, subscription),
        }

    def _get_effective_features(
        self, plan: Plan, subscription: OrganizationPlan
    ) -> Dict[str, Any]:
        """Get effective feature configuration considering overrides."""
        effective_features = plan.features.copy()
        effective_features.update(subscription.feature_overrides)
        return effective_features

    def _get_effective_limits(
        self, plan: Plan, subscription: OrganizationPlan
    ) -> Dict[str, int]:
        """Get effective limits considering overrides."""
        effective_limits = plan.limits.copy()
        effective_limits.update(subscription.limit_overrides)
        return effective_limits

    def get_subscriptions_requiring_renewal(
        self, days_ahead: int = 7
    ) -> List[Dict[str, Any]]:
        """Get subscriptions that need renewal soon."""
        expiring_plans = self._org_plan_repository.get_expiring_plans(days_ahead)

        renewal_list = []
        for subscription in expiring_plans:
            if subscription.auto_renew and subscription.is_active():
                plan = self._plan_repository.get_by_id(subscription.plan_id)

                renewal_list.append(
                    {
                        "organization_id": str(subscription.organization_id),
                        "subscription_id": str(subscription.id),
                        "plan_name": plan.name.value if plan else "Unknown",
                        "expires_at": subscription.expires_at.isoformat()
                        if subscription.expires_at
                        else None,
                        "days_until_expiry": subscription.days_until_expiry(),
                        "billing_cycle": subscription.billing_cycle.value,
                    }
                )

        return renewal_list

    def get_trial_ending_soon(self, days_ahead: int = 3) -> List[Dict[str, Any]]:
        """Get subscriptions with trials ending soon."""
        trial_ending = self._org_plan_repository.get_trial_ending_plans(days_ahead)

        ending_list = []
        for subscription in trial_ending:
            if subscription.is_in_trial() and subscription.is_active():
                plan = self._plan_repository.get_by_id(subscription.plan_id)

                ending_list.append(
                    {
                        "organization_id": str(subscription.organization_id),
                        "subscription_id": str(subscription.id),
                        "plan_name": plan.name.value if plan else "Unknown",
                        "trial_ends_at": subscription.trial_ends_at.isoformat()
                        if subscription.trial_ends_at
                        else None,
                        "days_in_trial_remaining": subscription.days_in_trial_remaining(),
                    }
                )

        return ending_list
from typing import Dict, Any, List, Optional
from uuid import UUID

from ..entities.feature_usage import FeatureUsage, UsagePeriod
from ..repositories.feature_usage_repository import FeatureUsageRepository
from ..repositories.organization_plan_repository import OrganizationPlanRepository
from ..repositories.plan_repository import PlanRepository


class UsageTrackingService:
    """Domain service for tracking and managing feature usage."""

    def __init__(
        self,
        usage_repository: FeatureUsageRepository,
        org_plan_repository: OrganizationPlanRepository,
        plan_repository: PlanRepository,
    ):
        self._usage_repository = usage_repository
        self._org_plan_repository = org_plan_repository
        self._plan_repository = plan_repository

    def track_feature_usage(
        self,
        organization_id: UUID,
        feature_name: str,
        amount: int = 1,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> tuple[bool, str, Optional[FeatureUsage]]:
        """Track feature usage and validate against limits."""

        # Get organization subscription and plan
        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return False, "Organization has no active subscription", None

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return False, "Plan not found", None

        # Check if feature is enabled
        effective_feature_value = subscription.get_effective_feature_value(
            feature_name, plan.get_feature_config(feature_name)
        )

        if not effective_feature_value:
            return False, f"Feature '{feature_name}' is not enabled for this plan", None

        # Get current usage
        current_usage = self._usage_repository.get_current_usage(
            organization_id, feature_name, UsagePeriod.MONTHLY
        )

        # Create usage record if doesn't exist
        if not current_usage:
            limit_value = subscription.get_effective_limit_value(
                f"monthly_{feature_name}", plan.get_limit(f"monthly_{feature_name}")
            )

            current_usage = FeatureUsage.create(
                organization_id=organization_id,
                feature_name=feature_name,
                usage_period=UsagePeriod.MONTHLY,
                limit_value=limit_value,
            )
            current_usage = self._usage_repository.save(current_usage)

        # Check if usage would exceed limit
        can_use, reason = current_usage.can_use_feature(amount)
        if not can_use:
            return False, reason, current_usage

        # Increment usage
        updated_usage = self._usage_repository.increment_usage(
            organization_id, feature_name, amount, metadata
        )

        return True, "Usage tracked successfully", updated_usage

    def get_organization_usage_summary(self, organization_id: UUID) -> Dict[str, Any]:
        """Get comprehensive usage summary for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            return {"error": "No active subscription found"}

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return {"error": "Plan not found"}

        # Get current usage for all features
        usage_records = self._usage_repository.get_organization_usage(organization_id)

        summary = {
            "organization_id": str(organization_id),
            "plan": {"name": plan.name.value, "type": plan.plan_type.value},
            "billing_period": {
                "cycle": subscription.billing_cycle.value,
                "started_at": subscription.started_at.isoformat(),
                "expires_at": subscription.expires_at.isoformat()
                if subscription.expires_at
                else None,
            },
            "features": {},
            "overall_status": "healthy",
        }

        # Process each usage record
        for usage in usage_records:
            if usage.is_current_period():
                feature_summary = usage.get_usage_summary()
                summary["features"][usage.feature_name] = feature_summary

                # Update overall status based on usage
                if usage.is_limit_exceeded():
                    summary["overall_status"] = "over_limit"
                elif usage.is_limit_near() and summary["overall_status"] == "healthy":
                    summary["overall_status"] = "approaching_limit"

        return summary

    def check_feature_access(
        self, organization_id: UUID, feature_name: str, requested_amount: int = 1
    ) -> tuple[bool, str, Dict[str, Any]]:
        """Check if organization can use a feature."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return False, "No active subscription", {}

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return False, "Plan not found", {}

        # Check if feature is enabled in plan
        effective_feature_value = subscription.get_effective_feature_value(
            feature_name, plan.get_feature_config(feature_name)
        )

        if not effective_feature_value:
            return (
                False,
                f"Feature '{feature_name}' not available in current plan",
                {"upgrade_required": True, "current_plan": plan.name.value},
            )

        # Check usage limits
        current_usage = self._usage_repository.get_current_usage(
            organization_id, feature_name, UsagePeriod.MONTHLY
        )

        if current_usage:
            can_use, reason = current_usage.can_use_feature(requested_amount)

            if not can_use:
                return (
                    False,
                    reason,
                    {
                        "current_usage": current_usage.current_usage,
                        "limit": current_usage.limit_value,
                        "usage_percentage": current_usage.get_usage_percentage(),
                        "days_until_reset": current_usage.days_until_reset(),
                        "upgrade_recommended": current_usage.is_limit_near(0.9),
                    },
                )

        return (
            True,
            "Feature access granted",
            {
                "remaining_usage": current_usage.get_remaining_usage()
                if current_usage
                else -1
            },
        )

    def get_usage_analytics(
        self, organization_id: UUID, feature_name: str, periods: int = 12
    ) -> Dict[str, Any]:
        """Get usage analytics and trends."""

        trends = self._usage_repository.get_usage_trends(
            organization_id, feature_name, periods
        )

        current_usage = self._usage_repository.get_current_usage(
            organization_id, feature_name, UsagePeriod.MONTHLY
        )

        analytics = {
            "feature_name": feature_name,
            "trends": trends,
            "current_period": current_usage.get_usage_summary()
            if current_usage
            else None,
            "insights": [],
        }

        # Generate insights
        if trends and len(trends) > 1:
            # Calculate growth trend
            recent_usage = [t["usage"] for t in trends[-3:]]
            if len(recent_usage) >= 2:
                growth_rate = (
                    (recent_usage[-1] - recent_usage[0]) / max(recent_usage[0], 1) * 100
                )

                if growth_rate > 50:
                    analytics["insights"].append(
                        {
                            "type": "high_growth",
                            "message": f"Usage has grown by {growth_rate:.1f}% in recent periods",
                        }
                    )
                elif growth_rate < -20:
                    analytics["insights"].append(
                        {
                            "type": "declining_usage",
                            "message": f"Usage has declined by {abs(growth_rate):.1f}% in recent periods",
                        }
                    )

        # Add limit warnings
        if current_usage and current_usage.is_limit_near(0.8):
            analytics["insights"].append(
                {
                    "type": "approaching_limit",
                    "message": f"Currently at {current_usage.get_usage_percentage():.1f}% of monthly limit",
                }
            )

        return analytics

    def reset_monthly_usage(self, organization_id: UUID) -> Dict[str, int]:
        """Reset monthly usage for organization (typically called by scheduler)."""

        usage_records = self._usage_repository.get_organization_usage(organization_id)
        reset_counts = {}

        for usage in usage_records:
            if usage.usage_period == UsagePeriod.MONTHLY and usage.is_period_expired():
                reset_usage = self._usage_repository.reset_usage_for_period(
                    organization_id, usage.feature_name, UsagePeriod.MONTHLY
                )

                if reset_usage:
                    reset_counts[usage.feature_name] = usage.current_usage

        return reset_counts

    def get_organizations_near_limits(
        self, threshold_percent: float = 0.8
    ) -> List[Dict[str, Any]]:
        """Get organizations approaching their usage limits."""

        near_limit_orgs = []

        # Get organizations exceeding threshold for various features
        feature_names = ["monthly_messages", "monthly_api_calls", "storage_mb"]

        for feature_name in feature_names:
            org_ids = self._usage_repository.get_organizations_exceeding_limit(
                feature_name, threshold_percent
            )

            for org_id in org_ids:
                usage = self._usage_repository.get_current_usage(
                    org_id, feature_name, UsagePeriod.MONTHLY
                )

                if usage:
                    near_limit_orgs.append(
                        {
                            "organization_id": str(org_id),
                            "feature_name": feature_name,
                            "usage_percentage": usage.get_usage_percentage(),
                            "current_usage": usage.current_usage,
                            "limit": usage.limit_value,
                            "days_until_reset": usage.days_until_reset(),
                        }
                    )

        return near_limit_orgs
from typing import Dict, Any, Optional, List
import requests
import time
from urllib.parse import urlparse

from ..entities.plan_resource import PlanResourceType


class PlanResourceService:
    """Domain service for plan resource configuration and testing."""

    def validate_configuration(
        self, resource_type: PlanResourceType, configuration: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Validate and normalize resource configuration based on type."""
        if resource_type == PlanResourceType.CHAT_WHATSAPP:
            return self._validate_whatsapp_configuration(configuration)
        elif resource_type == PlanResourceType.CHAT_IFRAME:
            return self._validate_iframe_configuration(configuration)
        elif resource_type == PlanResourceType.CUSTOM:
            return self._validate_custom_configuration(configuration)
        else:
            raise ValueError(f"Unsupported resource type: {resource_type}")

    def test_configuration(
        self,
        resource_type: PlanResourceType,
        configuration: Dict[str, Any],
        test_parameters: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Test a resource configuration and return test results."""
        test_parameters = test_parameters or {}
        
        if resource_type == PlanResourceType.CHAT_WHATSAPP:
            return self._test_whatsapp_configuration(configuration, test_parameters)
        elif resource_type == PlanResourceType.CHAT_IFRAME:
            return self._test_iframe_configuration(configuration, test_parameters)
        elif resource_type == PlanResourceType.CUSTOM:
            return self._test_custom_configuration(configuration, test_parameters)
        else:
            raise ValueError(f"Unsupported resource type: {resource_type}")

    def _validate_whatsapp_configuration(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Validate WhatsApp chat resource configuration."""
        validated_config = {}
        
        # Required fields
        if "api_key" not in config or not config["api_key"]:
            raise ValueError("WhatsApp API key is required")
        validated_config["api_key"] = str(config["api_key"]).strip()
        
        if "phone_number" not in config or not config["phone_number"]:
            raise ValueError("WhatsApp phone number is required")
        validated_config["phone_number"] = str(config["phone_number"]).strip()
        
        # Optional fields with defaults
        validated_config["messages_per_day"] = int(config.get("messages_per_day", 1000))
        validated_config["auto_reply"] = bool(config.get("auto_reply", True))
        validated_config["business_verification"] = bool(config.get("business_verification", False))
        
        # Webhook configuration
        if "webhook_url" in config and config["webhook_url"]:
            webhook_url = str(config["webhook_url"]).strip()
            if not self._is_valid_url(webhook_url):
                raise ValueError("Invalid webhook URL format")
            validated_config["webhook_url"] = webhook_url
            
        if "webhook_secret" in config:
            validated_config["webhook_secret"] = str(config["webhook_secret"])
            
        # Rate limiting
        validated_config["rate_limit_per_minute"] = int(config.get("rate_limit_per_minute", 60))
        validated_config["burst_limit"] = int(config.get("burst_limit", 10))
        
        # Message templates
        if "welcome_message" in config:
            validated_config["welcome_message"] = str(config["welcome_message"])[:500]
            
        if "default_response" in config:
            validated_config["default_response"] = str(config["default_response"])[:500]
            
        return validated_config

    def _validate_iframe_configuration(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Validate iframe chat resource configuration."""
        validated_config = {}
        
        # Required fields
        if "widget_id" not in config or not config["widget_id"]:
            raise ValueError("Widget ID is required")
        validated_config["widget_id"] = str(config["widget_id"]).strip()
        
        # Domain restrictions
        if "allowed_domains" in config:
            domains = config["allowed_domains"]
            if isinstance(domains, str):
                domains = [d.strip() for d in domains.split(",") if d.strip()]
            elif isinstance(domains, list):
                domains = [str(d).strip() for d in domains if str(d).strip()]
            else:
                raise ValueError("allowed_domains must be a string or list")
                
            # Validate domain formats
            validated_domains = []
            for domain in domains:
                if self._is_valid_domain(domain):
                    validated_domains.append(domain.lower())
                else:
                    raise ValueError(f"Invalid domain format: {domain}")
            validated_config["allowed_domains"] = validated_domains
        
        # Appearance settings
        validated_config["theme"] = config.get("theme", "light")
        if validated_config["theme"] not in ["light", "dark", "auto"]:
            validated_config["theme"] = "light"
            
        validated_config["primary_color"] = config.get("primary_color", "#007bff")
        validated_config["position"] = config.get("position", "bottom-right")
        if validated_config["position"] not in ["bottom-right", "bottom-left", "top-right", "top-left"]:
            validated_config["position"] = "bottom-right"
            
        # Size settings
        validated_config["width"] = min(max(int(config.get("width", 350)), 250), 500)
        validated_config["height"] = min(max(int(config.get("height", 500)), 300), 800)
        
        # Behavior settings
        validated_config["auto_open"] = bool(config.get("auto_open", False))
        validated_config["show_agent_avatar"] = bool(config.get("show_agent_avatar", True))
        validated_config["enable_file_upload"] = bool(config.get("enable_file_upload", True))
        validated_config["enable_emoji"] = bool(config.get("enable_emoji", True))
        
        # Custom branding
        if "company_name" in config:
            validated_config["company_name"] = str(config["company_name"])[:100]
            
        if "agent_name" in config:
            validated_config["agent_name"] = str(config["agent_name"])[:50]
            
        if "welcome_message" in config:
            validated_config["welcome_message"] = str(config["welcome_message"])[:500]
            
        return validated_config

    def _validate_custom_configuration(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Validate custom resource configuration."""
        # For custom resources, we perform basic validation
        validated_config = {}
        
        # Ensure configuration is not empty
        if not config:
            raise ValueError("Custom resource configuration cannot be empty")
            
        # Copy all fields, ensuring they are JSON serializable
        for key, value in config.items():
            if isinstance(value, (str, int, float, bool, list, dict, type(None))):
                validated_config[key] = value
            else:
                # Convert to string for non-JSON serializable types
                validated_config[key] = str(value)
                
        return validated_config

    def _test_whatsapp_configuration(
        self, config: Dict[str, Any], test_params: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Test WhatsApp configuration."""
        results = {
            "success": True,
            "tests_performed": [],
            "api_connection": False,
            "webhook_reachable": False,
            "response_time_ms": 0,
        }
        
        start_time = time.time()
        
        try:
            # Test 1: API Key validation
            results["tests_performed"].append("api_key_validation")
            api_key = config.get("api_key")
            phone_number = config.get("phone_number")
            
            if len(api_key) < 10:
                results["success"] = False
                results["api_connection"] = False
                results["error"] = "API key appears to be invalid (too short)"
            else:
                results["api_connection"] = True
                
            # Test 2: Webhook reachability (if configured)
            if "webhook_url" in config and config["webhook_url"]:
                results["tests_performed"].append("webhook_reachability")
                webhook_url = config["webhook_url"]
                
                try:
                    # Test webhook with a simple HEAD request
                    response = requests.head(webhook_url, timeout=5)
                    if response.status_code < 500:  # Accept 2xx, 3xx, 4xx as reachable
                        results["webhook_reachable"] = True
                    else:
                        results["webhook_reachable"] = False
                        results["webhook_error"] = f"HTTP {response.status_code}"
                except requests.RequestException as e:
                    results["webhook_reachable"] = False
                    results["webhook_error"] = str(e)
            else:
                results["webhook_reachable"] = True  # No webhook to test
                
            # Test 3: Rate limiting validation
            results["tests_performed"].append("rate_limit_validation")
            rate_limit = config.get("rate_limit_per_minute", 60)
            if rate_limit <= 0 or rate_limit > 1000:
                results["success"] = False
                results["rate_limit_error"] = "Rate limit should be between 1-1000 messages per minute"
                
        except Exception as e:
            results["success"] = False
            results["error"] = str(e)
            
        end_time = time.time()
        results["response_time_ms"] = int((end_time - start_time) * 1000)
        
        return results

    def _test_iframe_configuration(
        self, config: Dict[str, Any], test_params: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Test iframe configuration."""
        results = {
            "success": True,
            "tests_performed": [],
            "widget_valid": False,
            "domains_valid": False,
            "load_time_ms": 0,
        }
        
        start_time = time.time()
        
        try:
            # Test 1: Widget ID validation
            results["tests_performed"].append("widget_validation")
            widget_id = config.get("widget_id")
            
            if len(widget_id) >= 8:  # Basic length check
                results["widget_valid"] = True
            else:
                results["success"] = False
                results["widget_error"] = "Widget ID appears to be invalid"
                
            # Test 2: Domain validation
            results["tests_performed"].append("domain_validation")
            allowed_domains = config.get("allowed_domains", [])
            
            if isinstance(allowed_domains, list) and len(allowed_domains) > 0:
                valid_domains = all(self._is_valid_domain(domain) for domain in allowed_domains)
                results["domains_valid"] = valid_domains
                if not valid_domains:
                    results["success"] = False
                    results["domain_error"] = "One or more domains are invalid"
            else:
                results["domains_valid"] = True  # No domain restrictions
                
            # Test 3: Configuration completeness
            results["tests_performed"].append("configuration_completeness")
            required_fields = ["widget_id"]
            missing_fields = [field for field in required_fields if not config.get(field)]
            
            if missing_fields:
                results["success"] = False
                results["missing_fields"] = missing_fields
                
        except Exception as e:
            results["success"] = False
            results["error"] = str(e)
            
        end_time = time.time()
        results["load_time_ms"] = int((end_time - start_time) * 1000)
        
        return results

    def _test_custom_configuration(
        self, config: Dict[str, Any], test_params: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Test custom resource configuration."""
        results = {
            "success": True,
            "tests_performed": ["basic_validation"],
            "configuration_valid": False,
        }
        
        try:
            # Basic validation - ensure config is not empty and has required structure
            if not config:
                results["success"] = False
                results["error"] = "Configuration is empty"
            elif not isinstance(config, dict):
                results["success"] = False
                results["error"] = "Configuration must be a dictionary"
            else:
                results["configuration_valid"] = True
                
        except Exception as e:
            results["success"] = False
            results["error"] = str(e)
            
        return results

    def _is_valid_url(self, url: str) -> bool:
        """Check if URL is valid."""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc]) and result.scheme in ['http', 'https']
        except Exception:
            return False

    def _is_valid_domain(self, domain: str) -> bool:
        """Check if domain format is valid."""
        if not domain:
            return False
            
        # Remove protocol if present
        if domain.startswith(('http://', 'https://')):
            domain = domain.split('://', 1)[1]
            
        # Remove path if present
        domain = domain.split('/')[0]
        
        # Basic domain validation
        if '.' not in domain:
            return False
            
        parts = domain.split('.')
        return all(part and part.replace('-', '').isalnum() for part in parts)

    def get_default_configuration(self, resource_type: PlanResourceType) -> Dict[str, Any]:
        """Get default configuration for a resource type."""
        if resource_type == PlanResourceType.CHAT_WHATSAPP:
            return {
                "messages_per_day": 1000,
                "auto_reply": True,
                "business_verification": False,
                "rate_limit_per_minute": 60,
                "burst_limit": 10,
                "welcome_message": "Welcome! How can I help you today?",
                "default_response": "Thank you for your message. We'll get back to you soon.",
            }
        elif resource_type == PlanResourceType.CHAT_IFRAME:
            return {
                "theme": "light",
                "primary_color": "#007bff",
                "position": "bottom-right",
                "width": 350,
                "height": 500,
                "auto_open": False,
                "show_agent_avatar": True,
                "enable_file_upload": True,
                "enable_emoji": True,
                "welcome_message": "Hello! How can we assist you?",
            }
        elif resource_type == PlanResourceType.CUSTOM:
            return {
                "description": "Custom resource configuration",
                "enabled": True,
            }
        else:
            return {}

    def get_configuration_schema(self, resource_type: PlanResourceType) -> Dict[str, Any]:
        """Get configuration schema for a resource type."""
        if resource_type == PlanResourceType.CHAT_WHATSAPP:
            return {
                "type": "object",
                "required": ["api_key", "phone_number"],
                "properties": {
                    "api_key": {"type": "string", "description": "WhatsApp Business API key"},
                    "phone_number": {"type": "string", "description": "WhatsApp business phone number"},
                    "messages_per_day": {"type": "integer", "minimum": 1, "maximum": 100000},
                    "auto_reply": {"type": "boolean"},
                    "webhook_url": {"type": "string", "format": "uri"},
                    "webhook_secret": {"type": "string"},
                    "rate_limit_per_minute": {"type": "integer", "minimum": 1, "maximum": 1000},
                    "burst_limit": {"type": "integer", "minimum": 1, "maximum": 100},
                    "welcome_message": {"type": "string", "maxLength": 500},
                    "default_response": {"type": "string", "maxLength": 500},
                }
            }
        elif resource_type == PlanResourceType.CHAT_IFRAME:
            return {
                "type": "object",
                "required": ["widget_id"],
                "properties": {
                    "widget_id": {"type": "string", "description": "Unique widget identifier"},
                    "allowed_domains": {"type": "array", "items": {"type": "string"}},
                    "theme": {"type": "string", "enum": ["light", "dark", "auto"]},
                    "primary_color": {"type": "string", "pattern": "^#[0-9A-Fa-f]{6}$"},
                    "position": {"type": "string", "enum": ["bottom-right", "bottom-left", "top-right", "top-left"]},
                    "width": {"type": "integer", "minimum": 250, "maximum": 500},
                    "height": {"type": "integer", "minimum": 300, "maximum": 800},
                    "auto_open": {"type": "boolean"},
                    "show_agent_avatar": {"type": "boolean"},
                    "enable_file_upload": {"type": "boolean"},
                    "enable_emoji": {"type": "boolean"},
                    "company_name": {"type": "string", "maxLength": 100},
                    "agent_name": {"type": "string", "maxLength": 50},
                    "welcome_message": {"type": "string", "maxLength": 500},
                }
            }
        elif resource_type == PlanResourceType.CUSTOM:
            return {
                "type": "object",
                "description": "Custom resource configuration schema (flexible)",
                "additionalProperties": True
            }
        else:
            return {"type": "object", "additionalProperties": False}
from typing import List, Dict, Any, Optional
from uuid import UUID
from decimal import Decimal

from ..entities.plan import Plan, PlanType
from ..entities.plan_feature import PlanFeature
from ..repositories.plan_repository import PlanRepository
from ..repositories.plan_feature_repository import PlanFeatureRepository
from ..repositories.organization_plan_repository import OrganizationPlanRepository
from ..value_objects.pricing import Pricing


class PlanManagementService:
    """Domain service for managing plans and features."""

    def __init__(
        self,
        plan_repository: PlanRepository,
        feature_repository: PlanFeatureRepository,
        org_plan_repository: OrganizationPlanRepository,
    ):
        self._plan_repository = plan_repository
        self._feature_repository = feature_repository
        self._org_plan_repository = org_plan_repository

    def create_standard_plans(self) -> List[Plan]:
        """Create standard system plans (Free, Basic, Premium, Enterprise)."""
        plans = []

        # Free Plan
        free_plan = Plan.create(
            name="Free",
            description="Basic features for getting started",
            plan_type=PlanType.FREE,
            pricing=Pricing.create_free(),
            max_users=5,
            max_organizations=1,
        )
        plans.append(self._plan_repository.save(free_plan))

        # Basic Plan
        basic_plan = Plan.create(
            name="Basic",
            description="Essential features for small teams",
            plan_type=PlanType.BASIC,
            pricing=Pricing.create_per_user(
                base_amount=Decimal("29.00"),
                per_user_amount=Decimal("5.00"),
                free_user_count=2,
            ),
            max_users=25,
            max_organizations=3,
        )
        plans.append(self._plan_repository.save(basic_plan))

        # Premium Plan
        premium_plan = Plan.create(
            name="Premium",
            description="Advanced features for growing businesses",
            plan_type=PlanType.PREMIUM,
            pricing=Pricing.create_per_user(
                base_amount=Decimal("79.00"),
                per_user_amount=Decimal("8.00"),
                free_user_count=5,
            ),
            max_users=100,
            max_organizations=10,
        )
        plans.append(self._plan_repository.save(premium_plan))

        # Enterprise Plan
        enterprise_plan = Plan.create(
            name="Enterprise",
            description="Full features for large organizations",
            plan_type=PlanType.ENTERPRISE,
            pricing=Pricing.create_per_user(
                base_amount=Decimal("199.00"),
                per_user_amount=Decimal("12.00"),
                free_user_count=10,
            ),
            max_users=1000,
            max_organizations=50,
        )
        plans.append(self._plan_repository.save(enterprise_plan))

        return plans

    def create_system_features(self) -> List[PlanFeature]:
        """Create standard system features."""
        features = []

        # Create WhatsApp chat feature
        whatsapp_feature = PlanFeature.create_chat_whatsapp_feature()
        features.append(self._feature_repository.save(whatsapp_feature))

        # Create iframe chat feature
        iframe_feature = PlanFeature.create_chat_iframe_feature()
        features.append(self._feature_repository.save(iframe_feature))

        return features

    def can_plan_be_deleted(self, plan_id: UUID) -> tuple[bool, str]:
        """Check if plan can be safely deleted."""
        plan = self._plan_repository.get_by_id(plan_id)

        if not plan:
            return False, "Plan not found"

        # Check if plan has active subscriptions
        active_subscriptions = self._org_plan_repository.count_active_subscriptions(
            plan_id
        )

        if active_subscriptions > 0:
            return (
                False,
                f"Plan has {active_subscriptions} active subscriptions and cannot be deleted",
            )

        return True, "Plan can be deleted"

    def validate_plan_upgrade(
        self, current_plan_id: UUID, target_plan_id: UUID, organization_users: int
    ) -> tuple[bool, str]:
        """Validate if organization can upgrade to target plan."""
        current_plan = self._plan_repository.get_by_id(current_plan_id)
        target_plan = self._plan_repository.get_by_id(target_plan_id)

        if not current_plan:
            return False, "Current plan not found"

        if not target_plan:
            return False, "Target plan not found"

        if not target_plan.is_available_for_signup():
            return False, "Target plan is not available for signup"

        # Check if target plan can support current user count
        if not target_plan.can_support_users(organization_users):
            return (
                False,
                f"Target plan supports max {target_plan.max_users} users, but organization has {organization_users}",
            )

        # Prevent downgrade (optional business rule)
        plan_hierarchy = {
            PlanType.FREE: 0,
            PlanType.BASIC: 1,
            PlanType.PREMIUM: 2,
            PlanType.ENTERPRISE: 3,
        }

        current_level = plan_hierarchy.get(current_plan.plan_type, 0)
        target_level = plan_hierarchy.get(target_plan.plan_type, 0)

        if target_level < current_level:
            return False, "Downgrading plans is not allowed. Please contact support."

        return True, "Plan upgrade is valid"

    def calculate_plan_cost_comparison(
        self, plan_ids: List[UUID], user_count: int = 1
    ) -> Dict[str, Dict[str, Any]]:
        """Calculate and compare costs for multiple plans."""
        comparison = {}

        for plan_id in plan_ids:
            plan = self._plan_repository.get_by_id(plan_id)

            if plan:
                monthly_cost = plan.pricing.calculate_monthly_cost(user_count)
                yearly_cost = plan.pricing.calculate_yearly_cost(user_count)
                setup_cost = plan.pricing.calculate_setup_cost()

                comparison[str(plan_id)] = {
                    "plan_name": plan.name.value,
                    "plan_type": plan.plan_type.value,
                    "monthly_cost": float(monthly_cost),
                    "yearly_cost": float(yearly_cost),
                    "setup_cost": float(setup_cost),
                    "yearly_savings": float(monthly_cost * 12 - yearly_cost),
                    "cost_per_user": float(plan.pricing.per_user_amount or 0),
                    "pricing_description": plan.pricing.get_pricing_description(),
                    "features": plan.features,
                    "limits": plan.limits,
                }

        return comparison

    def get_plan_feature_matrix(self) -> Dict[str, Dict[str, Any]]:
        """Get feature comparison matrix for all public plans."""
        public_plans = self._plan_repository.get_public_plans()
        features = self._feature_repository.get_active_features()

        matrix = {}

        for plan in public_plans:
            plan_features = {}

            for feature in features:
                feature_value = plan.get_feature_config(feature.name)
                plan_features[feature.name] = {
                    "enabled": bool(feature_value),
                    "config": feature_value,
                    "display_name": feature.display_name,
                    "description": feature.description,
                }

            matrix[plan.name.value] = {
                "plan_id": str(plan.id),
                "plan_type": plan.plan_type.value,
                "pricing": plan.pricing.get_pricing_description(),
                "max_users": plan.max_users,
                "features": plan_features,
                "limits": plan.limits,
            }

        return matrix

    def recommend_plan_for_organization(
        self,
        user_count: int,
        required_features: List[str],
        budget_monthly: Optional[Decimal] = None,
    ) -> List[Dict[str, Any]]:
        """Recommend plans based on requirements."""
        public_plans = self._plan_repository.get_public_plans()
        recommendations = []

        for plan in public_plans:
            # Check user capacity
            if not plan.can_support_users(user_count):
                continue

            # Check required features
            missing_features = []
            for feature in required_features:
                if not plan.is_feature_enabled(feature):
                    missing_features.append(feature)

            # Calculate cost
            monthly_cost = plan.pricing.calculate_monthly_cost(user_count)

            # Check budget constraint
            within_budget = budget_monthly is None or monthly_cost <= budget_monthly

            score = 0
            # Higher score for plans that meet all requirements
            if not missing_features:
                score += 50

            # Higher score for plans within budget
            if within_budget:
                score += 30

            # Lower score for more expensive plans (prefer cheaper when possible)
            if budget_monthly and monthly_cost <= budget_monthly * Decimal("0.8"):
                score += 20

            recommendations.append(
                {
                    "plan_id": str(plan.id),
                    "plan_name": plan.name.value,
                    "plan_type": plan.plan_type.value,
                    "monthly_cost": float(monthly_cost),
                    "missing_features": missing_features,
                    "within_budget": within_budget,
                    "score": score,
                    "reason": self._get_recommendation_reason(
                        plan, missing_features, within_budget
                    ),
                }
            )

        # Sort by score (highest first)
        recommendations.sort(key=lambda x: x["score"], reverse=True)

        return recommendations[:3]  # Return top 3 recommendations

    def _get_recommendation_reason(
        self, plan: Plan, missing_features: List[str], within_budget: bool
    ) -> str:
        """Generate recommendation reason text."""
        if not missing_features and within_budget:
            return f"Perfect match! {plan.name.value} includes all required features within budget."

        if not missing_features:
            return f"{plan.name.value} includes all required features but may be over budget."

        if within_budget:
            feature_text = "features" if len(missing_features) > 1 else "feature"
            return f"{plan.name.value} is within budget but missing {len(missing_features)} {feature_text}."

        return f"{plan.name.value} is missing features and over budget."
from .plan_management_service import PlanManagementService
from .subscription_service import SubscriptionService
from .usage_tracking_service import UsageTrackingService
from .feature_access_service import FeatureAccessService
from .plan_authorization_service import PlanAuthorizationService
from .plan_resource_service import PlanResourceService

__all__ = [
    "PlanManagementService",
    "SubscriptionService", 
    "UsageTrackingService",
    "FeatureAccessService",
    "PlanAuthorizationService",
    "PlanResourceService"
]
from typing import Dict, Any, Optional, List
from uuid import UUID

from ..entities.organization_plan import OrganizationPlan
from ..repositories.organization_plan_repository import OrganizationPlanRepository
from ..repositories.plan_repository import PlanRepository
from ..value_objects.chat_configuration import (
    ChatWhatsAppConfiguration,
    ChatIframeConfiguration,
)


class FeatureAccessService:
    """Domain service for managing feature access and configurations."""

    def __init__(
        self,
        org_plan_repository: OrganizationPlanRepository,
        plan_repository: PlanRepository,
    ):
        self._org_plan_repository = org_plan_repository
        self._plan_repository = plan_repository

    def has_feature_access(
        self, organization_id: UUID, feature_name: str
    ) -> tuple[bool, str]:
        """Check if organization has access to a specific feature."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return False, "No active subscription"

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return False, "Plan not found"

        # Check effective feature value (plan + overrides)
        effective_value = subscription.get_effective_feature_value(
            feature_name, plan.get_feature_config(feature_name)
        )

        if not effective_value:
            return False, f"Feature '{feature_name}' not available in current plan"

        return True, "Feature access granted"

    def get_chat_whatsapp_config(
        self, organization_id: UUID
    ) -> Optional[ChatWhatsAppConfiguration]:
        """Get WhatsApp chat configuration for organization."""

        has_access, _ = self.has_feature_access(organization_id, "chat_whatsapp")
        if not has_access:
            return None

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            return None

        # Get configuration from feature overrides or default
        config_data = subscription.feature_overrides.get("chat_whatsapp")

        if isinstance(config_data, dict):
            try:
                return ChatWhatsAppConfiguration(**config_data)
            except Exception:
                # Return default config if custom config is invalid
                return ChatWhatsAppConfiguration.create_default()

        return ChatWhatsAppConfiguration.create_default()

    def update_chat_whatsapp_config(
        self, organization_id: UUID, config: ChatWhatsAppConfiguration
    ) -> OrganizationPlan:
        """Update WhatsApp chat configuration for organization."""

        has_access, reason = self.has_feature_access(organization_id, "chat_whatsapp")
        if not has_access:
            raise ValueError(f"Cannot update WhatsApp config: {reason}")

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("No active subscription found")

        # Validate configuration
        is_valid, issues = config.is_properly_configured()
        if not is_valid:
            raise ValueError(f"Invalid WhatsApp configuration: {', '.join(issues)}")

        # Update feature override
        updated_subscription = subscription.set_feature_override(
            "chat_whatsapp", config.model_dump()
        )

        return self._org_plan_repository.save(updated_subscription)

    def get_chat_iframe_config(
        self, organization_id: UUID
    ) -> Optional[ChatIframeConfiguration]:
        """Get iframe chat configuration for organization."""

        has_access, _ = self.has_feature_access(organization_id, "chat_iframe")
        if not has_access:
            return None

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            return None

        # Get configuration from feature overrides or default
        config_data = subscription.feature_overrides.get("chat_iframe")

        if isinstance(config_data, dict):
            try:
                return ChatIframeConfiguration(**config_data)
            except Exception:
                # Return default config if custom config is invalid
                return ChatIframeConfiguration.create_default()

        return ChatIframeConfiguration.create_default()

    def update_chat_iframe_config(
        self, organization_id: UUID, config: ChatIframeConfiguration
    ) -> OrganizationPlan:
        """Update iframe chat configuration for organization."""

        has_access, reason = self.has_feature_access(organization_id, "chat_iframe")
        if not has_access:
            raise ValueError(f"Cannot update iframe chat config: {reason}")

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("No active subscription found")

        # Update feature override
        updated_subscription = subscription.set_feature_override(
            "chat_iframe", config.model_dump()
        )

        return self._org_plan_repository.save(updated_subscription)

    def get_feature_configurations(self, organization_id: UUID) -> Dict[str, Any]:
        """Get all feature configurations for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return {}

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return {}

        configurations = {}

        # Chat WhatsApp
        if subscription.get_effective_feature_value(
            "chat_whatsapp", plan.get_feature_config("chat_whatsapp")
        ):
            whatsapp_config = self.get_chat_whatsapp_config(organization_id)
            if whatsapp_config:
                configurations["chat_whatsapp"] = whatsapp_config.model_dump()

        # Chat Iframe
        if subscription.get_effective_feature_value(
            "chat_iframe", plan.get_feature_config("chat_iframe")
        ):
            iframe_config = self.get_chat_iframe_config(organization_id)
            if iframe_config:
                configurations["chat_iframe"] = iframe_config.model_dump()

        return configurations

    def get_available_features(self, organization_id: UUID) -> List[Dict[str, Any]]:
        """Get list of available features for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription or not subscription.is_active():
            return []

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            return []

        available_features = []

        # Process each feature
        for feature_name, plan_config in plan.features.items():
            effective_config = subscription.get_effective_feature_value(
                feature_name, plan_config
            )

            if effective_config:
                feature_info = {
                    "name": feature_name,
                    "enabled": bool(effective_config),
                    "config": effective_config,
                    "overridden": feature_name in subscription.feature_overrides,
                }

                # Add specific information for chat features
                if feature_name == "chat_whatsapp":
                    config = self.get_chat_whatsapp_config(organization_id)
                    feature_info["configuration_status"] = (
                        "configured" if config and config.enabled else "not_configured"
                    )

                elif feature_name == "chat_iframe":
                    config = self.get_chat_iframe_config(organization_id)
                    feature_info["configuration_status"] = (
                        "configured" if config and config.enabled else "not_configured"
                    )

                available_features.append(feature_info)

        return available_features

    def validate_feature_requirements(
        self, organization_id: UUID, required_features: List[str]
    ) -> Dict[str, Any]:
        """Validate if organization has access to all required features."""

        validation_result = {
            "all_requirements_met": True,
            "available_features": [],
            "missing_features": [],
            "upgrade_required": False,
        }

        for feature_name in required_features:
            has_access, reason = self.has_feature_access(organization_id, feature_name)

            if has_access:
                validation_result["available_features"].append(feature_name)
            else:
                validation_result["missing_features"].append(
                    {"feature": feature_name, "reason": reason}
                )
                validation_result["all_requirements_met"] = False
                validation_result["upgrade_required"] = True

        return validation_result

    def get_iframe_embed_code(
        self, organization_id: UUID, chat_endpoint: str
    ) -> Optional[str]:
        """Generate iframe embed code for organization."""

        config = self.get_chat_iframe_config(organization_id)
        if not config or not config.enabled:
            return None

        return config.get_embed_code(str(organization_id), chat_endpoint)

    def is_domain_allowed_for_iframe(self, organization_id: UUID, domain: str) -> bool:
        """Check if domain is allowed to embed iframe chat."""

        config = self.get_chat_iframe_config(organization_id)
        if not config or not config.enabled:
            return False

        return config.is_domain_allowed(domain)

    def enable_feature_for_organization(
        self, organization_id: UUID, feature_name: str, config: Optional[Any] = None
    ) -> OrganizationPlan:
        """Enable a feature for organization with custom configuration."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("No active subscription found")

        plan = self._plan_repository.get_by_id(subscription.plan_id)
        if not plan:
            raise ValueError("Plan not found")

        # Check if feature exists in plan (even if disabled)
        if feature_name not in plan.features:
            raise ValueError(f"Feature '{feature_name}' not available in current plan")

        # Set feature override to enable it
        feature_config = config if config is not None else True
        updated_subscription = subscription.set_feature_override(
            feature_name, feature_config
        )

        return self._org_plan_repository.save(updated_subscription)

    def disable_feature_for_organization(
        self, organization_id: UUID, feature_name: str
    ) -> OrganizationPlan:
        """Disable a feature for organization."""

        subscription = self._org_plan_repository.get_by_organization_id(organization_id)
        if not subscription:
            raise ValueError("No active subscription found")

        # Set feature override to disable it
        updated_subscription = subscription.set_feature_override(feature_name, False)

        return self._org_plan_repository.save(updated_subscription)
from pydantic import BaseModel, field_validator
from typing import Any
import re


class PlanName(BaseModel):
    value: str

    model_config = {"frozen": True}

    @field_validator('value')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Plan name cannot be empty")
        
        cleaned_name = v.strip()
        
        if len(cleaned_name) < 2:
            raise ValueError("Plan name must be at least 2 characters long")
        
        if len(cleaned_name) > 50:
            raise ValueError("Plan name cannot exceed 50 characters")
        
        # Allow letters, numbers, spaces, hyphens, and underscores
        if not re.match(r'^[a-zA-Z0-9\s\-_]+$', cleaned_name):
            raise ValueError("Plan name can only contain letters, numbers, spaces, hyphens, and underscores")
        
        return cleaned_name

    def __str__(self) -> str:
        return self.value

    def __hash__(self) -> int:
        return hash(self.value)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, PlanName):
            return self.value == other.value
        return False

    def to_slug(self) -> str:
        """Convert name to URL-friendly slug."""
        return re.sub(r'[^a-zA-Z0-9\-_]', '-', self.value.lower()).strip('-')

    def to_identifier(self) -> str:
        """Convert name to programming identifier format."""
        return re.sub(r'[^a-zA-Z0-9_]', '_', self.value.lower()).strip('_')

    def is_system_plan(self) -> bool:
        """Check if this is a system plan name."""
        system_plans = ["free", "basic", "premium", "enterprise"]
        return self.to_identifier() in system_plans
from decimal import Decimal
from pydantic import BaseModel, field_validator
from typing import Optional
from enum import Enum


class Currency(str, Enum):
    USD = "USD"
    EUR = "EUR"
    BRL = "BRL"
    GBP = "GBP"


class PricingModel(str, Enum):
    FIXED = "fixed"
    PER_USER = "per_user"
    USAGE_BASED = "usage_based"
    TIERED = "tiered"


class Pricing(BaseModel):
    amount: Decimal
    currency: Currency
    model: PricingModel
    setup_fee: Decimal = Decimal("0.00")
    per_user_amount: Optional[Decimal] = None
    free_user_count: int = 0

    model_config = {"frozen": True}

    @field_validator('amount', 'setup_fee', 'per_user_amount')
    @classmethod
    def validate_amounts(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        if v is None:
            return v
        
        if v < 0:
            raise ValueError("Amount cannot be negative")
        
        if v > Decimal("999999.99"):
            raise ValueError("Amount cannot exceed 999,999.99")
        
        # Ensure proper decimal precision (2 decimal places)
        return v.quantize(Decimal("0.01"))

    @field_validator('free_user_count')
    @classmethod
    def validate_free_user_count(cls, v: int) -> int:
        if v < 0:
            raise ValueError("Free user count cannot be negative")
        
        if v > 1000:
            raise ValueError("Free user count cannot exceed 1000")
        
        return v

    @classmethod
    def create_fixed(
        cls, 
        amount: Decimal, 
        currency: Currency = Currency.USD,
        setup_fee: Decimal = Decimal("0.00")
    ) -> "Pricing":
        return cls(
            amount=amount,
            currency=currency,
            model=PricingModel.FIXED,
            setup_fee=setup_fee
        )

    @classmethod
    def create_per_user(
        cls,
        base_amount: Decimal,
        per_user_amount: Decimal,
        currency: Currency = Currency.USD,
        free_user_count: int = 0,
        setup_fee: Decimal = Decimal("0.00")
    ) -> "Pricing":
        return cls(
            amount=base_amount,
            currency=currency,
            model=PricingModel.PER_USER,
            per_user_amount=per_user_amount,
            free_user_count=free_user_count,
            setup_fee=setup_fee
        )

    @classmethod
    def create_free(cls) -> "Pricing":
        return cls(
            amount=Decimal("0.00"),
            currency=Currency.USD,
            model=PricingModel.FIXED,
            setup_fee=Decimal("0.00")
        )

    def calculate_total_cost(self, user_count: int = 1) -> Decimal:
        """Calculate total cost based on pricing model and user count."""
        total = self.amount
        
        if self.model == PricingModel.PER_USER and self.per_user_amount:
            # Calculate billable users (subtract free users)
            billable_users = max(0, user_count - self.free_user_count)
            total += self.per_user_amount * billable_users
        
        return total

    def calculate_setup_cost(self) -> Decimal:
        """Get setup cost."""
        return self.setup_fee

    def calculate_monthly_cost(self, user_count: int = 1) -> Decimal:
        """Calculate monthly cost (alias for total cost)."""
        return self.calculate_total_cost(user_count)

    def calculate_yearly_cost(self, user_count: int = 1) -> Decimal:
        """Calculate yearly cost with potential discount."""
        monthly_cost = self.calculate_total_cost(user_count)
        # Apply 10% discount for yearly billing
        yearly_cost = monthly_cost * 12 * Decimal("0.9")
        return yearly_cost.quantize(Decimal("0.01"))

    def is_free(self) -> bool:
        """Check if pricing is free."""
        return self.amount == Decimal("0.00") and self.setup_fee == Decimal("0.00")

    def has_setup_fee(self) -> bool:
        """Check if pricing has setup fee."""
        return self.setup_fee > Decimal("0.00")

    def is_per_user_pricing(self) -> bool:
        """Check if pricing is per-user based."""
        return self.model == PricingModel.PER_USER

    def format_amount(self, amount: Decimal) -> str:
        """Format amount with currency."""
        symbol_map = {
            Currency.USD: "$",
            Currency.EUR: "",
            Currency.BRL: "R$",
            Currency.GBP: ""
        }
        
        symbol = symbol_map.get(self.currency, self.currency.value)
        return f"{symbol}{amount:,.2f}"

    def format_price(self, user_count: int = 1) -> str:
        """Format complete price string."""
        total = self.calculate_total_cost(user_count)
        formatted = self.format_amount(total)
        
        if self.model == PricingModel.PER_USER and user_count > 1:
            formatted += f" ({user_count} users)"
        
        return formatted

    def get_pricing_description(self) -> str:
        """Get human-readable pricing description."""
        if self.is_free():
            return "Free"
        
        base_price = self.format_amount(self.amount)
        
        if self.model == PricingModel.FIXED:
            return f"{base_price}/month"
        
        elif self.model == PricingModel.PER_USER:
            if self.amount > 0:
                desc = f"{base_price} base"
            else:
                desc = ""
            
            if self.per_user_amount:
                user_price = self.format_amount(self.per_user_amount)
                if desc:
                    desc += f" + {user_price}/user/month"
                else:
                    desc = f"{user_price}/user/month"
            
            if self.free_user_count > 0:
                desc += f" (first {self.free_user_count} users free)"
            
            return desc
        
        return f"{base_price}/month"

    def to_dict(self) -> dict:
        """Convert to dictionary representation."""
        return {
            "amount": float(self.amount),
            "currency": self.currency.value,
            "model": self.model.value,
            "setup_fee": float(self.setup_fee),
            "per_user_amount": float(self.per_user_amount) if self.per_user_amount else None,
            "free_user_count": self.free_user_count
        }
from .plan_name import PlanName
from .pricing import Pricing
from .chat_configuration import ChatWhatsAppConfiguration, ChatIframeConfiguration

__all__ = ["PlanName", "Pricing", "ChatWhatsAppConfiguration", "ChatIframeConfiguration"]
from pydantic import BaseModel, field_validator
from typing import Optional, List, Dict, Any
import re


class BusinessHours(BaseModel):
    enabled: bool = False
    start_time: str = "09:00"
    end_time: str = "17:00"
    timezone: str = "UTC"

    model_config = {"frozen": True}

    @field_validator('start_time', 'end_time')
    @classmethod
    def validate_time_format(cls, v: str) -> str:
        if not re.match(r'^([01]?[0-9]|2[0-3]):[0-5][0-9]$', v):
            raise ValueError("Time must be in HH:MM format")
        return v

    @field_validator('timezone')
    @classmethod
    def validate_timezone(cls, v: str) -> str:
        # Basic timezone validation - in production, use pytz or zoneinfo
        if not v or len(v) > 50:
            raise ValueError("Invalid timezone")
        return v


class ChatWhatsAppConfiguration(BaseModel):
    enabled: bool = False
    phone_number: Optional[str] = None
    webhook_url: Optional[str] = None
    auto_reply: bool = True
    business_hours: BusinessHours = BusinessHours()
    welcome_message: str = "Hello! How can we help you today?"
    away_message: str = "We're currently away. Please leave a message and we'll get back to you soon."

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @field_validator('phone_number')
    @classmethod
    def validate_phone_number(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        
        # Remove common phone number formatting
        cleaned = re.sub(r'[^\d+]', '', v)
        
        if not re.match(r'^\+?[1-9]\d{1,14}$', cleaned):
            raise ValueError("Invalid phone number format")
        
        return cleaned

    @field_validator('webhook_url')
    @classmethod
    def validate_webhook_url(cls, v: Optional[str]) -> Optional[str]:
        if v is None:
            return v
        
        if not re.match(r'^https?://.+', v):
            raise ValueError("Webhook URL must be a valid HTTP/HTTPS URL")
        
        return v

    @field_validator('welcome_message', 'away_message')
    @classmethod
    def validate_messages(cls, v: str) -> str:
        if len(v) > 500:
            raise ValueError("Message cannot exceed 500 characters")
        return v.strip()

    @classmethod
    def create_default(cls) -> "ChatWhatsAppConfiguration":
        return cls()

    def enable(self, phone_number: str, webhook_url: Optional[str] = None) -> "ChatWhatsAppConfiguration":
        return self.model_copy(update={
            "enabled": True,
            "phone_number": phone_number,
            "webhook_url": webhook_url
        })

    def disable(self) -> "ChatWhatsAppConfiguration":
        return self.model_copy(update={"enabled": False})

    def update_business_hours(self, business_hours: BusinessHours) -> "ChatWhatsAppConfiguration":
        return self.model_copy(update={"business_hours": business_hours})

    def update_messages(self, welcome: Optional[str] = None, away: Optional[str] = None) -> "ChatWhatsAppConfiguration":
        updates = {}
        if welcome is not None:
            updates["welcome_message"] = welcome
        if away is not None:
            updates["away_message"] = away
        
        return self.model_copy(update=updates)

    def is_properly_configured(self) -> tuple[bool, List[str]]:
        """Check if configuration is valid and complete."""
        issues = []
        
        if self.enabled:
            if not self.phone_number:
                issues.append("Phone number is required when WhatsApp chat is enabled")
            
            if self.business_hours.enabled:
                try:
                    start_hour, start_min = map(int, self.business_hours.start_time.split(':'))
                    end_hour, end_min = map(int, self.business_hours.end_time.split(':'))
                    
                    start_minutes = start_hour * 60 + start_min
                    end_minutes = end_hour * 60 + end_min
                    
                    if start_minutes >= end_minutes:
                        issues.append("Business hours start time must be before end time")
                
                except ValueError:
                    issues.append("Invalid business hours time format")
        
        return len(issues) == 0, issues


class ChatTheme(BaseModel):
    primary_color: str = "#007bff"
    secondary_color: str = "#6c757d"
    font_family: str = "Arial, sans-serif"
    border_radius: int = 8

    model_config = {"frozen": True}

    @field_validator('primary_color', 'secondary_color')
    @classmethod
    def validate_color(cls, v: str) -> str:
        if not re.match(r'^#[0-9a-fA-F]{6}$', v):
            raise ValueError("Color must be a valid hex color (e.g., #007bff)")
        return v.lower()

    @field_validator('border_radius')
    @classmethod
    def validate_border_radius(cls, v: int) -> int:
        if not 0 <= v <= 50:
            raise ValueError("Border radius must be between 0 and 50 pixels")
        return v


class ChatIframeConfiguration(BaseModel):
    enabled: bool = False
    theme: ChatTheme = ChatTheme()
    position: str = "bottom-right"
    welcome_message: str = "Hi there! How can we help you?"
    offline_message: str = "We're currently offline. Please leave a message."
    allowed_domains: List[str] = []
    show_agent_avatar: bool = True
    show_timestamps: bool = True
    enable_file_upload: bool = False
    enable_emoji: bool = True

    model_config = {"frozen": True, "arbitrary_types_allowed": True}

    @field_validator('position')
    @classmethod
    def validate_position(cls, v: str) -> str:
        valid_positions = ["bottom-right", "bottom-left", "top-right", "top-left"]
        if v not in valid_positions:
            raise ValueError(f"Position must be one of: {', '.join(valid_positions)}")
        return v

    @field_validator('welcome_message', 'offline_message')
    @classmethod
    def validate_messages(cls, v: str) -> str:
        if len(v) > 200:
            raise ValueError("Message cannot exceed 200 characters")
        return v.strip()

    @field_validator('allowed_domains')
    @classmethod
    def validate_domains(cls, v: List[str]) -> List[str]:
        validated_domains = []
        
        for domain in v:
            # Basic domain validation
            if not re.match(r'^[a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]*[a-zA-Z0-9])?)*$', domain):
                raise ValueError(f"Invalid domain format: {domain}")
            validated_domains.append(domain.lower())
        
        return validated_domains

    @classmethod
    def create_default(cls) -> "ChatIframeConfiguration":
        return cls()

    def enable(self, allowed_domains: Optional[List[str]] = None) -> "ChatIframeConfiguration":
        return self.model_copy(update={
            "enabled": True,
            "allowed_domains": allowed_domains or []
        })

    def disable(self) -> "ChatIframeConfiguration":
        return self.model_copy(update={"enabled": False})

    def update_theme(self, theme: ChatTheme) -> "ChatIframeConfiguration":
        return self.model_copy(update={"theme": theme})

    def add_allowed_domain(self, domain: str) -> "ChatIframeConfiguration":
        if domain.lower() not in [d.lower() for d in self.allowed_domains]:
            new_domains = self.allowed_domains + [domain.lower()]
            return self.model_copy(update={"allowed_domains": new_domains})
        return self

    def remove_allowed_domain(self, domain: str) -> "ChatIframeConfiguration":
        new_domains = [d for d in self.allowed_domains if d.lower() != domain.lower()]
        return self.model_copy(update={"allowed_domains": new_domains})

    def update_position(self, position: str) -> "ChatIframeConfiguration":
        return self.model_copy(update={"position": position})

    def update_messages(self, welcome: Optional[str] = None, offline: Optional[str] = None) -> "ChatIframeConfiguration":
        updates = {}
        if welcome is not None:
            updates["welcome_message"] = welcome
        if offline is not None:
            updates["offline_message"] = offline
        
        return self.model_copy(update=updates)

    def is_domain_allowed(self, domain: str) -> bool:
        """Check if a domain is allowed to embed the chat."""
        if not self.allowed_domains:  # Empty list means all domains allowed
            return True
        
        return domain.lower() in [d.lower() for d in self.allowed_domains]

    def get_embed_code(self, organization_id: str, chat_endpoint: str) -> str:
        """Generate iframe embed code."""
        params = {
            "org": organization_id,
            "theme": self.theme.primary_color.replace("#", ""),
            "position": self.position
        }
        
        param_string = "&".join([f"{k}={v}" for k, v in params.items()])
        
        return f'''<iframe 
    src="{chat_endpoint}?{param_string}" 
    width="350" 
    height="500" 
    frameborder="0"
    style="position: fixed; {self._get_position_style()}; z-index: 9999;">
</iframe>'''

    def _get_position_style(self) -> str:
        """Get CSS positioning style based on position setting."""
        positions = {
            "bottom-right": "bottom: 20px; right: 20px;",
            "bottom-left": "bottom: 20px; left: 20px;",
            "top-right": "top: 20px; right: 20px;",
            "top-left": "top: 20px; left: 20px;"
        }
        return positions.get(self.position, positions["bottom-right"])

    def to_client_config(self) -> Dict[str, Any]:
        """Get configuration safe for client-side use."""
        return {
            "theme": {
                "primaryColor": self.theme.primary_color,
                "secondaryColor": self.theme.secondary_color,
                "fontFamily": self.theme.font_family,
                "borderRadius": self.theme.border_radius
            },
            "position": self.position,
            "welcomeMessage": self.welcome_message,
            "offlineMessage": self.offline_message,
            "showAgentAvatar": self.show_agent_avatar,
            "showTimestamps": self.show_timestamps,
            "enableFileUpload": self.enable_file_upload,
            "enableEmoji": self.enable_emoji
        }
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.plan import Plan, PlanType, PlanStatus
from ..value_objects.plan_name import PlanName


class PlanRepository(ABC):
    """Plan repository interface for the Plans bounded context."""

    @abstractmethod
    def save(self, plan: Plan) -> Plan:
        """Save or update a plan."""
        pass

    @abstractmethod
    def get_by_id(self, plan_id: UUID) -> Optional[Plan]:
        """Get plan by ID."""
        pass

    @abstractmethod
    def get_by_name(self, name: PlanName) -> Optional[Plan]:
        """Get plan by name."""
        pass

    @abstractmethod
    def get_by_type(self, plan_type: PlanType) -> List[Plan]:
        """Get plans by type."""
        pass

    @abstractmethod
    def get_public_plans(self) -> List[Plan]:
        """Get all public plans available for signup."""
        pass

    @abstractmethod
    def get_active_plans(self) -> List[Plan]:
        """Get all active plans."""
        pass

    @abstractmethod
    def exists_by_name(self, name: PlanName) -> bool:
        """Check if plan exists by name."""
        pass

    @abstractmethod
    def delete(self, plan_id: UUID) -> bool:
        """Delete plan by ID."""
        pass

    @abstractmethod
    def list_plans(
        self,
        status: Optional[PlanStatus] = None,
        is_public: Optional[bool] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[Plan]:
        """List plans with filtering and pagination."""
        pass

    @abstractmethod
    def count_plans(self, status: Optional[PlanStatus] = None) -> int:
        """Count plans by status."""
        pass

    @abstractmethod
    def get_plans_with_resource(self, resource_type: str) -> List[Plan]:
        """Get plans that have a specific resource enabled."""
        pass

    @abstractmethod
    def assign_to_organization(self, plan_id: UUID, organization_id: UUID) -> bool:
        """Assign plan to organization."""
        pass

    @abstractmethod
    def validate_plan_resources(self, plan_id: UUID) -> tuple[bool, List[str]]:
        """Validate that plan resources have required configurations."""
        pass

    @abstractmethod
    def get_plans_requiring_api_key(self, api_key_name: str) -> List[Plan]:
        """Get plans that require a specific API key."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
from uuid import UUID
from datetime import datetime

from ..entities.feature_usage import FeatureUsage, UsagePeriod


class FeatureUsageRepository(ABC):
    """Feature usage repository interface for the Plans bounded context."""

    @abstractmethod
    def save(self, feature_usage: FeatureUsage) -> FeatureUsage:
        """Save or update feature usage."""
        pass

    @abstractmethod
    def get_by_id(self, usage_id: UUID) -> Optional[FeatureUsage]:
        """Get feature usage by ID."""
        pass

    @abstractmethod
    def get_current_usage(
        self, organization_id: UUID, feature_name: str, period: UsagePeriod
    ) -> Optional[FeatureUsage]:
        """Get current usage for organization and feature."""
        pass

    @abstractmethod
    def get_organization_usage(
        self,
        organization_id: UUID,
        period_start: Optional[datetime] = None,
        period_end: Optional[datetime] = None,
    ) -> List[FeatureUsage]:
        """Get all usage records for an organization."""
        pass

    @abstractmethod
    def get_feature_usage_across_organizations(
        self,
        feature_name: str,
        period: UsagePeriod,
        period_start: Optional[datetime] = None,
    ) -> List[FeatureUsage]:
        """Get usage for a specific feature across all organizations."""
        pass

    @abstractmethod
    def get_organizations_exceeding_limit(
        self, feature_name: str, threshold_percent: float = 0.8
    ) -> List[UUID]:
        """Get organizations exceeding usage threshold for a feature."""
        pass

    @abstractmethod
    def increment_usage(
        self,
        organization_id: UUID,
        feature_name: str,
        amount: int = 1,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> FeatureUsage:
        """Increment usage for organization and feature."""
        pass

    @abstractmethod
    def reset_usage_for_period(
        self, organization_id: UUID, feature_name: str, period: UsagePeriod
    ) -> bool:
        """Reset usage for new billing period."""
        pass

    @abstractmethod
    def delete(self, usage_id: UUID) -> bool:
        """Delete usage record by ID."""
        pass

    @abstractmethod
    def delete_old_records(self, older_than_days: int = 365) -> int:
        """Delete usage records older than specified days."""
        pass

    @abstractmethod
    def get_usage_summary(
        self, organization_id: UUID, period_start: datetime, period_end: datetime
    ) -> Dict[str, Dict[str, Any]]:
        """Get usage summary for organization within period."""
        pass

    @abstractmethod
    def get_usage_trends(
        self, organization_id: UUID, feature_name: str, periods: int = 12
    ) -> List[Dict[str, Any]]:
        """Get usage trends for feature over specified periods."""
        pass

    @abstractmethod
    def bulk_reset_monthly_usage(self) -> int:
        """Reset monthly usage for all organizations at month end."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID
from datetime import datetime

from ..entities.organization_plan import OrganizationPlan, SubscriptionStatus


class OrganizationPlanRepository(ABC):
    """Organization plan repository interface for the Plans bounded context."""

    @abstractmethod
    def save(self, organization_plan: OrganizationPlan) -> OrganizationPlan:
        """Save or update an organization plan."""
        pass

    @abstractmethod
    def get_by_id(self, organization_plan_id: UUID) -> Optional[OrganizationPlan]:
        """Get organization plan by ID."""
        pass

    @abstractmethod
    def get_by_organization_id(
        self, organization_id: UUID
    ) -> Optional[OrganizationPlan]:
        """Get current plan for an organization."""
        pass

    @abstractmethod
    def get_organization_plan_history(
        self, organization_id: UUID
    ) -> List[OrganizationPlan]:
        """Get plan history for an organization."""
        pass

    @abstractmethod
    def get_by_plan_id(self, plan_id: UUID) -> List[OrganizationPlan]:
        """Get all organizations using a specific plan."""
        pass

    @abstractmethod
    def get_expiring_plans(self, days_ahead: int = 7) -> List[OrganizationPlan]:
        """Get plans expiring within specified days."""
        pass

    @abstractmethod
    def get_trial_ending_plans(self, days_ahead: int = 3) -> List[OrganizationPlan]:
        """Get plans with trials ending within specified days."""
        pass

    @abstractmethod
    def get_by_status(self, status: SubscriptionStatus) -> List[OrganizationPlan]:
        """Get organization plans by status."""
        pass

    @abstractmethod
    def delete(self, organization_plan_id: UUID) -> bool:
        """Delete organization plan by ID."""
        pass

    @abstractmethod
    def count_active_subscriptions(self, plan_id: Optional[UUID] = None) -> int:
        """Count active subscriptions, optionally filtered by plan."""
        pass

    @abstractmethod
    def get_organizations_with_feature(
        self, feature_name: str, enabled: bool = True
    ) -> List[UUID]:
        """Get organization IDs that have a specific feature enabled/disabled."""
        pass

    @abstractmethod
    def cleanup_expired_plans(self) -> int:
        """Update status of expired plans. Returns count of updated plans."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List
from uuid import UUID

from ..entities.plan_feature import PlanFeature, FeatureCategory, FeatureType


class PlanFeatureRepository(ABC):
    """Plan feature repository interface for the Plans bounded context."""

    @abstractmethod
    def save(self, feature: PlanFeature) -> PlanFeature:
        """Save or update a plan feature."""
        pass

    @abstractmethod
    def get_by_id(self, feature_id: UUID) -> Optional[PlanFeature]:
        """Get feature by ID."""
        pass

    @abstractmethod
    def get_by_name(self, name: str) -> Optional[PlanFeature]:
        """Get feature by name."""
        pass

    @abstractmethod
    def get_by_category(self, category: FeatureCategory) -> List[PlanFeature]:
        """Get features by category."""
        pass

    @abstractmethod
    def get_by_type(self, feature_type: FeatureType) -> List[PlanFeature]:
        """Get features by type."""
        pass

    @abstractmethod
    def get_active_features(self) -> List[PlanFeature]:
        """Get all active features."""
        pass

    @abstractmethod
    def get_system_features(self) -> List[PlanFeature]:
        """Get all system features."""
        pass

    @abstractmethod
    def exists_by_name(self, name: str) -> bool:
        """Check if feature exists by name."""
        pass

    @abstractmethod
    def delete(self, feature_id: UUID) -> bool:
        """Delete feature by ID."""
        pass

    @abstractmethod
    def list_features(
        self,
        category: Optional[FeatureCategory] = None,
        is_active: Optional[bool] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[PlanFeature]:
        """List features with filtering and pagination."""
        pass

    @abstractmethod
    def search_features(self, query: str, limit: int = 100) -> List[PlanFeature]:
        """Search features by name or description."""
        pass

    @abstractmethod
    def count_features(
        self,
        category: Optional[FeatureCategory] = None,
        is_active: Optional[bool] = None,
    ) -> int:
        """Count features with optional filtering."""
        pass
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
from uuid import UUID

from ..entities.plan_resource import PlanResource, PlanResourceType


class PlanResourceRepository(ABC):
    """Plan resource repository interface for the Plans bounded context."""

    @abstractmethod
    def save(self, plan_resource: PlanResource) -> PlanResource:
        """Save or update a plan resource."""
        pass

    @abstractmethod
    def get_by_id(self, resource_id: UUID) -> Optional[PlanResource]:
        """Get plan resource by ID."""
        pass

    @abstractmethod
    def get_by_plan_id(self, plan_id: UUID) -> List[PlanResource]:
        """Get all resources for a plan."""
        pass

    @abstractmethod
    def get_by_plan_and_type(
        self, plan_id: UUID, resource_type: PlanResourceType
    ) -> Optional[PlanResource]:
        """Get specific resource type for a plan."""
        pass

    @abstractmethod
    def get_by_resource_type(
        self, resource_type: PlanResourceType
    ) -> List[PlanResource]:
        """Get all resources of a specific type."""
        pass

    @abstractmethod
    def get_active_resources(self, plan_id: UUID) -> List[PlanResource]:
        """Get all active resources for a plan."""
        pass

    @abstractmethod
    def delete(self, resource_id: UUID) -> bool:
        """Delete plan resource by ID."""
        pass

    @abstractmethod
    def delete_by_plan_id(self, plan_id: UUID) -> int:
        """Delete all resources for a plan. Returns count of deleted resources."""
        pass

    @abstractmethod
    def exists_by_plan_and_type(
        self, plan_id: UUID, resource_type: PlanResourceType
    ) -> bool:
        """Check if plan has specific resource type."""
        pass

    @abstractmethod
    def update_configuration(
        self, resource_id: UUID, configuration: Dict[str, Any]
    ) -> Optional[PlanResource]:
        """Update resource configuration."""
        pass

    @abstractmethod
    def activate_resource(self, resource_id: UUID) -> bool:
        """Activate a resource."""
        pass

    @abstractmethod
    def deactivate_resource(self, resource_id: UUID) -> bool:
        """Deactivate a resource."""
        pass

    @abstractmethod
    def list_resources(
        self,
        resource_type: Optional[PlanResourceType] = None,
        is_active: Optional[bool] = None,
        limit: int = 100,
        offset: int = 0,
    ) -> List[PlanResource]:
        """List plan resources with filtering and pagination."""
        pass

    @abstractmethod
    def count_resources(
        self,
        resource_type: Optional[PlanResourceType] = None,
        is_active: Optional[bool] = None,
    ) -> int:
        """Count plan resources with optional filtering."""
        pass

    @abstractmethod
    def get_resources_with_api_key(self, api_key_name: str) -> List[PlanResource]:
        """Get resources that have a specific API key configured."""
        pass

    @abstractmethod
    def validate_api_key_uniqueness(
        self,
        api_key_name: str,
        api_key_value: str,
        excluding_resource_id: Optional[UUID] = None,
    ) -> bool:
        """Check if API key value is unique across resources."""
        pass
from .plan_repository import PlanRepository
from .plan_resource_repository import PlanResourceRepository
from .plan_configuration_repository import PlanConfigurationRepository
from .organization_plan_repository import OrganizationPlanRepository
from .feature_usage_repository import FeatureUsageRepository
from .plan_feature_repository import PlanFeatureRepository
from .subscription_repository import SubscriptionRepository

__all__ = [
    "PlanRepository", 
    "PlanResourceRepository",
    "PlanConfigurationRepository",
    "OrganizationPlanRepository", 
    "FeatureUsageRepository",
    "PlanFeatureRepository",
    "SubscriptionRepository"
]
from abc import ABC, abstractmethod
from datetime import datetime
from typing import List, Optional, Tuple
from uuid import UUID

from ..entities.subscription import Subscription


class SubscriptionRepository(ABC):
    """Abstract repository for Subscription entities."""

    @abstractmethod
    def save(self, subscription: Subscription) -> Subscription:
        """Save a subscription entity."""
        pass

    @abstractmethod
    def find_by_id(self, subscription_id: UUID) -> Optional[Subscription]:
        """Find a subscription by ID."""
        pass

    @abstractmethod
    def find_by_organization(self, organization_id: UUID) -> List[Subscription]:
        """Find all subscriptions for an organization."""
        pass

    @abstractmethod
    def find_active_by_organization(self, organization_id: UUID) -> Optional[Subscription]:
        """Find active subscription for an organization."""
        pass

    @abstractmethod
    def find_by_plan(self, plan_id: UUID) -> List[Subscription]:
        """Find all subscriptions for a plan."""
        pass

    @abstractmethod
    def find_by_status(self, status: str) -> List[Subscription]:
        """Find subscriptions by status."""
        pass

    @abstractmethod
    def find_expiring_before(self, date: datetime) -> List[Subscription]:
        """Find subscriptions expiring before a date."""
        pass

    @abstractmethod
    def find_due_for_billing(self, date: datetime) -> List[Subscription]:
        """Find subscriptions due for billing."""
        pass

    @abstractmethod
    def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        plan_id: Optional[UUID] = None,
        status: Optional[str] = None,
        billing_cycle: Optional[str] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> Tuple[List[Subscription], int]:
        """Find subscriptions with pagination and filters.
        
        Returns:
            Tuple of (subscriptions, total_count)
        """
        pass

    @abstractmethod
    def delete(self, subscription_id: UUID) -> bool:
        """Delete a subscription (hard delete).
        
        Returns:
            True if subscription was deleted, False if not found
        """
        pass

    @abstractmethod
    def update_status(self, subscription_id: UUID, status: str) -> bool:
        """Update subscription status.
        
        Returns:
            True if subscription was updated, False if not found
        """
        pass

    @abstractmethod
    def cancel_subscription(
        self,
        subscription_id: UUID,
        cancelled_at: datetime,
        cancellation_reason: Optional[str] = None,
    ) -> bool:
        """Cancel a subscription.
        
        Args:
            subscription_id: ID of subscription to cancel
            cancelled_at: Timestamp when subscription was cancelled
            cancellation_reason: Optional reason for cancellation
            
        Returns:
            True if subscription was cancelled, False if not found
        """
        pass

    @abstractmethod
    def update_billing_date(
        self, subscription_id: UUID, next_billing_date: datetime
    ) -> bool:
        """Update subscription billing date.
        
        Returns:
            True if subscription was updated, False if not found
        """
        pass

    @abstractmethod
    def extend_subscription(
        self, subscription_id: UUID, new_end_date: datetime
    ) -> bool:
        """Extend subscription end date.
        
        Returns:
            True if subscription was extended, False if not found
        """
        pass

    @abstractmethod
    def change_plan(self, subscription_id: UUID, new_plan_id: UUID) -> bool:
        """Change subscription plan.
        
        Returns:
            True if plan was changed, False if not found
        """
        pass

    @abstractmethod
    def get_active_subscriptions_count(self) -> int:
        """Get count of active subscriptions."""
        pass

    @abstractmethod
    def get_revenue_by_period(self, start_date: datetime, end_date: datetime) -> dict:
        """Get revenue data for a period.
        
        Returns:
            Dictionary with revenue metrics for the period
        """
        pass
from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
from uuid import UUID

from ..entities.plan_configuration import PlanConfiguration


class PlanConfigurationRepository(ABC):
    """Plan configuration repository interface for the Plans bounded context."""

    @abstractmethod
    def save(self, plan_configuration: PlanConfiguration) -> PlanConfiguration:
        """Save or update a plan configuration."""
        pass

    @abstractmethod
    def get_by_id(self, configuration_id: UUID) -> Optional[PlanConfiguration]:
        """Get plan configuration by ID."""
        pass

    @abstractmethod
    def get_by_plan_id(self, plan_id: UUID) -> Optional[PlanConfiguration]:
        """Get configuration for a plan."""
        pass

    @abstractmethod
    def get_active_configurations(self) -> List[PlanConfiguration]:
        """Get all active plan configurations."""
        pass

    @abstractmethod
    def delete(self, configuration_id: UUID) -> bool:
        """Delete plan configuration by ID."""
        pass

    @abstractmethod
    def delete_by_plan_id(self, plan_id: UUID) -> bool:
        """Delete configuration for a plan."""
        pass

    @abstractmethod
    def exists_by_plan_id(self, plan_id: UUID) -> bool:
        """Check if plan has configuration."""
        pass

    @abstractmethod
    def update_api_keys(
        self, configuration_id: UUID, api_keys: Dict[str, str]
    ) -> Optional[PlanConfiguration]:
        """Update API keys in configuration."""
        pass

    @abstractmethod
    def update_limits(
        self, configuration_id: UUID, limits: Dict[str, int]
    ) -> Optional[PlanConfiguration]:
        """Update limits in configuration."""
        pass

    @abstractmethod
    def update_enabled_features(
        self, configuration_id: UUID, enabled_features: List[str]
    ) -> Optional[PlanConfiguration]:
        """Update enabled features in configuration."""
        pass

    @abstractmethod
    def activate_configuration(self, configuration_id: UUID) -> bool:
        """Activate a configuration."""
        pass

    @abstractmethod
    def deactivate_configuration(self, configuration_id: UUID) -> bool:
        """Deactivate a configuration."""
        pass

    @abstractmethod
    def list_configurations(
        self, is_active: Optional[bool] = None, limit: int = 100, offset: int = 0
    ) -> List[PlanConfiguration]:
        """List plan configurations with filtering and pagination."""
        pass

    @abstractmethod
    def count_configurations(self, is_active: Optional[bool] = None) -> int:
        """Count plan configurations with optional filtering."""
        pass

    @abstractmethod
    def get_configurations_with_feature(
        self, feature_name: str
    ) -> List[PlanConfiguration]:
        """Get configurations that have a specific feature enabled."""
        pass

    @abstractmethod
    def get_configurations_with_api_key(
        self, api_key_name: str
    ) -> List[PlanConfiguration]:
        """Get configurations that have a specific API key."""
        pass

    @abstractmethod
    def validate_api_key_uniqueness(
        self,
        api_key_name: str,
        api_key_value: str,
        excluding_configuration_id: Optional[UUID] = None,
    ) -> bool:
        """Check if API key value is unique across configurations."""
        pass

    @abstractmethod
    def bulk_update_configurations(
        self, updates: List[Dict[str, Any]]
    ) -> List[PlanConfiguration]:
        """Bulk update multiple configurations."""
        pass
from .entities import (
    Plan, PlanType, PlanFeature, PlanResource, PlanResourceType, 
    PlanConfiguration, OrganizationPlan, FeatureUsage
)
from .value_objects import (
    PlanName, Pricing, ChatWhatsAppConfiguration, ChatIframeConfiguration
)
from .repositories import (
    PlanRepository, PlanResourceRepository, PlanConfigurationRepository,
    OrganizationPlanRepository, FeatureUsageRepository, PlanFeatureRepository
)
from .services import (
    PlanManagementService, SubscriptionService, UsageTrackingService, 
    FeatureAccessService, PlanAuthorizationService
)

__all__ = [
    # Entities
    "Plan", "PlanType", "PlanFeature", "PlanResource", "PlanResourceType",
    "PlanConfiguration", "OrganizationPlan", "FeatureUsage",
    
    # Value Objects
    "PlanName", "Pricing", "ChatWhatsAppConfiguration", "ChatIframeConfiguration",
    
    # Repositories
    "PlanRepository", "PlanResourceRepository", "PlanConfigurationRepository",
    "OrganizationPlanRepository", "FeatureUsageRepository", "PlanFeatureRepository",
    
    # Services
    "PlanManagementService", "SubscriptionService", "UsageTrackingService", 
    "FeatureAccessService", "PlanAuthorizationService"
]
from fastapi import APIRouter

from .routes.plan_routes import router as plan_router
from .routes.subscription_routes import router as subscription_router
from .routes.plan_resource_routes import router as plan_resource_router

# Create main plans router
plans_api_router = APIRouter(prefix="/api/v1/plans", tags=["Plans Context"])

# Include all sub-routers
plans_api_router.include_router(plan_router)
plans_api_router.include_router(subscription_router)
plans_api_router.include_router(plan_resource_router)

__all__ = ["plans_api_router"]
from fastapi import Depends
from sqlalchemy.orm import Session

from shared.infrastructure.database.dependencies import get_db_session
from plans.application.use_cases.plan_use_cases import PlanUseCase
from plans.application.use_cases.subscription_use_cases import SubscriptionUseCase
from plans.application.use_cases.plan_resource_use_cases import PlanResourceUseCase
from plans.infrastructure.plans_unit_of_work import PlansUnitOfWork


def get_plans_uow(db: Session = Depends(get_db_session)) -> PlansUnitOfWork:
    """Get a PlansUnitOfWork instance with plan, subscription, and plan_resource repositories."""
    return PlansUnitOfWork(db, ["plan", "subscription", "plan_resource"])


def get_plan_use_case(uow: PlansUnitOfWork = Depends(get_plans_uow)) -> PlanUseCase:
    """Get PlanUseCase with proper UnitOfWork dependency."""
    return PlanUseCase(uow)


def get_subscription_use_case(uow: PlansUnitOfWork = Depends(get_plans_uow)) -> SubscriptionUseCase:
    """Get SubscriptionUseCase with proper UnitOfWork dependency."""
    return SubscriptionUseCase(uow)


def get_plan_resource_use_case(uow: PlansUnitOfWork = Depends(get_plans_uow)) -> PlanResourceUseCase:
    """Get PlanResourceUseCase with proper UnitOfWork dependency."""
    return PlanResourceUseCase(uow)
from fastapi import APIRouter, Depends, HTTPException, Query, status
from typing import Optional
from uuid import UUID

from ..dependencies import get_plan_resource_use_case
from ...application.dtos.plan_resource_dto import (
    PlanResourceCreateDTO,
    PlanResourceUpdateDTO,
    PlanResourceResponseDTO,
    PlanResourceListResponseDTO,
    PlanResourceTestDTO,
    PlanResourceTestResponseDTO,
    PlanResourceUsageDTO,
    PlanResourceUsageResponseDTO,
)
from ...application.use_cases.plan_resource_use_cases import PlanResourceUseCase

router = APIRouter(prefix="/plan-resources", tags=["Plan Resources"])


@router.post("/", response_model=PlanResourceResponseDTO, status_code=status.HTTP_201_CREATED)
async def create_plan_resource(
    dto: PlanResourceCreateDTO,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Create a new plan resource."""
    try:
        return use_case.create_plan_resource(dto)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{resource_id}", response_model=PlanResourceResponseDTO)
async def get_plan_resource_by_id(
    resource_id: UUID,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Get plan resource by ID."""
    try:
        resource = use_case.get_resource_by_id(resource_id)
        if not resource:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan resource not found",
            )
        return resource
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/", response_model=PlanResourceListResponseDTO)
async def list_plan_resources(
    plan_id: Optional[UUID] = Query(None, description="Filter by plan ID"),
    resource_type: Optional[str] = Query(None, description="Filter by resource type"),
    is_enabled: Optional[bool] = Query(None, description="Filter by enabled status"),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """List plan resources with pagination and filters."""
    try:
        return use_case.list_plan_resources(
            plan_id=plan_id,
            resource_type=resource_type,
            is_enabled=is_enabled,
            page=page,
            page_size=page_size
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/plan/{plan_id}")
async def get_plan_resources(
    plan_id: UUID,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Get all resources for a specific plan."""
    try:
        return use_case.get_plan_resources(plan_id)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.put("/{resource_id}", response_model=PlanResourceResponseDTO)
async def update_plan_resource(
    resource_id: UUID,
    dto: PlanResourceUpdateDTO,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Update plan resource configuration."""
    try:
        resource = use_case.update_plan_resource(resource_id, dto)
        if not resource:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan resource not found",
            )
        return resource
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{resource_id}/enable", response_model=PlanResourceResponseDTO)
async def enable_plan_resource(
    resource_id: UUID,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Enable a plan resource."""
    try:
        resource = use_case.enable_resource(resource_id)
        if not resource:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan resource not found",
            )
        return resource
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{resource_id}/disable", response_model=PlanResourceResponseDTO)
async def disable_plan_resource(
    resource_id: UUID,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Disable a plan resource."""
    try:
        resource = use_case.disable_resource(resource_id)
        if not resource:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan resource not found",
            )
        return resource
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/test", response_model=PlanResourceTestResponseDTO)
async def test_resource_configuration(
    dto: PlanResourceTestDTO,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Test a plan resource configuration."""
    try:
        return use_case.test_resource_configuration(dto)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/usage", status_code=status.HTTP_201_CREATED)
async def record_resource_usage(
    dto: PlanResourceUsageDTO,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Record usage of a plan resource."""
    try:
        success = use_case.record_resource_usage(dto)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Failed to record usage",
            )
        return {"message": "Usage recorded successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{resource_id}/usage", response_model=PlanResourceUsageResponseDTO)
async def get_resource_usage(
    resource_id: UUID,
    start_date: str = Query(..., description="Start date (YYYY-MM-DD)"),
    end_date: str = Query(..., description="End date (YYYY-MM-DD)"),
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Get usage statistics for a plan resource."""
    try:
        from datetime import datetime
        start_dt = datetime.strptime(start_date, "%Y-%m-%d")
        end_dt = datetime.strptime(end_date, "%Y-%m-%d")
        
        return use_case.get_resource_usage(resource_id, start_dt, end_dt)
    except ValueError as e:
        if "time data" in str(e):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid date format. Use YYYY-MM-DD",
            )
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{resource_id}/duplicate", response_model=PlanResourceResponseDTO)
async def duplicate_resource(
    resource_id: UUID,
    target_plan_id: UUID = Query(..., description="Target plan ID"),
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Duplicate a resource to another plan."""
    try:
        resource = use_case.duplicate_resource(resource_id, target_plan_id)
        if not resource:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan resource not found",
            )
        return resource
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{resource_id}")
async def delete_plan_resource(
    resource_id: UUID,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Delete a plan resource."""
    try:
        success = use_case.delete_plan_resource(resource_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan resource not found",
            )
        return {"message": "Plan resource deleted successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/types/{resource_type}/defaults")
async def get_resource_type_defaults(
    resource_type: str,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Get default configuration for a resource type."""
    try:
        from ...domain.entities.plan_resource import PlanResourceType
        from ...domain.services.plan_resource_service import PlanResourceService
        
        # Validate resource type
        try:
            resource_type_enum = PlanResourceType(resource_type)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid resource type: {resource_type}",
            )
        
        service = PlanResourceService()
        defaults = service.get_default_configuration(resource_type_enum)
        schema = service.get_configuration_schema(resource_type_enum)
        
        return {
            "resource_type": resource_type,
            "default_configuration": defaults,
            "configuration_schema": schema,
        }
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/types/{resource_type}/schema")
async def get_resource_type_schema(
    resource_type: str,
    use_case: PlanResourceUseCase = Depends(get_plan_resource_use_case),
):
    """Get configuration schema for a resource type."""
    try:
        from ...domain.entities.plan_resource import PlanResourceType
        from ...domain.services.plan_resource_service import PlanResourceService
        
        # Validate resource type
        try:
            resource_type_enum = PlanResourceType(resource_type)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid resource type: {resource_type}",
            )
        
        service = PlanResourceService()
        schema = service.get_configuration_schema(resource_type_enum)
        
        return {
            "resource_type": resource_type,
            "configuration_schema": schema,
        }
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
from fastapi import APIRouter, Depends, HTTPException, Query, status
from typing import Optional
from uuid import UUID

from ..dependencies import get_subscription_use_case
from ...application.dtos.subscription_dto import (
    SubscriptionCreateDTO,
    SubscriptionUpdateDTO,
    SubscriptionResponseDTO,
    SubscriptionListResponseDTO,
    SubscriptionUpgradeDTO,
    SubscriptionDowngradeDTO,
    SubscriptionCancellationDTO,
)
from ...application.use_cases.subscription_use_cases import SubscriptionUseCase

router = APIRouter(prefix="/subscriptions", tags=["Subscriptions"])


@router.post("/", response_model=SubscriptionResponseDTO, status_code=status.HTTP_201_CREATED)
async def create_subscription(
    dto: SubscriptionCreateDTO,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Create a new subscription."""
    try:
        return use_case.create_subscription(dto)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{subscription_id}", response_model=SubscriptionResponseDTO)
async def get_subscription_by_id(
    subscription_id: UUID,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Get subscription by ID."""
    try:
        subscription = use_case.get_subscription_by_id(subscription_id)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/", response_model=SubscriptionListResponseDTO)
async def list_subscriptions(
    organization_id: Optional[UUID] = Query(None, description="Filter by organization"),
    plan_id: Optional[UUID] = Query(None, description="Filter by plan"),
    status: Optional[str] = Query(None, description="Filter by status"),
    billing_cycle: Optional[str] = Query(None, description="Filter by billing cycle"),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """List subscriptions with pagination and filters."""
    try:
        return use_case.list_subscriptions(
            organization_id=organization_id,
            plan_id=plan_id,
            status=status,
            billing_cycle=billing_cycle,
            page=page,
            page_size=page_size
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/organization/{organization_id}", response_model=SubscriptionResponseDTO)
async def get_organization_subscription(
    organization_id: UUID,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Get active subscription for an organization."""
    try:
        subscription = use_case.get_organization_subscription(organization_id)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="No active subscription found for organization",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.put("/{subscription_id}", response_model=SubscriptionResponseDTO)
async def update_subscription(
    subscription_id: UUID,
    dto: SubscriptionUpdateDTO,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Update subscription information."""
    try:
        subscription = use_case.update_subscription(subscription_id, dto)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{subscription_id}/activate", response_model=SubscriptionResponseDTO)
async def activate_subscription(
    subscription_id: UUID,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Activate a subscription."""
    try:
        subscription = use_case.activate_subscription(subscription_id)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{subscription_id}/cancel", response_model=SubscriptionResponseDTO)
async def cancel_subscription(
    subscription_id: UUID,
    dto: SubscriptionCancellationDTO,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Cancel a subscription."""
    try:
        subscription = use_case.cancel_subscription(subscription_id, dto)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{subscription_id}/suspend", response_model=SubscriptionResponseDTO)
async def suspend_subscription(
    subscription_id: UUID,
    reason: Optional[str] = Query(None, description="Reason for suspension"),
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Suspend a subscription."""
    try:
        subscription = use_case.suspend_subscription(subscription_id, reason)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{subscription_id}/reactivate", response_model=SubscriptionResponseDTO)
async def reactivate_subscription(
    subscription_id: UUID,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Reactivate a suspended subscription."""
    try:
        subscription = use_case.reactivate_subscription(subscription_id)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{subscription_id}/upgrade", response_model=SubscriptionResponseDTO)
async def upgrade_subscription(
    subscription_id: UUID,
    dto: SubscriptionUpgradeDTO,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Upgrade a subscription to a higher plan."""
    try:
        subscription = use_case.upgrade_subscription(subscription_id, dto)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{subscription_id}/downgrade", response_model=SubscriptionResponseDTO)
async def downgrade_subscription(
    subscription_id: UUID,
    dto: SubscriptionDowngradeDTO,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Downgrade a subscription to a lower plan."""
    try:
        subscription = use_case.downgrade_subscription(subscription_id, dto)
        if not subscription:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return subscription
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{subscription_id}/extend")
async def extend_subscription(
    subscription_id: UUID,
    extension_days: int = Query(..., ge=1, le=3650, description="Days to extend subscription"),
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Extend subscription end date."""
    try:
        success = use_case.extend_subscription(subscription_id, extension_days)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return {"message": f"Subscription extended by {extension_days} days"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{subscription_id}/billing-history")
async def get_subscription_billing_history(
    subscription_id: UUID,
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Get subscription billing history."""
    try:
        history = use_case.get_subscription_billing_history(
            subscription_id, page, page_size
        )
        if not history:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return history
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{subscription_id}/usage")
async def get_subscription_usage(
    subscription_id: UUID,
    start_date: Optional[str] = Query(None, description="Start date (YYYY-MM-DD)"),
    end_date: Optional[str] = Query(None, description="End date (YYYY-MM-DD)"),
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Get subscription usage statistics."""
    try:
        usage = use_case.get_subscription_usage(subscription_id, start_date, end_date)
        if not usage:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return usage
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{subscription_id}")
async def delete_subscription(
    subscription_id: UUID,
    use_case: SubscriptionUseCase = Depends(get_subscription_use_case),
):
    """Delete a subscription (admin only)."""
    try:
        success = use_case.delete_subscription(subscription_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Subscription not found",
            )
        return {"message": "Subscription deleted successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
from fastapi import APIRouter, Depends, HTTPException, Query, status
from typing import Optional
from uuid import UUID

from ..dependencies import get_plan_use_case
from ...application.dtos.plan_dto import (
    PlanCreateDTO,
    PlanUpdateDTO,
    PlanResponseDTO,
    PlanListResponseDTO,
)
from ...application.use_cases.plan_use_cases import PlanUseCase

router = APIRouter(prefix="/plans", tags=["Plans"])


@router.post("/", response_model=PlanResponseDTO, status_code=status.HTTP_201_CREATED)
async def create_plan(
    dto: PlanCreateDTO,
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Create a new plan."""
    try:
        return use_case.create_plan(dto)
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{plan_id}", response_model=PlanResponseDTO)
async def get_plan_by_id(
    plan_id: UUID,
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Get plan by ID."""
    try:
        plan = use_case.get_plan_by_id(plan_id)
        if not plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan not found",
            )
        return plan
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/", response_model=PlanListResponseDTO)
async def list_plans(
    plan_type: Optional[str] = Query(None, description="Filter by plan type"),
    is_active: Optional[bool] = Query(None, description="Filter by active status"),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(20, ge=1, le=100, description="Items per page"),
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """List plans with pagination and filters."""
    try:
        return use_case.list_plans(
            plan_type=plan_type,
            is_active=is_active,
            page=page,
            page_size=page_size
        )
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.put("/{plan_id}", response_model=PlanResponseDTO)
async def update_plan(
    plan_id: UUID,
    dto: PlanUpdateDTO,
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Update plan information."""
    try:
        plan = use_case.update_plan(plan_id, dto)
        if not plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan not found",
            )
        return plan
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{plan_id}/activate", response_model=PlanResponseDTO)
async def activate_plan(
    plan_id: UUID,
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Activate a plan."""
    try:
        plan = use_case.activate_plan(plan_id)
        if not plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan not found",
            )
        return plan
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{plan_id}/deactivate", response_model=PlanResponseDTO)
async def deactivate_plan(
    plan_id: UUID,
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Deactivate a plan."""
    try:
        plan = use_case.deactivate_plan(plan_id)
        if not plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan not found",
            )
        return plan
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.delete("/{plan_id}")
async def delete_plan(
    plan_id: UUID,
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Delete a plan."""
    try:
        success = use_case.delete_plan(plan_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan not found",
            )
        return {"message": "Plan deleted successfully"}
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{plan_id}/pricing")
async def get_plan_pricing(
    plan_id: UUID,
    billing_cycle: Optional[str] = Query("monthly", description="Billing cycle"),
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Get plan pricing information."""
    try:
        pricing = use_case.get_plan_pricing(plan_id, billing_cycle)
        if not pricing:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan not found",
            )
        return pricing
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.get("/{plan_id}/features")
async def get_plan_features(
    plan_id: UUID,
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Get plan features and limits."""
    try:
        features = use_case.get_plan_features(plan_id)
        if not features:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan not found",
            )
        return features
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))


@router.post("/{plan_id}/duplicate", response_model=PlanResponseDTO)
async def duplicate_plan(
    plan_id: UUID,
    new_name: str = Query(..., description="Name for the duplicated plan"),
    use_case: PlanUseCase = Depends(get_plan_use_case),
):
    """Duplicate an existing plan."""
    try:
        plan = use_case.duplicate_plan(plan_id, new_name)
        if not plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Plan not found",
            )
        return plan
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
from .plan_routes import router as plan_router
from .subscription_routes import router as subscription_router
from .plan_resource_routes import router as plan_resource_router

__all__ = ["plan_router", "subscription_router", "plan_resource_router"]
from .routers import plans_api_router

__all__ = ["plans_api_router"]
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, field_validator

from ...domain.entities.plan_resource import PlanResourceType


class PlanResourceCreateDTO(BaseModel):
    """DTO for creating a new plan resource."""
    plan_id: UUID = Field(..., description="Plan ID")
    resource_type: PlanResourceType = Field(..., description="Resource type")
    configuration: Dict[str, Any] = Field(..., description="Resource configuration")
    is_enabled: bool = Field(True, description="Whether resource is enabled")
    
    @field_validator('configuration')
    @classmethod
    def validate_configuration(cls, v: Dict[str, Any], info) -> Dict[str, Any]:
        resource_type = info.data.get('resource_type')
        
        if resource_type == PlanResourceType.CHAT_WHATSAPP:
            required_fields = ['api_key', 'webhook_url', 'phone_number']
            for field in required_fields:
                if field not in v:
                    raise ValueError(f"WhatsApp configuration missing required field: {field}")
        
        elif resource_type == PlanResourceType.CHAT_IFRAME:
            required_fields = ['iframe_url', 'allowed_domains']
            for field in required_fields:
                if field not in v:
                    raise ValueError(f"Iframe configuration missing required field: {field}")
        
        return v


class PlanResourceUpdateDTO(BaseModel):
    """DTO for updating an existing plan resource."""
    configuration: Optional[Dict[str, Any]] = Field(None, description="Resource configuration")
    is_enabled: Optional[bool] = Field(None, description="Whether resource is enabled")
    
    @field_validator('configuration')
    @classmethod
    def validate_configuration(cls, v: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        if v is None:
            return v
        
        # Basic validation - specific validation will be done in use case
        if not isinstance(v, dict):
            raise ValueError("Configuration must be a dictionary")
        
        return v


class PlanResourceResponseDTO(BaseModel):
    """DTO for plan resource response data."""
    id: UUID
    plan_id: UUID
    plan_name: str
    resource_type: str
    configuration: Dict[str, Any]
    is_enabled: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    usage_count: int  # Number of times this resource has been used
    
    model_config = {"from_attributes": True}


class PlanResourceListResponseDTO(BaseModel):
    """DTO for paginated plan resource list response."""
    resources: List[PlanResourceResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class PlanResourceTestDTO(BaseModel):
    """DTO for testing plan resource configuration."""
    plan_id: UUID = Field(..., description="Plan ID")
    resource_type: PlanResourceType = Field(..., description="Resource type")
    test_configuration: Dict[str, Any] = Field(..., description="Configuration to test")
    test_parameters: Dict[str, Any] = Field(default_factory=dict, description="Test parameters")


class PlanResourceTestResponseDTO(BaseModel):
    """DTO for plan resource test response."""
    success: bool
    resource_type: str
    test_results: Dict[str, Any]
    error_message: Optional[str] = None
    performance_metrics: Dict[str, float] = Field(default_factory=dict)
    recommendations: List[str] = Field(default_factory=list)


class PlanResourceUsageDTO(BaseModel):
    """DTO for plan resource usage data."""
    resource_id: UUID
    organization_id: UUID
    resource_type: str
    usage_date: datetime
    usage_count: int
    usage_details: Dict[str, Any] = Field(default_factory=dict)
    cost: Optional[float] = None


class PlanResourceUsageResponseDTO(BaseModel):
    """DTO for plan resource usage response."""
    resource_id: UUID
    resource_type: str
    total_usage: int
    usage_period: str
    usage_breakdown: Dict[str, Any]
    cost_breakdown: Dict[str, float]
    usage_trends: List[Dict[str, Any]] = Field(default_factory=list)
from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from enum import Enum

from ...domain.entities.plan import PlanType


class PlanCreateDTO(BaseModel):
    """DTO for creating a new plan."""
    name: str = Field(..., min_length=2, max_length=100, description="Plan name")
    description: str = Field(..., max_length=500, description="Plan description")
    plan_type: PlanType = Field(..., description="Plan type")
    resources: Dict[str, Any] = Field(default_factory=dict, description="Plan resources configuration")
    price_monthly: Optional[float] = Field(None, ge=0, description="Monthly price")
    price_yearly: Optional[float] = Field(None, ge=0, description="Yearly price")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Plan name cannot be empty')
        return v.strip()
    
    @field_validator('resources')
    @classmethod
    def validate_resources(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        # Validate resource structure for known resource types
        for resource_type, config in v.items():
            if resource_type in ['chat_whatsapp', 'chat_iframe']:
                if not isinstance(config, dict):
                    raise ValueError(f"Resource {resource_type} must be a dictionary")
                if 'enabled' not in config:
                    raise ValueError(f"Resource {resource_type} must have 'enabled' field")
        return v


class PlanUpdateDTO(BaseModel):
    """DTO for updating an existing plan."""
    description: Optional[str] = Field(None, max_length=500, description="Plan description")
    resources: Optional[Dict[str, Any]] = Field(None, description="Plan resources configuration")
    price_monthly: Optional[float] = Field(None, ge=0, description="Monthly price")
    price_yearly: Optional[float] = Field(None, ge=0, description="Yearly price")
    
    @field_validator('resources')
    @classmethod
    def validate_resources(cls, v: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        if v is None:
            return v
        
        # Validate resource structure for known resource types
        for resource_type, config in v.items():
            if resource_type in ['chat_whatsapp', 'chat_iframe']:
                if not isinstance(config, dict):
                    raise ValueError(f"Resource {resource_type} must be a dictionary")
                if 'enabled' not in config:
                    raise ValueError(f"Resource {resource_type} must have 'enabled' field")
        return v


class PlanResponseDTO(BaseModel):
    """DTO for plan response data."""
    id: UUID
    name: str
    description: str
    plan_type: str
    resources: Dict[str, Any]
    price_monthly: Optional[float] = None
    price_yearly: Optional[float] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_active: bool
    subscription_count: int  # Number of active subscriptions
    
    model_config = {"from_attributes": True}


class PlanListResponseDTO(BaseModel):
    """DTO for paginated plan list response."""
    plans: List[PlanResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class PlanResourceConfigDTO(BaseModel):
    """DTO for plan resource configuration."""
    resource_type: str = Field(..., description="Resource type (e.g., chat_whatsapp, chat_iframe)")
    enabled: bool = Field(..., description="Whether resource is enabled")
    configuration: Dict[str, Any] = Field(default_factory=dict, description="Resource-specific configuration")
    limits: Dict[str, Any] = Field(default_factory=dict, description="Resource limits")


class PlanValidationRequestDTO(BaseModel):
    """DTO for plan validation request."""
    organization_id: UUID = Field(..., description="Organization ID")
    plan_id: UUID = Field(..., description="Plan ID")
    resource_type: str = Field(..., description="Resource type to validate")
    action: str = Field(..., description="Action to validate")
    context: Dict[str, Any] = Field(default_factory=dict, description="Additional context")


class PlanValidationResponseDTO(BaseModel):
    """DTO for plan validation response."""
    is_allowed: bool
    plan_name: str
    resource_type: str
    action: str
    reason: str
    current_usage: Optional[Dict[str, Any]] = None
    limits: Optional[Dict[str, Any]] = None
    suggestions: List[str] = Field(default_factory=list)
from datetime import datetime
from typing import Optional, List
from uuid import UUID
from pydantic import BaseModel, Field, field_validator
from enum import Enum


class SubscriptionStatusEnum(str, Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    CANCELLED = "cancelled"
    EXPIRED = "expired"


class BillingCycleEnum(str, Enum):
    MONTHLY = "monthly"
    YEARLY = "yearly"


class SubscriptionCreateDTO(BaseModel):
    """DTO for creating a new subscription."""
    organization_id: UUID = Field(..., description="Organization ID")
    plan_id: UUID = Field(..., description="Plan ID")
    billing_cycle: BillingCycleEnum = Field(..., description="Billing cycle")
    starts_at: Optional[datetime] = Field(None, description="Subscription start date")
    metadata: dict = Field(default_factory=dict, description="Additional metadata")
    
    @field_validator('starts_at')
    @classmethod
    def validate_starts_at(cls, v: Optional[datetime]) -> Optional[datetime]:
        if v and v < datetime.now():
            raise ValueError('Subscription start date cannot be in the past')
        return v


class SubscriptionUpdateDTO(BaseModel):
    """DTO for updating an existing subscription."""
    billing_cycle: Optional[BillingCycleEnum] = Field(None, description="Billing cycle")
    ends_at: Optional[datetime] = Field(None, description="Subscription end date")
    metadata: Optional[dict] = Field(None, description="Additional metadata")


class SubscriptionResponseDTO(BaseModel):
    """DTO for subscription response data."""
    id: UUID
    organization_id: UUID
    plan_id: UUID
    plan_name: str
    plan_type: str
    status: str
    billing_cycle: str
    starts_at: datetime
    ends_at: Optional[datetime] = None
    next_billing_date: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    metadata: dict
    is_trial: bool = False
    
    model_config = {"from_attributes": True}


class SubscriptionListResponseDTO(BaseModel):
    """DTO for paginated subscription list response."""
    subscriptions: List[SubscriptionResponseDTO]
    total: int
    page: int
    page_size: int
    total_pages: int


class SubscriptionUpgradeDTO(BaseModel):
    """DTO for subscription upgrade request."""
    new_plan_id: UUID = Field(..., description="New plan ID")
    billing_cycle: Optional[BillingCycleEnum] = Field(None, description="Billing cycle for new plan")
    upgrade_immediately: bool = Field(True, description="Whether to upgrade immediately")
    prorate: bool = Field(True, description="Whether to prorate the charges")


class SubscriptionDowngradeDTO(BaseModel):
    """DTO for subscription downgrade request."""
    new_plan_id: UUID = Field(..., description="New plan ID")
    billing_cycle: Optional[BillingCycleEnum] = Field(None, description="Billing cycle for new plan")
    downgrade_at_period_end: bool = Field(True, description="Whether to downgrade at the end of current period")


class SubscriptionCancellationDTO(BaseModel):
    """DTO for subscription cancellation request."""
    cancel_immediately: bool = Field(False, description="Whether to cancel immediately")
    cancellation_reason: Optional[str] = Field(None, max_length=500, description="Reason for cancellation")
    feedback: Optional[str] = Field(None, max_length=1000, description="User feedback")
from .plan_dto import (
    PlanCreateDTO, PlanUpdateDTO, PlanResponseDTO, PlanListResponseDTO,
    PlanResourceConfigDTO, PlanValidationRequestDTO, PlanValidationResponseDTO
)
from .subscription_dto import (
    SubscriptionCreateDTO, SubscriptionUpdateDTO, SubscriptionResponseDTO,
    SubscriptionListResponseDTO, SubscriptionUpgradeDTO, SubscriptionDowngradeDTO,
    SubscriptionCancellationDTO
)
from .plan_resource_dto import (
    PlanResourceCreateDTO, PlanResourceUpdateDTO, PlanResourceResponseDTO,
    PlanResourceListResponseDTO, PlanResourceTestDTO, PlanResourceTestResponseDTO,
    PlanResourceUsageDTO, PlanResourceUsageResponseDTO
)

__all__ = [
    # Plan DTOs
    "PlanCreateDTO", "PlanUpdateDTO", "PlanResponseDTO", "PlanListResponseDTO",
    "PlanResourceConfigDTO", "PlanValidationRequestDTO", "PlanValidationResponseDTO",
    
    # Subscription DTOs
    "SubscriptionCreateDTO", "SubscriptionUpdateDTO", "SubscriptionResponseDTO",
    "SubscriptionListResponseDTO", "SubscriptionUpgradeDTO", "SubscriptionDowngradeDTO",
    "SubscriptionCancellationDTO",
    
    # Plan Resource DTOs
    "PlanResourceCreateDTO", "PlanResourceUpdateDTO", "PlanResourceResponseDTO",
    "PlanResourceListResponseDTO", "PlanResourceTestDTO", "PlanResourceTestResponseDTO",
    "PlanResourceUsageDTO", "PlanResourceUsageResponseDTO"
]
from .dtos import (
    # Plan DTOs
    PlanCreateDTO, PlanUpdateDTO, PlanResponseDTO, PlanListResponseDTO,
    PlanResourceConfigDTO, PlanValidationRequestDTO, PlanValidationResponseDTO,
    
    # Subscription DTOs
    SubscriptionCreateDTO, SubscriptionUpdateDTO, SubscriptionResponseDTO,
    SubscriptionListResponseDTO, SubscriptionUpgradeDTO, SubscriptionDowngradeDTO,
    SubscriptionCancellationDTO,
    
    # Plan Resource DTOs
    PlanResourceCreateDTO, PlanResourceUpdateDTO, PlanResourceResponseDTO,
    PlanResourceListResponseDTO, PlanResourceTestDTO, PlanResourceTestResponseDTO,
    PlanResourceUsageDTO, PlanResourceUsageResponseDTO
)
from .use_cases import PlanUseCase, SubscriptionUseCase, PlanResourceUseCase

__all__ = [
    # DTOs
    "PlanCreateDTO", "PlanUpdateDTO", "PlanResponseDTO", "PlanListResponseDTO",
    "PlanResourceConfigDTO", "PlanValidationRequestDTO", "PlanValidationResponseDTO",
    "SubscriptionCreateDTO", "SubscriptionUpdateDTO", "SubscriptionResponseDTO",
    "SubscriptionListResponseDTO", "SubscriptionUpgradeDTO", "SubscriptionDowngradeDTO",
    "SubscriptionCancellationDTO",
    "PlanResourceCreateDTO", "PlanResourceUpdateDTO", "PlanResourceResponseDTO",
    "PlanResourceListResponseDTO", "PlanResourceTestDTO", "PlanResourceTestResponseDTO",
    "PlanResourceUsageDTO", "PlanResourceUsageResponseDTO",
    
    # Use Cases
    "PlanUseCase", "SubscriptionUseCase", "PlanResourceUseCase"
]
from datetime import datetime, timezone, timedelta
from typing import List, Optional
from uuid import UUID

from shared.domain.repositories.unit_of_work import UnitOfWork
from ...domain.entities.subscription import Subscription
from ...domain.repositories.subscription_repository import SubscriptionRepository
from ...domain.repositories.plan_repository import PlanRepository
from ...domain.services.subscription_service import SubscriptionService
from ..dtos.subscription_dto import (
    SubscriptionCreateDTO,
    SubscriptionUpdateDTO,
    SubscriptionResponseDTO,
    SubscriptionListResponseDTO,
    SubscriptionUpgradeDTO,
    SubscriptionDowngradeDTO,
    SubscriptionCancellationDTO,
)


class SubscriptionUseCase:
    """Use case for subscription management operations."""

    def __init__(self, uow: UnitOfWork):
        self._subscription_repository: SubscriptionRepository = uow.get_repository("subscription")
        self._plan_repository: PlanRepository = uow.get_repository("plan")
        self._subscription_service = SubscriptionService(uow)
        self._uow = uow

    def create_subscription(
        self, dto: SubscriptionCreateDTO
    ) -> SubscriptionResponseDTO:
        """Create a new subscription."""
        with self._uow:
            # Validate plan exists
            plan = self._plan_repository.find_by_id(dto.plan_id)
            if not plan:
                raise ValueError("Plan not found")

            if not plan.is_active:
                raise ValueError("Plan is not active")

            # Check if organization already has an active subscription
            existing_subscription = (
                self._subscription_repository.find_active_by_organization(
                    dto.organization_id
                )
            )
            if existing_subscription:
                raise ValueError("Organization already has an active subscription")

            # Create subscription
            subscription = self._subscription_service.create_subscription(
                organization_id=dto.organization_id,
                plan_id=dto.plan_id,
                billing_cycle=dto.billing_cycle,
                starts_at=dto.starts_at or datetime.now(timezone.utc),
                metadata=dto.metadata,
            )

        return self._build_subscription_response(subscription)

    def get_subscription_by_id(
        self, subscription_id: UUID
    ) -> Optional[SubscriptionResponseDTO]:
        """Get subscription by ID."""
        subscription = self._subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None

        return self._build_subscription_response(subscription)

    def update_subscription(
        self, subscription_id: UUID, dto: SubscriptionUpdateDTO
    ) -> Optional[SubscriptionResponseDTO]:
        """Update an existing subscription."""
        with self._uow:
            subscription = self._subscription_repository.find_by_id(subscription_id)
            if not subscription:
                return None

            # Update fields
            if dto.billing_cycle is not None:
                subscription.billing_cycle = dto.billing_cycle
            if dto.ends_at is not None:
                subscription.ends_at = dto.ends_at
            if dto.metadata is not None:
                subscription.metadata.update(dto.metadata)

            subscription.updated_at = datetime.now(timezone.utc)

            # Recalculate next billing date if billing cycle changed
            if dto.billing_cycle is not None:
                subscription.next_billing_date = (
                    self._subscription_service.calculate_next_billing_date(
                        subscription.starts_at, subscription.billing_cycle
                    )
                )

            updated_subscription = self._subscription_repository.save(subscription)

        return self._build_subscription_response(updated_subscription)

    def cancel_subscription(
        self, subscription_id: UUID, dto: SubscriptionCancellationDTO
    ) -> Optional[SubscriptionResponseDTO]:
        """Cancel a subscription."""
        with self._uow:
            subscription = self._subscription_repository.find_by_id(subscription_id)
            if not subscription:
                return None

            if subscription.status == "cancelled":
                raise ValueError("Subscription is already cancelled")

            # Cancel subscription
            cancelled_subscription = self._subscription_service.cancel_subscription(
                subscription_id=subscription_id,
                cancel_immediately=dto.cancel_immediately,
                cancellation_reason=dto.cancellation_reason,
            )

            # Store feedback if provided
            if dto.feedback:
                cancelled_subscription.metadata["cancellation_feedback"] = dto.feedback
                self._subscription_repository.save(cancelled_subscription)

        return self._build_subscription_response(cancelled_subscription)

    def upgrade_subscription(
        self, subscription_id: UUID, dto: SubscriptionUpgradeDTO
    ) -> Optional[SubscriptionResponseDTO]:
        """Upgrade a subscription to a higher plan."""
        subscription = self._subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None

        # Validate new plan
        new_plan = self.plan_repository.find_by_id(dto.new_plan_id)
        if not new_plan:
            raise ValueError("New plan not found")

        # Perform upgrade
        upgraded_subscription = self._subscription_service.upgrade_subscription(
            subscription_id=subscription_id,
            new_plan_id=dto.new_plan_id,
            billing_cycle=dto.billing_cycle or subscription.billing_cycle,
            upgrade_immediately=dto.upgrade_immediately,
            prorate=dto.prorate,
        )

        return self._build_subscription_response(upgraded_subscription)

    def downgrade_subscription(
        self, subscription_id: UUID, dto: SubscriptionDowngradeDTO
    ) -> Optional[SubscriptionResponseDTO]:
        """Downgrade a subscription to a lower plan."""
        subscription = self._subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None

        # Validate new plan
        new_plan = self.plan_repository.find_by_id(dto.new_plan_id)
        if not new_plan:
            raise ValueError("New plan not found")

        # Perform downgrade
        downgraded_subscription = self._subscription_service.downgrade_subscription(
            subscription_id=subscription_id,
            new_plan_id=dto.new_plan_id,
            billing_cycle=dto.billing_cycle or subscription.billing_cycle,
            downgrade_at_period_end=dto.downgrade_at_period_end,
        )

        return self._build_subscription_response(downgraded_subscription)

    def list_subscriptions(
        self,
        organization_id: Optional[UUID] = None,
        status: Optional[str] = None,
        plan_id: Optional[UUID] = None,
        page: int = 1,
        page_size: int = 20,
    ) -> SubscriptionListResponseDTO:
        """List subscriptions with pagination and filters."""
        offset = (page - 1) * page_size

        subscriptions, total = self._subscription_repository.find_paginated(
            organization_id=organization_id,
            status=status,
            plan_id=plan_id,
            offset=offset,
            limit=page_size,
        )

        subscription_responses = []
        for subscription in subscriptions:
            subscription_responses.append(
                self._build_subscription_response(subscription)
            )

        total_pages = (total + page_size - 1) // page_size

        return SubscriptionListResponseDTO(
            subscriptions=subscription_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_organization_subscription(
        self, organization_id: UUID
    ) -> Optional[SubscriptionResponseDTO]:
        """Get the active subscription for an organization."""
        subscription = self._subscription_repository.find_active_by_organization(
            organization_id
        )
        if not subscription:
            return None

        return self._build_subscription_response(subscription)

    def get_expiring_subscriptions(
        self, days_ahead: int = 7
    ) -> List[SubscriptionResponseDTO]:
        """Get subscriptions expiring within specified days."""
        cutoff_date = datetime.now(timezone.utc) + timedelta(days=days_ahead)

        subscriptions = self._subscription_repository.find_expiring_before(cutoff_date)

        subscription_responses = []
        for subscription in subscriptions:
            subscription_responses.append(
                self._build_subscription_response(subscription)
            )

        return subscription_responses

    def renew_subscription(
        self, subscription_id: UUID
    ) -> Optional[SubscriptionResponseDTO]:
        """Renew a subscription."""
        subscription = self._subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None

        # Renew subscription
        renewed_subscription = self._subscription_service.renew_subscription(
            subscription_id
        )

        return self._build_subscription_response(renewed_subscription)

    def pause_subscription(
        self, subscription_id: UUID
    ) -> Optional[SubscriptionResponseDTO]:
        """Pause a subscription."""
        subscription = self._subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None

        if subscription.status != "active":
            raise ValueError("Can only pause active subscriptions")

        subscription.status = "paused"
        subscription.metadata["paused_at"] = datetime.now(timezone.utc).isoformat()
        subscription.updated_at = datetime.now(timezone.utc)

        updated_subscription = self._subscription_repository.save(subscription)
        return self._build_subscription_response(updated_subscription)

    def resume_subscription(
        self, subscription_id: UUID
    ) -> Optional[SubscriptionResponseDTO]:
        """Resume a paused subscription."""
        subscription = self._subscription_repository.find_by_id(subscription_id)
        if not subscription:
            return None

        if subscription.status != "paused":
            raise ValueError("Can only resume paused subscriptions")

        subscription.status = "active"
        subscription.metadata["resumed_at"] = datetime.now(timezone.utc).isoformat()
        subscription.updated_at = datetime.now(timezone.utc)

        updated_subscription = self._subscription_repository.save(subscription)
        return self._build_subscription_response(updated_subscription)

    def _build_subscription_response(
        self, subscription: Subscription
    ) -> SubscriptionResponseDTO:
        """Build subscription response DTO."""
        # Get plan details
        plan = self._plan_repository.find_by_id(subscription.plan_id)
        plan_name = plan.name if plan else "Unknown Plan"
        plan_type = plan.plan_type if plan else "Unknown"

        return SubscriptionResponseDTO(
            id=subscription.id,
            organization_id=subscription.organization_id,
            plan_id=subscription.plan_id,
            plan_name=plan_name,
            plan_type=plan_type,
            status=subscription.status,
            billing_cycle=subscription.billing_cycle,
            starts_at=subscription.starts_at,
            ends_at=subscription.ends_at,
            next_billing_date=subscription.next_billing_date,
            created_at=subscription.created_at,
            updated_at=subscription.updated_at,
            metadata=subscription.metadata,
            is_trial=subscription.metadata.get("is_trial", False),
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID

from shared.domain.repositories.unit_of_work import UnitOfWork
from ...domain.entities.plan import Plan
from ...domain.repositories.plan_repository import PlanRepository
from ...domain.services.plan_authorization_service import PlanAuthorizationService
from ..dtos.plan_dto import (
    PlanCreateDTO,
    PlanUpdateDTO,
    PlanResponseDTO,
    PlanListResponseDTO,
    PlanValidationRequestDTO,
    PlanValidationResponseDTO,
)


class PlanUseCase:
    """Use case for plan management operations."""

    def __init__(self, uow: UnitOfWork):
        self._plan_repository: PlanRepository = uow.get_repository("plan")
        self._plan_authorization_service = PlanAuthorizationService(uow)
        self._uow = uow

    def create_plan(self, dto: PlanCreateDTO) -> PlanResponseDTO:
        """Create a new plan."""
        with self._uow:
            # Create plan entity
            plan = Plan(
                name=dto.name,
                description=dto.description,
                plan_type=dto.plan_type,
                resources=dto.resources,
                price_monthly=dto.price_monthly,
                price_yearly=dto.price_yearly,
                created_at=datetime.now(timezone.utc),
            )

            # Save plan
            saved_plan = self._plan_repository.save(plan)

        return self._build_plan_response(saved_plan)

    def get_plan_by_id(self, plan_id: UUID) -> Optional[PlanResponseDTO]:
        """Get plan by ID."""
        plan = self._plan_repository.find_by_id(plan_id)
        if not plan:
            return None

        return self._build_plan_response(plan)

    def update_plan(
        self, plan_id: UUID, dto: PlanUpdateDTO
    ) -> Optional[PlanResponseDTO]:
        """Update an existing plan."""
        with self._uow:
            plan = self._plan_repository.find_by_id(plan_id)
            if not plan:
                return None

            # Update fields
            if dto.description is not None:
                plan.description = dto.description
            if dto.resources is not None:
                plan.resources = dto.resources
            if dto.price_monthly is not None:
                plan.price_monthly = dto.price_monthly
            if dto.price_yearly is not None:
                plan.price_yearly = dto.price_yearly

            plan.updated_at = datetime.now(timezone.utc)

            # Save plan
            updated_plan = self._plan_repository.save(plan)

        return self._build_plan_response(updated_plan)

    def delete_plan(self, plan_id: UUID) -> bool:
        """Delete a plan (soft delete)."""
        with self._uow:
            plan = self._plan_repository.find_by_id(plan_id)
            if not plan:
                return False

            # Check if plan has active subscriptions
            subscription_count = self._plan_repository.get_active_subscription_count(plan_id)
            if subscription_count > 0:
                raise ValueError("Cannot delete plan with active subscriptions")

            plan.is_active = False
            plan.updated_at = datetime.now(timezone.utc)
            self._plan_repository.save(plan)

        return True

    def list_plans(
        self,
        plan_type: Optional[str] = None,
        is_active: Optional[bool] = None,
        page: int = 1,
        page_size: int = 20,
    ) -> PlanListResponseDTO:
        """List plans with pagination and filters."""
        offset = (page - 1) * page_size

        plans, total = self._plan_repository.find_paginated(
            plan_type=plan_type, is_active=is_active, offset=offset, limit=page_size
        )

        plan_responses = []
        for plan in plans:
            plan_responses.append(self._build_plan_response(plan))

        total_pages = (total + page_size - 1) // page_size

        return PlanListResponseDTO(
            plans=plan_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_active_plans(self) -> List[PlanResponseDTO]:
        """Get all active plans."""
        plans = self._plan_repository.find_active_plans()

        plan_responses = []
        for plan in plans:
            plan_responses.append(self._build_plan_response(plan))

        return plan_responses

    def get_plans_by_type(self, plan_type: str) -> List[PlanResponseDTO]:
        """Get plans by type."""
        plans = self._plan_repository.find_by_type(plan_type)

        plan_responses = []
        for plan in plans:
            plan_responses.append(self._build_plan_response(plan))

        return plan_responses

    def validate_plan_access(
        self, request_dto: PlanValidationRequestDTO
    ) -> PlanValidationResponseDTO:
        """Validate if an organization can access a plan resource."""
        plan = self._plan_repository.find_by_id(request_dto.plan_id)
        if not plan:
            return PlanValidationResponseDTO(
                is_allowed=False,
                plan_name="Unknown",
                resource_type=request_dto.resource_type,
                action=request_dto.action,
                reason="Plan not found",
            )

        # Use authorization service to check access
        is_allowed, reason, usage_info = (
            self._plan_authorization_service.can_access_resource(
                organization_id=request_dto.organization_id,
                plan_id=request_dto.plan_id,
                resource_type=request_dto.resource_type,
                action=request_dto.action,
                context=request_dto.context,
            )
        )

        suggestions = []
        if not is_allowed:
            if "limit" in reason.lower():
                suggestions.append("Consider upgrading your plan for higher limits")
            if "not enabled" in reason.lower():
                suggestions.append("This feature is not included in your current plan")

        return PlanValidationResponseDTO(
            is_allowed=is_allowed,
            plan_name=plan.name,
            resource_type=request_dto.resource_type,
            action=request_dto.action,
            reason=reason,
            current_usage=usage_info.get("current_usage") if usage_info else None,
            limits=usage_info.get("limits") if usage_info else None,
            suggestions=suggestions,
        )

    def get_plan_features(self, plan_id: UUID) -> Optional[Dict[str, Any]]:
        """Get detailed plan features and capabilities."""
        plan = self._plan_repository.find_by_id(plan_id)
        if not plan:
            return None

        # Build comprehensive feature list
        features = {
            "plan_info": {
                "id": str(plan.id),
                "name": plan.name,
                "type": plan.plan_type,
                "description": plan.description,
            },
            "resources": plan.resources,
            "pricing": {"monthly": plan.price_monthly, "yearly": plan.price_yearly},
            "capabilities": [],
        }

        # Add resource capabilities
        for resource_type, config in plan.resources.items():
            if isinstance(config, dict) and config.get("enabled", False):
                features["capabilities"].append(
                    {
                        "type": resource_type,
                        "enabled": True,
                        "limits": config.get("limits", {}),
                        "features": config.get("features", []),
                    }
                )

        return features

    def compare_plans(self, plan_ids: List[UUID]) -> Dict[str, Any]:
        """Compare multiple plans side by side."""
        plans = []
        for plan_id in plan_ids:
            plan = self._plan_repository.find_by_id(plan_id)
            if plan:
                plans.append(plan)

        if not plans:
            return {"error": "No valid plans found"}

        comparison = {"plans": [], "feature_matrix": {}, "pricing_comparison": {}}

        # Build plan summaries
        for plan in plans:
            comparison["plans"].append(
                {
                    "id": str(plan.id),
                    "name": plan.name,
                    "type": plan.plan_type,
                    "monthly_price": plan.price_monthly,
                    "yearly_price": plan.price_yearly,
                }
            )

        # Build feature matrix
        all_features = set()
        for plan in plans:
            all_features.update(plan.resources.keys())

        for feature in all_features:
            comparison["feature_matrix"][feature] = []
            for plan in plans:
                resource_config = plan.resources.get(feature, {})
                comparison["feature_matrix"][feature].append(
                    {
                        "plan_id": str(plan.id),
                        "enabled": resource_config.get("enabled", False),
                        "limits": resource_config.get("limits", {}),
                    }
                )

        # Pricing comparison
        comparison["pricing_comparison"] = {
            "monthly": [p.price_monthly for p in plans],
            "yearly": [p.price_yearly for p in plans],
            "best_value_monthly": min(
                (p for p in plans if p.price_monthly),
                key=lambda x: x.price_monthly or float("inf"),
                default=None,
            ),
            "best_value_yearly": min(
                (p for p in plans if p.price_yearly),
                key=lambda x: x.price_yearly or float("inf"),
                default=None,
            ),
        }

        return comparison

    def _build_plan_response(self, plan: Plan) -> PlanResponseDTO:
        """Build plan response DTO."""
        subscription_count = self._plan_repository.get_active_subscription_count(plan.id)

        return PlanResponseDTO(
            id=plan.id,
            name=plan.name,
            description=plan.description,
            plan_type=plan.plan_type,
            resources=plan.resources,
            price_monthly=plan.price_monthly,
            price_yearly=plan.price_yearly,
            created_at=plan.created_at,
            updated_at=plan.updated_at,
            is_active=plan.is_active,
            subscription_count=subscription_count,
        )
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID

from shared.domain.repositories.unit_of_work import UnitOfWork
from ...domain.entities.plan_resource import PlanResource
from ...domain.repositories.plan_resource_repository import PlanResourceRepository
from ...domain.repositories.plan_repository import PlanRepository
from ...domain.services.plan_resource_service import PlanResourceService
from ..dtos.plan_resource_dto import (
    PlanResourceCreateDTO,
    PlanResourceUpdateDTO,
    PlanResourceResponseDTO,
    PlanResourceListResponseDTO,
    PlanResourceTestDTO,
    PlanResourceTestResponseDTO,
    PlanResourceUsageDTO,
    PlanResourceUsageResponseDTO,
)


class PlanResourceUseCase:
    """Use case for plan resource management operations."""

    def __init__(
        self,
        plan_resource_repository: PlanResourceRepository,
        plan_repository: PlanRepository,
        plan_resource_service: PlanResourceService,
    ):
        self.plan_resource_repository = plan_resource_repository
        self.plan_repository = plan_repository
        self.plan_resource_service = plan_resource_service

    def create_plan_resource(
        self, dto: PlanResourceCreateDTO
    ) -> PlanResourceResponseDTO:
        """Create a new plan resource."""
        # Validate plan exists
        plan = self.plan_repository.find_by_id(dto.plan_id)
        if not plan:
            raise ValueError("Plan not found")

        # Check if resource already exists for this plan
        existing = self.plan_resource_repository.find_by_plan_and_type(
            dto.plan_id, dto.resource_type
        )
        if existing:
            raise ValueError(
                f"Resource {dto.resource_type} already exists for this plan"
            )

        # Create resource using factory method
        resource = PlanResource.create_resource(
            plan_id=dto.plan_id,
            resource_type=dto.resource_type,
            configuration=dto.configuration,
            is_enabled=dto.is_enabled,
        )

        # Save resource
        saved_resource = self.plan_resource_repository.save(resource)

        return self._build_resource_response(saved_resource)

    def get_resource_by_id(
        self, resource_id: UUID
    ) -> Optional[PlanResourceResponseDTO]:
        """Get plan resource by ID."""
        resource = self.plan_resource_repository.find_by_id(resource_id)
        if not resource:
            return None

        return self._build_resource_response(resource)

    def update_plan_resource(
        self, resource_id: UUID, dto: PlanResourceUpdateDTO
    ) -> Optional[PlanResourceResponseDTO]:
        """Update an existing plan resource."""
        with self._uow:
            resource = self._plan_resource_repository.find_by_id(resource_id)
            if not resource:
                return None

            # Update fields
            if dto.configuration is not None:
                # Validate configuration based on resource type
                validated_config = self._plan_resource_service.validate_configuration(
                    resource.resource_type, dto.configuration
                )
                resource.configuration = validated_config

            if dto.is_enabled is not None:
                resource.is_enabled = dto.is_enabled

            resource.updated_at = datetime.now(timezone.utc)

            # Save resource
            updated_resource = self._plan_resource_repository.save(resource)

        return self._build_resource_response(updated_resource)

    def delete_plan_resource(self, resource_id: UUID) -> bool:
        """Delete a plan resource."""
        with self._uow:
            resource = self._plan_resource_repository.find_by_id(resource_id)
            if not resource:
                return False

            # Check if resource is being used
            usage_count = self._plan_resource_repository.get_usage_count(resource_id)
            if usage_count > 0:
                # Soft delete if in use
                resource.is_enabled = False
                resource.updated_at = datetime.now(timezone.utc)
                self._plan_resource_repository.save(resource)
            else:
                # Hard delete if not in use
                self._plan_resource_repository.delete(resource_id)

        return True

    def list_plan_resources(
        self,
        plan_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
        is_enabled: Optional[bool] = None,
        page: int = 1,
        page_size: int = 20,
    ) -> PlanResourceListResponseDTO:
        """List plan resources with pagination and filters."""
        offset = (page - 1) * page_size

        resources, total = self.plan_resource_repository.find_paginated(
            plan_id=plan_id,
            resource_type=resource_type,
            is_enabled=is_enabled,
            offset=offset,
            limit=page_size,
        )

        resource_responses = []
        for resource in resources:
            resource_responses.append(self._build_resource_response(resource))

        total_pages = (total + page_size - 1) // page_size

        return PlanResourceListResponseDTO(
            resources=resource_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )

    def get_plan_resources(self, plan_id: UUID) -> List[PlanResourceResponseDTO]:
        """Get all resources for a specific plan."""
        resources = self.plan_resource_repository.find_by_plan(plan_id)

        resource_responses = []
        for resource in resources:
            resource_responses.append(self._build_resource_response(resource))

        return resource_responses

    def test_resource_configuration(
        self, dto: PlanResourceTestDTO
    ) -> PlanResourceTestResponseDTO:
        """Test a plan resource configuration."""
        start_time = datetime.now(timezone.utc)

        try:
            # Test the configuration
            test_results = self.plan_resource_service.test_configuration(
                resource_type=dto.resource_type,
                configuration=dto.test_configuration,
                test_parameters=dto.test_parameters,
            )

            end_time = datetime.now(timezone.utc)
            test_duration = (end_time - start_time).total_seconds() * 1000

            # Generate recommendations based on test results
            recommendations = self._generate_configuration_recommendations(
                dto.resource_type, dto.test_configuration, test_results
            )

            return PlanResourceTestResponseDTO(
                success=test_results.get("success", False),
                resource_type=dto.resource_type,
                test_results=test_results,
                performance_metrics={"test_duration_ms": test_duration},
                recommendations=recommendations,
            )

        except Exception as e:
            end_time = datetime.now(timezone.utc)
            test_duration = (end_time - start_time).total_seconds() * 1000

            return PlanResourceTestResponseDTO(
                success=False,
                resource_type=dto.resource_type,
                test_results={},
                error_message=str(e),
                performance_metrics={"test_duration_ms": test_duration},
            )

    def record_resource_usage(self, dto: PlanResourceUsageDTO) -> bool:
        """Record usage of a plan resource."""
        return self.plan_resource_repository.record_usage(
            resource_id=dto.resource_id,
            organization_id=dto.organization_id,
            usage_date=dto.usage_date,
            usage_count=dto.usage_count,
            usage_details=dto.usage_details,
            cost=dto.cost,
        )

    def get_resource_usage(
        self, resource_id: UUID, start_date: datetime, end_date: datetime
    ) -> PlanResourceUsageResponseDTO:
        """Get usage statistics for a plan resource."""
        usage_data = self.plan_resource_repository.get_usage_statistics(
            resource_id=resource_id, start_date=start_date, end_date=end_date
        )

        resource = self.plan_resource_repository.find_by_id(resource_id)
        resource_type = resource.resource_type if resource else "Unknown"

        return PlanResourceUsageResponseDTO(
            resource_id=resource_id,
            resource_type=resource_type,
            total_usage=usage_data.get("total_usage", 0),
            usage_period=f"{start_date.date()} to {end_date.date()}",
            usage_breakdown=usage_data.get("breakdown", {}),
            cost_breakdown=usage_data.get("costs", {}),
            usage_trends=usage_data.get("trends", []),
        )

    def enable_resource(self, resource_id: UUID) -> Optional[PlanResourceResponseDTO]:
        """Enable a plan resource."""
        with self._uow:
            resource = self._plan_resource_repository.find_by_id(resource_id)
            if not resource:
                return None

            resource.is_enabled = True
            resource.updated_at = datetime.now(timezone.utc)

            updated_resource = self._plan_resource_repository.save(resource)
            
        return self._build_resource_response(updated_resource)

    def disable_resource(self, resource_id: UUID) -> Optional[PlanResourceResponseDTO]:
        """Disable a plan resource."""
        with self._uow:
            resource = self._plan_resource_repository.find_by_id(resource_id)
            if not resource:
                return None

            resource.is_enabled = False
            resource.updated_at = datetime.now(timezone.utc)

            updated_resource = self._plan_resource_repository.save(resource)
            
        return self._build_resource_response(updated_resource)

    def duplicate_resource(
        self, resource_id: UUID, target_plan_id: UUID
    ) -> Optional[PlanResourceResponseDTO]:
        """Duplicate a resource to another plan."""
        with self._uow:
            source_resource = self._plan_resource_repository.find_by_id(resource_id)
            if not source_resource:
                return None

            # Validate target plan exists
            target_plan = self._plan_repository.find_by_id(target_plan_id)
            if not target_plan:
                raise ValueError("Target plan not found")

            # Check if resource already exists in target plan
            existing = self._plan_resource_repository.find_by_plan_and_type(
                target_plan_id, source_resource.resource_type
            )
            if existing:
                raise ValueError("Resource already exists in target plan")

            # Create duplicate
            duplicate_resource = PlanResource.create_resource(
                plan_id=target_plan_id,
                resource_type=source_resource.resource_type,
                configuration=source_resource.configuration.copy(),
                is_enabled=source_resource.is_enabled,
            )

            saved_duplicate = self._plan_resource_repository.save(duplicate_resource)
            
        return self._build_resource_response(saved_duplicate)

    def _generate_configuration_recommendations(
        self,
        resource_type: str,
        configuration: Dict[str, Any],
        test_results: Dict[str, Any],
    ) -> List[str]:
        """Generate configuration recommendations based on test results."""
        recommendations = []

        if resource_type == "chat_whatsapp":
            if not test_results.get("webhook_reachable", True):
                recommendations.append(
                    "Ensure webhook URL is accessible from external networks"
                )
            if test_results.get("response_time_ms", 0) > 2000:
                recommendations.append(
                    "Consider optimizing webhook response time (currently > 2s)"
                )

        elif resource_type == "chat_iframe":
            if not test_results.get("domains_valid", True):
                recommendations.append(
                    "Verify all allowed domains are correctly formatted"
                )
            if test_results.get("load_time_ms", 0) > 3000:
                recommendations.append("Consider optimizing iframe content load time")

        # General recommendations
        if not test_results.get("success", False):
            recommendations.append(
                "Review configuration parameters and ensure all required fields are provided"
            )

        return recommendations

    def _build_resource_response(
        self, resource: PlanResource
    ) -> PlanResourceResponseDTO:
        """Build plan resource response DTO."""
        # Get plan name
        plan = self.plan_repository.find_by_id(resource.plan_id)
        plan_name = plan.name if plan else "Unknown Plan"

        # Get usage count
        usage_count = self.plan_resource_repository.get_usage_count(resource.id)

        return PlanResourceResponseDTO(
            id=resource.id,
            plan_id=resource.plan_id,
            plan_name=plan_name,
            resource_type=resource.resource_type,
            configuration=resource.configuration,
            is_enabled=resource.is_enabled,
            created_at=resource.created_at,
            updated_at=resource.updated_at,
            usage_count=usage_count,
        )
from .plan_use_cases import PlanUseCase
from .subscription_use_cases import SubscriptionUseCase
from .plan_resource_use_cases import PlanResourceUseCase

__all__ = [
    "PlanUseCase",
    "SubscriptionUseCase", 
    "PlanResourceUseCase"
]
from sqlalchemy import Column, String, Boolean, ForeignKey, Text, Enum, Integer, Numeric, DateTime
from sqlalchemy.dialects.postgresql import UUID, JSON
from sqlalchemy.sql import func
import enum

from shared.infrastructure.database.models.base import BaseModel


class PlanTypeEnum(str, enum.Enum):
    BASIC = "basic"
    PREMIUM = "premium"
    ENTERPRISE = "enterprise"


class PlanResourceTypeEnum(str, enum.Enum):
    CHAT_WHATSAPP = "chat_whatsapp"
    CHAT_IFRAME = "chat_iframe"


class SubscriptionStatusEnum(str, enum.Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    CANCELLED = "cancelled"
    EXPIRED = "expired"
    TRIAL = "trial"
    SUSPENDED = "suspended"


class BillingCycleEnum(str, enum.Enum):
    MONTHLY = "monthly"
    YEARLY = "yearly"
    QUARTERLY = "quarterly"
    WEEKLY = "weekly"


class PlanModel(BaseModel):
    """SQLAlchemy model for Plan entity."""
    __tablename__ = "plans"

    name = Column(String(100), nullable=False, unique=True, index=True)
    description = Column(Text, nullable=False)
    plan_type = Column(Enum(PlanTypeEnum), nullable=False, index=True)
    resources = Column(JSON, nullable=False, default={})  # Plan resources configuration
    price_monthly = Column(Numeric(10, 2), nullable=True)
    price_yearly = Column(Numeric(10, 2), nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    features = Column(JSON, nullable=False, default=[])  # List of plan features
    limits = Column(JSON, nullable=False, default={})  # Plan limits configuration


class PlanResourceModel(BaseModel):
    """SQLAlchemy model for PlanResource entity."""
    __tablename__ = "plan_resources"

    plan_id = Column(UUID(as_uuid=True), ForeignKey("plans.id"), nullable=False, index=True)
    resource_type = Column(Enum(PlanResourceTypeEnum), nullable=False, index=True)
    configuration = Column(JSON, nullable=False, default={})  # Resource-specific configuration
    is_enabled = Column(Boolean, default=True, nullable=False)
    limits = Column(JSON, nullable=False, default={})  # Resource limits
    
    # Ensure unique resource type per plan
    __table_args__ = (
        {'postgresql_unique': ['plan_id', 'resource_type']},
    )


class SubscriptionModel(BaseModel):
    """SQLAlchemy model for Subscription entity."""
    __tablename__ = "subscriptions"

    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True)
    plan_id = Column(UUID(as_uuid=True), ForeignKey("plans.id"), nullable=False, index=True)
    status = Column(Enum(SubscriptionStatusEnum), nullable=False, default=SubscriptionStatusEnum.PENDING, index=True)
    billing_cycle = Column(Enum(BillingCycleEnum), nullable=False, index=True)
    starts_at = Column(DateTime(timezone=True), nullable=False, index=True)
    ends_at = Column(DateTime(timezone=True), nullable=True)
    next_billing_date = Column(DateTime(timezone=True), nullable=True)
    cancelled_at = Column(DateTime(timezone=True), nullable=True)
    metadata = Column(JSON, nullable=False, default={})  # Additional subscription data
    
    # Ensure one active subscription per organization
    __table_args__ = (
        {'postgresql_where': 'status = \'active\''},
    )


class PlanConfigurationModel(BaseModel):
    """SQLAlchemy model for PlanConfiguration entity."""
    __tablename__ = "plan_configurations"

    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True)
    plan_id = Column(UUID(as_uuid=True), ForeignKey("plans.id"), nullable=False, index=True)
    configuration_data = Column(JSON, nullable=False, default={})  # Configuration settings
    api_keys = Column(JSON, nullable=False, default={})  # Encrypted API keys
    limits = Column(JSON, nullable=False, default={})  # Custom limits
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Ensure unique configuration per organization-plan
    __table_args__ = (
        {'postgresql_unique': ['organization_id', 'plan_id']},
    )


class FeatureUsageModel(BaseModel):
    """SQLAlchemy model for FeatureUsage entity."""
    __tablename__ = "feature_usage"

    organization_id = Column(UUID(as_uuid=True), ForeignKey("organizations.id"), nullable=False, index=True)
    resource_type = Column(String(50), nullable=False, index=True)
    feature_name = Column(String(100), nullable=False, index=True)
    usage_count = Column(Integer, default=0, nullable=False)
    usage_date = Column(DateTime(timezone=True), nullable=False, index=True)
    usage_details = Column(JSON, nullable=False, default={})  # Detailed usage information
    cost = Column(Numeric(10, 4), nullable=True)  # Cost associated with usage
    
    # Index for efficient usage queries
    __table_args__ = (
        {'postgresql_index': ['organization_id', 'resource_type', 'usage_date']},
    )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete, and_
from sqlalchemy.exc import IntegrityError

from ...domain.entities.subscription import Subscription, SubscriptionStatus, BillingCycle
from ...domain.repositories.subscription_repository import SubscriptionRepository
from ...infrastructure.database.models import (
    SubscriptionModel,
    SubscriptionStatusEnum,
    BillingCycleEnum,
)


class SqlAlchemySubscriptionRepository(SubscriptionRepository):
    """SQLAlchemy implementation of SubscriptionRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, subscription: Subscription) -> Subscription:
        """Save a subscription entity."""
        try:
            # Check if subscription exists
            existing = self.session.get(SubscriptionModel, subscription.id)

            if existing:
                # Update existing subscription
                existing.organization_id = subscription.organization_id
                existing.plan_id = subscription.plan_id
                existing.status = SubscriptionStatusEnum(subscription.status.value)
                existing.billing_cycle = BillingCycleEnum(subscription.billing_cycle.value)
                existing.starts_at = subscription.starts_at
                existing.ends_at = subscription.ends_at
                existing.next_billing_date = subscription.next_billing_date
                existing.cancelled_at = subscription.cancelled_at
                existing.metadata = subscription.metadata
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new subscription
                subscription_model = SubscriptionModel(
                    id=subscription.id,
                    organization_id=subscription.organization_id,
                    plan_id=subscription.plan_id,
                    status=SubscriptionStatusEnum(subscription.status.value),
                    billing_cycle=BillingCycleEnum(subscription.billing_cycle.value),
                    starts_at=subscription.starts_at,
                    ends_at=subscription.ends_at,
                    next_billing_date=subscription.next_billing_date,
                    cancelled_at=subscription.cancelled_at,
                    metadata=subscription.metadata,
                    created_at=subscription.created_at,
                    updated_at=subscription.updated_at,
                )

                self.session.add(subscription_model)
                self.session.flush()
                return self._to_domain_entity(subscription_model)

        except IntegrityError as e:
            raise e

    def find_by_id(self, subscription_id: UUID) -> Optional[Subscription]:
        """Find a subscription by ID."""
        result = self.session.execute(
            select(SubscriptionModel).where(SubscriptionModel.id == subscription_id)
        )
        subscription_model = result.scalar_one_or_none()

        if subscription_model:
            return self._to_domain_entity(subscription_model)
        return None

    def find_by_organization(self, organization_id: UUID) -> List[Subscription]:
        """Find all subscriptions for an organization."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                SubscriptionModel.organization_id == organization_id
            )
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_active_by_organization(
        self, organization_id: UUID
    ) -> Optional[Subscription]:
        """Find active subscription for an organization."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                and_(
                    SubscriptionModel.organization_id == organization_id,
                    SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE,
                )
            )
        )
        subscription_model = result.scalar_one_or_none()

        if subscription_model:
            return self._to_domain_entity(subscription_model)
        return None

    def find_by_plan(self, plan_id: UUID) -> List[Subscription]:
        """Find all subscriptions for a plan."""
        result = self.session.execute(
            select(SubscriptionModel).where(SubscriptionModel.plan_id == plan_id)
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_by_status(self, status: str) -> List[Subscription]:
        """Find subscriptions by status."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                SubscriptionModel.status == SubscriptionStatusEnum(status)
            )
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_expiring_before(self, date: datetime) -> List[Subscription]:
        """Find subscriptions expiring before a date."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                and_(
                    SubscriptionModel.ends_at <= date,
                    SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE,
                )
            )
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_due_for_billing(self, date: datetime) -> List[Subscription]:
        """Find subscriptions due for billing."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                and_(
                    SubscriptionModel.next_billing_date <= date,
                    SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE,
                )
            )
        )
        subscription_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in subscription_models]

    def find_paginated(
        self,
        organization_id: Optional[UUID] = None,
        plan_id: Optional[UUID] = None,
        status: Optional[str] = None,
        billing_cycle: Optional[str] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Subscription], int]:
        """Find subscriptions with pagination and filters."""
        query = select(SubscriptionModel)
        count_query = select(SubscriptionModel)

        # Apply filters
        if organization_id:
            query = query.where(SubscriptionModel.organization_id == organization_id)
            count_query = count_query.where(
                SubscriptionModel.organization_id == organization_id
            )

        if plan_id:
            query = query.where(SubscriptionModel.plan_id == plan_id)
            count_query = count_query.where(SubscriptionModel.plan_id == plan_id)

        if status:
            query = query.where(
                SubscriptionModel.status == SubscriptionStatusEnum(status)
            )
            count_query = count_query.where(
                SubscriptionModel.status == SubscriptionStatusEnum(status)
            )

        if billing_cycle:
            query = query.where(
                SubscriptionModel.billing_cycle == BillingCycleEnum(billing_cycle)
            )
            count_query = count_query.where(
                SubscriptionModel.billing_cycle == BillingCycleEnum(billing_cycle)
            )

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(SubscriptionModel.created_at.desc())
        )
        result = self.session.execute(query)
        subscription_models = result.scalars().all()

        subscriptions = [self._to_domain_entity(model) for model in subscription_models]
        return subscriptions, total

    def delete(self, subscription_id: UUID) -> bool:
        """Delete a subscription (hard delete)."""
        result = self.session.execute(
            delete(SubscriptionModel).where(SubscriptionModel.id == subscription_id)
        )
        return result.rowcount > 0

    def update_status(self, subscription_id: UUID, status: str) -> bool:
        """Update subscription status."""
        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(
                status=SubscriptionStatusEnum(status),
                updated_at=datetime.now(timezone.utc),
            )
        )
        return result.rowcount > 0

    def cancel_subscription(
        self,
        subscription_id: UUID,
        cancelled_at: datetime,
        cancellation_reason: Optional[str] = None,
    ) -> bool:
        """Cancel a subscription."""
        update_values = {
            "status": SubscriptionStatusEnum.CANCELLED,
            "cancelled_at": cancelled_at,
            "updated_at": datetime.now(timezone.utc),
        }

        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(**update_values)
        )

        # Update metadata with cancellation reason if provided
        if cancellation_reason and result.rowcount > 0:
            subscription = self.find_by_id(subscription_id)
            if subscription:
                subscription.metadata["cancellation_reason"] = cancellation_reason
                self.save(subscription)

        return result.rowcount > 0

    def update_billing_date(
        self, subscription_id: UUID, next_billing_date: datetime
    ) -> bool:
        """Update subscription billing date."""
        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(
                next_billing_date=next_billing_date,
                updated_at=datetime.now(timezone.utc),
            )
        )
        return result.rowcount > 0

    def extend_subscription(
        self, subscription_id: UUID, new_end_date: datetime
    ) -> bool:
        """Extend subscription end date."""
        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(ends_at=new_end_date, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def change_plan(self, subscription_id: UUID, new_plan_id: UUID) -> bool:
        """Change subscription plan."""
        result = self.session.execute(
            update(SubscriptionModel)
            .where(SubscriptionModel.id == subscription_id)
            .values(plan_id=new_plan_id, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def get_active_subscriptions_count(self) -> int:
        """Get count of active subscriptions."""
        result = self.session.execute(
            select(SubscriptionModel).where(
                SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE
            )
        )
        return len(result.scalars().all())

    def get_revenue_by_period(self, start_date: datetime, end_date: datetime) -> dict:
        """Get revenue data for a period."""
        # This would typically involve joining with billing/payment tables
        # For now, return a placeholder implementation
        result = self.session.execute(
            select(SubscriptionModel).where(
                and_(
                    SubscriptionModel.created_at >= start_date,
                    SubscriptionModel.created_at <= end_date,
                    SubscriptionModel.status == SubscriptionStatusEnum.ACTIVE,
                )
            )
        )
        subscriptions = result.scalars().all()

        return {
            "subscription_count": len(subscriptions),
            "period_start": start_date,
            "period_end": end_date,
        }

    def _to_domain_entity(self, subscription_model: SubscriptionModel) -> Subscription:
        """Convert SQLAlchemy model to domain entity."""
        return Subscription(
            id=subscription_model.id,
            organization_id=subscription_model.organization_id,
            plan_id=subscription_model.plan_id,
            status=SubscriptionStatus(subscription_model.status.value),
            billing_cycle=BillingCycle(subscription_model.billing_cycle.value),
            starts_at=subscription_model.starts_at,
            ends_at=subscription_model.ends_at,
            next_billing_date=subscription_model.next_billing_date,
            cancelled_at=subscription_model.cancelled_at,
            metadata=subscription_model.metadata or {},
            created_at=subscription_model.created_at,
            updated_at=subscription_model.updated_at,
        )
from datetime import datetime, timezone
from typing import List, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete, and_, text
from sqlalchemy.exc import IntegrityError

from ...domain.entities.plan import Plan
from ...domain.repositories.plan_repository import PlanRepository
from ...domain.value_objects.plan_name import PlanName
from ...infrastructure.database.models import PlanModel, PlanTypeEnum


class SqlAlchemyPlanRepository(PlanRepository):
    """SQLAlchemy implementation of PlanRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, plan: Plan) -> Plan:
        """Save a plan entity."""
        try:
            # Check if plan exists
            existing = self.session.get(PlanModel, plan.id)

            if existing:
                # Update existing plan
                existing.name = plan.name.value
                existing.description = plan.description
                existing.plan_type = PlanTypeEnum(plan.plan_type)
                existing.resources = plan.resources
                existing.price_monthly = plan.price_monthly
                existing.price_yearly = plan.price_yearly
                existing.is_active = plan.is_active
                existing.features = plan.features if hasattr(plan, "features") else []
                existing.limits = plan.limits if hasattr(plan, "limits") else {}
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new plan
                plan_model = PlanModel(
                    id=plan.id,
                    name=plan.name.value,
                    description=plan.description,
                    plan_type=PlanTypeEnum(plan.plan_type),
                    resources=plan.resources,
                    price_monthly=plan.price_monthly,
                    price_yearly=plan.price_yearly,
                    is_active=plan.is_active,
                    features=plan.features if hasattr(plan, "features") else [],
                    limits=plan.limits if hasattr(plan, "limits") else {},
                    created_at=plan.created_at,
                    updated_at=plan.updated_at,
                )

                self.session.add(plan_model)
                self.session.flush()
                return self._to_domain_entity(plan_model)

        except IntegrityError as e:
            if "name" in str(e):
                raise ValueError(f"Plan with name '{plan.name.value}' already exists")
            raise e

    def find_by_id(self, plan_id: UUID) -> Optional[Plan]:
        """Find a plan by ID."""
        result = self.session.execute(select(PlanModel).where(PlanModel.id == plan_id))
        plan_model = result.scalar_one_or_none()

        if plan_model:
            return self._to_domain_entity(plan_model)
        return None

    def find_by_name(self, name: PlanName) -> Optional[Plan]:
        """Find a plan by name."""
        result = self.session.execute(
            select(PlanModel).where(PlanModel.name == name.value)
        )
        plan_model = result.scalar_one_or_none()

        if plan_model:
            return self._to_domain_entity(plan_model)
        return None

    def find_by_type(self, plan_type: str) -> List[Plan]:
        """Find plans by type."""
        result = self.session.execute(
            select(PlanModel).where(
                and_(
                    PlanModel.plan_type == PlanTypeEnum(plan_type),
                    PlanModel.is_active,
                )
            )
        )
        plan_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in plan_models]

    def find_active_plans(self) -> List[Plan]:
        """Find all active plans."""
        result = self.session.execute(select(PlanModel).where(PlanModel.is_active))
        plan_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in plan_models]

    def find_paginated(
        self,
        plan_type: Optional[str] = None,
        is_active: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Plan], int]:
        """Find plans with pagination and filters."""
        query = select(PlanModel)
        count_query = select(PlanModel)

        # Apply filters
        if plan_type:
            query = query.where(PlanModel.plan_type == PlanTypeEnum(plan_type))
            count_query = count_query.where(
                PlanModel.plan_type == PlanTypeEnum(plan_type)
            )

        if is_active is not None:
            query = query.where(PlanModel.is_active == is_active)
            count_query = count_query.where(PlanModel.is_active == is_active)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = query.offset(offset).limit(limit).order_by(PlanModel.created_at.desc())
        result = self.session.execute(query)
        plan_models = result.scalars().all()

        plans = [self._to_domain_entity(model) for model in plan_models]
        return plans, total

    def delete(self, plan_id: UUID) -> bool:
        """Delete a plan (hard delete)."""
        result = self.session.execute(delete(PlanModel).where(PlanModel.id == plan_id))
        return result.rowcount > 0

    def get_active_subscription_count(self, plan_id: UUID) -> int:
        """Get the number of active subscriptions for a plan."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM subscriptions WHERE plan_id = :plan_id AND status = 'active'"
            ).bindparam(plan_id=plan_id)
        )
        return result.scalar() or 0

    def get_plan_pricing(
        self, plan_id: UUID
    ) -> tuple[Optional[float], Optional[float]]:
        """Get plan pricing (monthly, yearly)."""
        result = self.session.execute(
            select(PlanModel.price_monthly, PlanModel.price_yearly).where(
                PlanModel.id == plan_id
            )
        )
        pricing = result.first()

        if pricing:
            return pricing[0], pricing[1]
        return None, None

    def update_pricing(
        self,
        plan_id: UUID,
        price_monthly: Optional[float] = None,
        price_yearly: Optional[float] = None,
    ) -> bool:
        """Update plan pricing."""
        update_values = {"updated_at": datetime.now(timezone.utc)}

        if price_monthly is not None:
            update_values["price_monthly"] = price_monthly

        if price_yearly is not None:
            update_values["price_yearly"] = price_yearly

        result = self.session.execute(
            update(PlanModel).where(PlanModel.id == plan_id).values(**update_values)
        )
        return result.rowcount > 0

    def search_plans(
        self,
        query: Optional[str] = None,
        min_price: Optional[float] = None,
        max_price: Optional[float] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[Plan], int]:
        """Search plans with filters."""
        db_query = select(PlanModel)
        count_query = select(PlanModel)

        # Apply text search
        if query:
            search_filter = PlanModel.name.ilike(
                f"%{query}%"
            ) | PlanModel.description.ilike(f"%{query}%")
            db_query = db_query.where(search_filter)
            count_query = count_query.where(search_filter)

        # Apply price filters
        if min_price is not None:
            price_filter = (PlanModel.price_monthly >= min_price) | (
                PlanModel.price_yearly >= min_price * 10
            )
            db_query = db_query.where(price_filter)
            count_query = count_query.where(price_filter)

        if max_price is not None:
            price_filter = (PlanModel.price_monthly <= max_price) | (
                PlanModel.price_yearly <= max_price * 10
            )
            db_query = db_query.where(price_filter)
            count_query = count_query.where(price_filter)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        db_query = (
            db_query.offset(offset).limit(limit).order_by(PlanModel.created_at.desc())
        )
        result = self.session.execute(db_query)
        plan_models = result.scalars().all()

        plans = [self._to_domain_entity(model) for model in plan_models]
        return plans, total

    def _to_domain_entity(self, plan_model: PlanModel) -> Plan:
        """Convert SQLAlchemy model to domain entity."""
        return Plan(
            id=plan_model.id,
            name=PlanName(plan_model.name),
            description=plan_model.description,
            plan_type=plan_model.plan_type.value,
            resources=plan_model.resources,
            price_monthly=plan_model.price_monthly,
            price_yearly=plan_model.price_yearly,
            is_active=plan_model.is_active,
            features=plan_model.features,
            limits=plan_model.limits,
            created_at=plan_model.created_at,
            updated_at=plan_model.updated_at,
        )
from .sqlalchemy_plan_repository import SqlAlchemyPlanRepository
from .sqlalchemy_plan_resource_repository import SqlAlchemyPlanResourceRepository
from .sqlalchemy_subscription_repository import SqlAlchemySubscriptionRepository

__all__ = [
    "SqlAlchemyPlanRepository",
    "SqlAlchemyPlanResourceRepository",
    "SqlAlchemySubscriptionRepository"
]
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import select, update, delete, and_, text
from sqlalchemy.exc import IntegrityError

from ...domain.entities.plan_resource import PlanResource
from ...domain.repositories.plan_resource_repository import PlanResourceRepository
from ...infrastructure.database.models import (
    PlanResourceModel,
    PlanResourceTypeEnum,
    FeatureUsageModel,
)


class SqlAlchemyPlanResourceRepository(PlanResourceRepository):
    """SQLAlchemy implementation of PlanResourceRepository."""

    def __init__(self, session: Session):
        self.session = session

    def save(self, resource: PlanResource) -> PlanResource:
        """Save a plan resource entity."""
        try:
            # Check if resource exists
            existing = self.session.get(PlanResourceModel, resource.id)

            if existing:
                # Update existing resource
                existing.plan_id = resource.plan_id
                existing.resource_type = PlanResourceTypeEnum(resource.resource_type)
                existing.configuration = resource.configuration
                existing.is_enabled = resource.is_enabled
                existing.limits = resource.limits if hasattr(resource, "limits") else {}
                existing.updated_at = datetime.now(timezone.utc)

                self.session.flush()
                return self._to_domain_entity(existing)
            else:
                # Create new resource
                resource_model = PlanResourceModel(
                    id=resource.id,
                    plan_id=resource.plan_id,
                    resource_type=PlanResourceTypeEnum(resource.resource_type),
                    configuration=resource.configuration,
                    is_enabled=resource.is_enabled,
                    limits=resource.limits if hasattr(resource, "limits") else {},
                    created_at=resource.created_at,
                    updated_at=resource.updated_at,
                )

                self.session.add(resource_model)
                self.session.flush()
                return self._to_domain_entity(resource_model)

        except IntegrityError as e:
            if "plan_id" in str(e) and "resource_type" in str(e):
                raise ValueError(
                    f"Resource {resource.resource_type} already exists for this plan"
                )
            raise e

    def find_by_id(self, resource_id: UUID) -> Optional[PlanResource]:
        """Find a plan resource by ID."""
        result = self.session.execute(
            select(PlanResourceModel).where(PlanResourceModel.id == resource_id)
        )
        resource_model = result.scalar_one_or_none()

        if resource_model:
            return self._to_domain_entity(resource_model)
        return None

    def find_by_plan(self, plan_id: UUID) -> List[PlanResource]:
        """Find all resources for a plan."""
        result = self.session.execute(
            select(PlanResourceModel).where(PlanResourceModel.plan_id == plan_id)
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def find_by_plan_and_type(
        self, plan_id: UUID, resource_type: str
    ) -> Optional[PlanResource]:
        """Find a specific resource for a plan."""
        result = self.session.execute(
            select(PlanResourceModel).where(
                and_(
                    PlanResourceModel.plan_id == plan_id,
                    PlanResourceModel.resource_type
                    == PlanResourceTypeEnum(resource_type),
                )
            )
        )
        resource_model = result.scalar_one_or_none()

        if resource_model:
            return self._to_domain_entity(resource_model)
        return None

    def find_by_type(self, resource_type: str) -> List[PlanResource]:
        """Find all resources of a specific type."""
        result = self.session.execute(
            select(PlanResourceModel).where(
                and_(
                    PlanResourceModel.resource_type
                    == PlanResourceTypeEnum(resource_type),
                    PlanResourceModel.is_enabled,
                )
            )
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def find_enabled_resources(self, plan_id: UUID) -> List[PlanResource]:
        """Find enabled resources for a plan."""
        result = self.session.execute(
            select(PlanResourceModel).where(
                and_(
                    PlanResourceModel.plan_id == plan_id,
                    PlanResourceModel.is_enabled,
                )
            )
        )
        resource_models = result.scalars().all()

        return [self._to_domain_entity(model) for model in resource_models]

    def find_paginated(
        self,
        plan_id: Optional[UUID] = None,
        resource_type: Optional[str] = None,
        is_enabled: Optional[bool] = None,
        offset: int = 0,
        limit: int = 20,
    ) -> tuple[List[PlanResource], int]:
        """Find plan resources with pagination and filters."""
        query = select(PlanResourceModel)
        count_query = select(PlanResourceModel)

        # Apply filters
        if plan_id:
            query = query.where(PlanResourceModel.plan_id == plan_id)
            count_query = count_query.where(PlanResourceModel.plan_id == plan_id)

        if resource_type:
            query = query.where(
                PlanResourceModel.resource_type == PlanResourceTypeEnum(resource_type)
            )
            count_query = count_query.where(
                PlanResourceModel.resource_type == PlanResourceTypeEnum(resource_type)
            )

        if is_enabled is not None:
            query = query.where(PlanResourceModel.is_enabled == is_enabled)
            count_query = count_query.where(PlanResourceModel.is_enabled == is_enabled)

        # Get total count
        total_result = self.session.execute(count_query)
        total = len(total_result.scalars().all())

        # Get paginated results
        query = (
            query.offset(offset)
            .limit(limit)
            .order_by(PlanResourceModel.created_at.desc())
        )
        result = self.session.execute(query)
        resource_models = result.scalars().all()

        resources = [self._to_domain_entity(model) for model in resource_models]
        return resources, total

    def delete(self, resource_id: UUID) -> bool:
        """Delete a plan resource (hard delete)."""
        result = self.session.execute(
            delete(PlanResourceModel).where(PlanResourceModel.id == resource_id)
        )
        return result.rowcount > 0

    def update_configuration(
        self, resource_id: UUID, configuration: Dict[str, Any]
    ) -> bool:
        """Update resource configuration."""
        result = self.session.execute(
            update(PlanResourceModel)
            .where(PlanResourceModel.id == resource_id)
            .values(configuration=configuration, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def enable_resource(self, resource_id: UUID) -> bool:
        """Enable a plan resource."""
        result = self.session.execute(
            update(PlanResourceModel)
            .where(PlanResourceModel.id == resource_id)
            .values(is_enabled=True, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def disable_resource(self, resource_id: UUID) -> bool:
        """Disable a plan resource."""
        result = self.session.execute(
            update(PlanResourceModel)
            .where(PlanResourceModel.id == resource_id)
            .values(is_enabled=False, updated_at=datetime.now(timezone.utc))
        )
        return result.rowcount > 0

    def get_usage_count(self, resource_id: UUID) -> int:
        """Get usage count for a resource."""
        result = self.session.execute(
            text(
                "SELECT COUNT(*) FROM feature_usage WHERE resource_type = (SELECT resource_type FROM plan_resources WHERE id = :resource_id)"
            ).bindparam(resource_id=resource_id)
        )
        return result.scalar() or 0

    def record_usage(
        self,
        resource_id: UUID,
        organization_id: UUID,
        usage_date: datetime,
        usage_count: int = 1,
        usage_details: Optional[Dict[str, Any]] = None,
        cost: Optional[float] = None,
    ) -> bool:
        """Record usage of a plan resource."""
        # Get resource type first
        resource_result = self.session.execute(
            select(PlanResourceModel.resource_type).where(
                PlanResourceModel.id == resource_id
            )
        )
        resource_type_enum = resource_result.scalar_one_or_none()

        if not resource_type_enum:
            return False

        usage_model = FeatureUsageModel(
            organization_id=organization_id,
            resource_type=resource_type_enum.value,
            feature_name="general_usage",
            usage_count=usage_count,
            usage_date=usage_date,
            usage_details=usage_details or {},
            cost=cost,
        )

        self.session.add(usage_model)
        self.session.flush()
        return True

    def get_usage_statistics(
        self, resource_id: UUID, start_date: datetime, end_date: datetime
    ) -> Dict[str, Any]:
        """Get usage statistics for a resource."""
        # Get resource type
        resource_result = self.session.execute(
            select(PlanResourceModel.resource_type).where(
                PlanResourceModel.id == resource_id
            )
        )
        resource_type_enum = resource_result.scalar_one_or_none()

        if not resource_type_enum:
            return {}

        # Get usage data
        usage_result = self.session.execute(
            select(FeatureUsageModel).where(
                and_(
                    FeatureUsageModel.resource_type == resource_type_enum.value,
                    FeatureUsageModel.usage_date >= start_date,
                    FeatureUsageModel.usage_date <= end_date,
                )
            )
        )
        usage_records = usage_result.scalars().all()

        # Calculate statistics
        total_usage = sum(record.usage_count for record in usage_records)
        total_cost = sum(record.cost or 0 for record in usage_records)

        # Group by date for trends
        daily_usage = {}
        for record in usage_records:
            date_key = record.usage_date.date().isoformat()
            if date_key not in daily_usage:
                daily_usage[date_key] = {"usage": 0, "cost": 0}
            daily_usage[date_key]["usage"] += record.usage_count
            daily_usage[date_key]["cost"] += record.cost or 0

        return {
            "total_usage": total_usage,
            "breakdown": {"by_date": daily_usage},
            "costs": {"total": total_cost},
            "trends": [
                {"date": date, "usage": data["usage"], "cost": data["cost"]}
                for date, data in daily_usage.items()
            ],
        }

    def bulk_update_limits(self, resource_updates: Dict[UUID, Dict[str, Any]]) -> int:
        """Update limits for multiple resources."""
        updated_count = 0

        for resource_id, limits in resource_updates.items():
            result = self.session.execute(
                update(PlanResourceModel)
                .where(PlanResourceModel.id == resource_id)
                .values(limits=limits, updated_at=datetime.now(timezone.utc))
            )
            if result.rowcount > 0:
                updated_count += 1

        return updated_count

    def _to_domain_entity(self, resource_model: PlanResourceModel) -> PlanResource:
        """Convert SQLAlchemy model to domain entity."""
        return PlanResource(
            id=resource_model.id,
            plan_id=resource_model.plan_id,
            resource_type=resource_model.resource_type.value,
            configuration=resource_model.configuration,
            is_enabled=resource_model.is_enabled,
            limits=resource_model.limits,
            created_at=resource_model.created_at,
            updated_at=resource_model.updated_at,
        )
from shared.infrastructure.repositories.sqlalchemy_unit_of_work import (
    SQLAlchemyUnitOfWork,
)
from sqlalchemy.orm import Session
from plans.infrastructure.repositories.sqlalchemy_plan_repository import (
    SqlAlchemyPlanRepository,
)
from plans.infrastructure.repositories.sqlalchemy_plan_resource_repository import (
    SqlAlchemyPlanResourceRepository,
)
from plans.infrastructure.repositories.sqlalchemy_subscription_repository import (
    SqlAlchemySubscriptionRepository,
)


class PlansUnitOfWork(SQLAlchemyUnitOfWork):
    _repositories = {}

    def __init__(self, session: Session, repositories: list[str]):
        if "plan" in repositories:
            self._repositories.update({"plan": SqlAlchemyPlanRepository(session)})
        if "plan_resource" in repositories:
            self._repositories.update({"plan_resource": SqlAlchemyPlanResourceRepository(session)})
        if "subscription" in repositories:
            self._repositories.update({"subscription": SqlAlchemySubscriptionRepository(session)})

        super().__init__(session)
from .repositories import (
    SqlAlchemyPlanRepository, SqlAlchemyPlanResourceRepository, SqlAlchemySubscriptionRepository
)

__all__ = [
    "SqlAlchemyPlanRepository",
    "SqlAlchemyPlanResourceRepository",
    "SqlAlchemySubscriptionRepository"
]
